<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[执行文件出现lib库缺失问题解决]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0lib%E5%BA%93%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[下面介绍一个memcached执行失败的问提启动memcached时报错： 1error while loading shared libraries: libevent-2.1.so.6 下面给出解决办法： 1.用ldd命令查看 memcached 命令缺失什么库 123456[root@Autumn ~]# ldd /usr/local/bin/memcached linux-vdso.so.1 =&gt; (0x00007ffc517cf000) libevent-2.1.so.6 =&gt; not found libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f6c96860000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f6c96493000) /lib64/ld-linux-x86-64.so.2 (0x00007f6c96a7c000) 2.在安装libevent时，安装结果告诉我们libevent安装在/usr/local/lib/，可以用locate命令查看: 1locate libevent-2.1.so.6 如果没有安装locate，请查看：yum安装locate命令。 3.查看 memcached 查找依赖库的路径： 1234567891011121314[root@Autumn ~]# LD_DEBUG=libs /usr/local/bin/memcached -v 30708: find library=libevent-2.1.so.6 [0]; searching 30708: search cache=/etc/ld.so.cache 30708: search path=/lib64/tls/x86_64:/lib64/tls:/lib64/x86_64:/lib64:/usr/lib64/tls/x86_64:/usr/lib64/tls:/usr/lib64/x86_64:/usr/lib64 (system search path) 30708: trying file=/lib64/tls/x86_64/libevent-2.1.so.6 30708: trying file=/lib64/tls/libevent-2.1.so.6 30708: trying file=/lib64/x86_64/libevent-2.1.so.6 30708: trying file=/lib64/libevent-2.1.so.6 30708: trying file=/usr/lib64/tls/x86_64/libevent-2.1.so.6 30708: trying file=/usr/lib64/tls/libevent-2.1.so.6 30708: trying file=/usr/lib64/x86_64/libevent-2.1.so.6 30708: trying file=/usr/lib64/libevent-2.1.so.6 30708: /usr/local/bin/memcached: error while loading shared libraries: libevent-2.1.so.6: cannot open shared object file: No such file or directory 发现它查找了search path那一行后面的路径，我们将libevent-2.1.so.6链接到/lib64目录下： 4.链接libevent-2.1.so.6： 1$ sudo ln -s /usr/local/lib/libevent-2.1.so.6 /usr/lib64/libevent-2.1.so.6]]></content>
  </entry>
  <entry>
    <title><![CDATA[netconf-note]]></title>
    <url>%2F2019%2F11%2F26%2Fnetconf-note%2F</url>
    <content type="text"><![CDATA[TD-LTE 蜂窝移动通信分布式基站 IR 接口技术学习笔记基本缩略语 缩略词 英文解释 中文解释 BBU Base Band Unit 基带单元 CN Core Network 核心网络 C&amp;M Control and management 控制和管理 Ir Interface between the RRU and the BBU BBU 与 RRU 的接口 RRU Remote RF Unit 射频远端单元 CPRI Common Public Radio Interface 通用公共无线接口 UE User Equipment 用户设备 LOS Lost of signal 信号丢失 LOF Lost of frame 帧丢失 MME Mobility Management Entity 移动性管理实体 S-GW Serving Gateway 服务网关 EPC Evolved Packet Core 分组核心网 eNodeB Evolved Node B 演进型[Node B](https://baike.baidu.com/item/Node B/5128355)，简称eNB，LTE中基站的名称 IE information element 信息元素 Ir接口协议定义了层一和层二协议来支持用户层的数据传输，BBU和RRU单元间同步等控制信息的发送和接收。用户层的消息是以IQ数据方式发送的，不同天线载波（Antenna &amp; Carrier）的IQ数据分时在光传输通道中。Ir支持Ethernet协议来传送C&amp;M信息，利用TCP协议获取IP，该IP地址由BBU自行分配。除此之外还需要传送厂商的特殊信息。 LTE IR接口协议的层一，层二遵从CPRI Specification V4.2协议，LTE IR接口协议对CPRI协议的部分内容加以约束，以保证符合LTE IR接口协议的BBU/RRU的互操作性。LTE IR接口协议的层3定义BBU与RRU间的交互流程，消息定义，通过层三流程BBU完成对RRU的配置与查询等操作。 NetConf 协议学习我们是基于 libnetconf开源软件 进行二次开发 github 中有两套 libnetconf， 一套是 libnetconf，另外一套是 libnetconf2。libnetconf2 是正在开发中的版本，还未正式发布 网上的开源方案主要有2个： 一个是 ensuite 的 yencap + manager, 这个是基于 Python 的。MS 之前用的人比较多。 http://ensuite.sourceforge.net/ 另一个是yuma（yangclient+netconfd)，这个感觉更专业。不过用的人很少。 http://netconfcentral.org NETCONF模块设计介绍 NETCONF协议详解 Yang解析 NetConf简介之一篇文章读懂NetConf： https://github.com/CESNET/libnetconf https://blog.csdn.net/Kangyucheng/article/details/88251249 https://github.com/CESNET/libnetconf https://github.com/CESNET/libnetconf https://github.com/CESNET/libnetconf2/blob/master/src/messages_server.c https://github.com/ncclient/ncclient https://github.com/CESNET/libnetconf Reference5G 相关基础知识及架构： 5G RAN组网架构及演进分析 CPRI 基础知识： 超越CPRI：为5G前传制定计划 CPRI与eCPRI接口 NetConf 协议： Netconf配置及其RPC和Notification下发流程解析 netopeer工具的使用 【开源推介02-pyang】-你离yang模型只差一个pyang工具 An error occurred after executing the ‘commit‘’ command Set up Netopeer Server to use with NETCONFc YANG 1.1数据建模语言 Yang解析 netconf协议开发 从NETCONF/YANG看网络配置自动化 NETCONF+Yang配置TSN 软件定义网络基础—NETCONF协议 NETCONF协议详解 NETCONF协议之netopeer软件安装 netopeer工具的使用 NETCONF协议netopeer软件安装与环境搭建 SDN： SDN 是什么？ SDN介绍 DHCP： DHCP源码分析-dhcp模块 Netconf模块设计介绍： NETCONF模块设计介绍]]></content>
      <categories>
        <category>netconf</category>
      </categories>
      <tags>
        <tag>netconf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC 流媒体服务器（三）]]></title>
    <url>%2F2019%2F10%2F21%2FWebRTC%2Fmediaserver-02%2F</url>
    <content type="text"><![CDATA[各流媒体服务器的比较多人互动架构方案 多人音视频架构： Mesh 方案 MCU（Multipoint Conferencing Unit） 方案 SFU（Selective Forwarding Unit） 方案 Mesh架构模型详解 MCU架构模型详解 SFU架构模型详解 Licode架构Licode 属于 MCU 的一种架构模型 Janus流媒体服务器的架构及特点 Medooze流媒体服务器架构及特点Medooze可以作为MCU也可以作为SFU Mediasoup流媒体服务器架构及特点 Mediasoup服务器的部署与使用Mediasoup的运行环境服务器环境： Ubuntu 18.04 Nodejs 10.0 以上 npm 6.4.1 gulp 2.2.0 Nodejs的安装方式： 二进制库安装 源码安装 二进制库安装步骤： 12$ apt/brew/yum install nodejs$ apt/brew/yum install npm 源码安装： 下载 Nodejs 源码 生成 Makefile make -j 4 &amp;&amp; sudo make install Mediasoup Demo的部署下载Demo源码： 123$ git clone https://github.com/versatica/mediasoup-demo.git$ cd mediasoup-demo$ git checkout v3 配置服务： 123$ cd server$ npm install$ cp config.example.js config.js 测试： 12345# server$ npm start# app$ npm install -g gulp-cli$ gulp live 通过Nodejs实现HTTP服务最简单的http服务： require 引入 http 模块 创建 http 服务 侦听端口 12345678910// server.js'use strict'const http = require('http');const express = require('express');const app = express();const http_server = http.createServer(app);http_server.listen(9999, '0.0.0.0'); 启动Nodejs服务： 1234567$ node server.js$ nohup node server.js &amp;$ forever start server.js# macos 查看端口状态$ netstat -an | grep 9999# 测试服务是否正常$ telnet 127.0.0.1 9999 HTTPS基本知识nodejs搭建HTTPS服务： 生成HTTPS证书 引入HTTPS模块 指定证书位置，并创建HTTPS服务 通过WWW服务发布mediasoup客户端代码真正的web服务： 引入 express 模块 引入 server-index 模块 指定发布目录 12345678910111213141516171819// server.js'use strict'const https = require('https');const express = require('express');const server_index = require('server-index');const fs = require('fs');const options = &#123; key : fs.readFileSync('./cert/xxx'), cert : fs.readFileSync('./cert/xxx')&#125;const app = express();app.use(server_index('./public'));app.use(express.static('./public'));const https_server = https.createServer(options, app);https_server.listen(443, '0.0.0.0'); 1$ netstat -ntpl | grep 443 作业 - 客户端是如何与信令服务建立连接的TODO app 443端口 是如何和 server 4443端口通信的？ 如何知道信令服务器的地址？ Mediasoup的信令系统Mediasoup-demo整体分析 JavaScript 基本语法Nodejs基本语法 基础知识： 变量与类型 基本运算 if/else for循环 函数 日志打印 JavaScriptES6高级特性 Promise与EventEmitter详解 剖析serverjsTODO 阅读源码 剖析roomjsmediasoup基本概念： Room/Router Transport/WebRTCTransport Produce/Consume Room 的主要逻辑： 创建房间 信令处理 如何调试MediasoupDemoNodejs调试方法： node --inspect-brk server.js chrome://inspect 设置断点 运行时查看Mediasoup的核心信息Demo Dump工具： 方法一：export INTERACTIVE=1; ndoe server.js – 调试的时候使用 方法二：node connect.js – 查看线上内容的时候使用 Mediasoup源码分析Mediasoup 库的架构讲解Mediasoup基本概念： Worker Router Producer - 生产者 Consumer - 消费者 Transport Mediasoup包括的特性（一） 支持 IPv6 ICE / DTLS / RTP / RTCP / over UDP and TCP 支持 Simulcast 和 SVC Mediasoup包括的特性（二） 支持拥塞控制 带宽评估 支持STCP协议 - 通过修改 TCP的窗口增加和减少参数来调整发送窗口大小 ,以适应高速网络的环境。 Mediasoup包括的特性（三） 多流使用同一个 ICE + DTLS 传输通道 极其强大的性能 - 进程 + libuv，linux下一般使用epoll Mediasoup_JS_的作用1234567891011121314151617181920212223Mr.Miaow mediasoup git:(v3) $ tree lib lib├── AudioLevelObserver.js -- 用于检测声音的├── Channel.js -- 与 C++ 部分进行信令通信├── Consumer.js -- 消费者├── DataConsumer.js ├── DataProducer.js├── EnhancedEventEmitter.js -- 向C++层抛事件├── errors.js├── index.js -- 整个mediasoup库的索引，通过nodejs引入的时候第一个导入的就是indexjs├── Logger.js├── ortc.js -- 与SDP相对应，以对象方式描述SDP信息├── PipeTransport.js -- worker之间不同route流的转发├── PlainRtpTransport.js -- 普通RTP数据，不使用webrtc传输协议的，比如与ffmpeg通信├── Producer.js -- 生产者├── Router.js -- 一个房间或路由器├── RtpObserver.js -- RTP的一个观察者，回调用的├── scalabilityModes.js├── supportedRtpCapabilities.js -- 媒体协商一些相关的内容├── Transport.js -- 基类├── utils.js -- 常用的工具函数├── WebRtcTransport.js -- 浏览器的传输协议└── Worker.js -- 一个节点或进程 Mediasoup JS 的作用： 起到管理的作用 生成 json 字符串，传给 C++ WebRTC中的C++类关系图 Mediasoup启动详解1$ fg --切回到代码 1234[mediasoup-demo/server/] server.js (runMediasoupWorkers-&gt;createWorker) --&gt; [mediasoup/lib/] index.js (createWorker-&gt;new Worker) -- &gt; [mediasoup/lib/] worker.js (constructor()-&gt;spawn()) --&gt; [mediasoup/worker/src/] main.cpp 匿名管道进程间通信的原理常见的进程间通信方式（IPC） 管道：匿名管道，有名管道 socket：unixsocket，普通socket 共享内存 信号 实战通过socketpair进行进程间通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// testsocketpair.c#include&lt;stdio.h&gt;#include&lt;sys/socket.h&gt;#include&lt;string&gt;#include&lt;unistd.h&gt;int main(int argc, char* argv[])&#123; int sv[2]; if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv[]) &lt; 0) &#123; perror("socketpair error\n"); return -1; &#125; pid_t id = fork(); if (id == 0) &#123; // subprocess char *msg = "I'm children!\n"; char buffer[1024] = &#123;0, &#125;; close(sv[1]); while(1) &#123; write(sv[0], msg, strlen(msg)); sleep(1); ssize_t len = read(sv[0], buffer, sizeof(buffer)); if (len &gt; 0) &#123; buffer[len] = '\0'; printf("children, recv from parent: %s \n", buffer); &#125; &#125; &#125; else if (id &gt; 0) &#123; // parent process char *msg = "I'm father!\n"; char buffer[1024] = &#123;0, &#125;; close(sv[0]); while(1) &#123; ssize_t len = read(sv[1], buffer, sizeof(buffer)); if (len) &#123; buffer[len] = '\0'; printf("father, recv from children: %s \n", buffer); sleep(1); &#125; write(sv[1], msg, strlen(msg)); &#125; &#125; else &#123; perror("Failed to create process\n"); &#125; return 0;&#125; 1$ clang -g -o testsocketpair testsocketpair.c Mediasoup下channel创建的详细过程12345678910111213[mediasoup/lib/] index.js (createWorker-&gt;new Worker) -- &gt; [mediasoup/lib/] worker.js (constructor()-&gt;new channel()) --&gt; [mediasoup/lib/] Channel.js (socket) [mediasoup/worker/src/] main.cpp (new Channel::UnixStreamSocket(ChannelFd)) --&gt; [mediasoup/worker/src/Channel/] UnixStreamSocker.cpp (::UnixStreamSocket::UnixStreamSocket(fd, NsMessageMaxLen)) --&gt; [mediasoup/worker/src/handles/] UnixStreamSocker.cpp (static_cast&lt;uv_read_cb&gt;(onRead))) --&gt; [mediasoup/worker/src/handles/] UnixStreamSocker.cpp (onRead()) --&gt; [mediasoup/worker/src/handles/] UnixStreamSocker.cpp (OnUvRead() --&gt; UserOnUnixStreamRead()--&gt;调用子类中的实现) --&gt; [mediasoup/worker/src/Channel/] UnixStreamSocker.cpp (UserOnUnixStreamRead() --&gt; new Channel::Request()) --&gt; [mediasoup/worker/src/Channel/] Request.cpp(this 对象数据返回给创建者) --&gt; [mediasoup/worker/src/Channel/] UnixStreamSocker.cpp (this-&gt;listener-&gt;OnChannelRequest(this, request)) --&gt; [mediasoup/worker/src/] Worker.cpp (OnChannelRequest()) Mediasoup中消息的确认与事件通知返回信令确认消息： 123...request-&gt;Accept(data);... 例子： 123[mediasoup/worker/src/] Worker.cpp (OnChannelRequest(中使用request-&gt;Accept(data)情景)) [mediasoup/worker/src/Channel/] Request.cpp (Accept(data) -- &gt; this-&gt;channel-&gt;Send(jsonResponse)) --&gt; [mediasoup/worker/src/Channel/] UnixStreamSocker.cpp (Send() --&gt; Write() --&gt; 向管道写数据给 js 端) 创建Notifier： 123456...main&#123; ... Channel::Notifier::ClassInit(channel); ...&#125; 向上层发送通知： 123...Channel::Noetifier::Emit(this-&gt;id, "icestatechange", data);... Mediasoup主业务流程 123456789101112131415161718192021[mediasoup/worker/src/] Worker.cpp (OnChannelRequest()) --&gt; [mediasoup/worker/src/] Worker.cpp (new RTC::Router(routerId)) [mediasoup/worker/src/] Worker.cpp (OnChannelRequest( default )) --&gt; [mediasoup/worker/src/] Worker.cpp (router-&gt;HandleRequest(request)) --&gt; [mediasoup/worker/src/RTC] Router.cpp (HandleRequest(Channel::Request* request)) --&gt; [mediasoup/worker/src/RTC] Router.cpp (new RTC::WebRtcTransport(transportId, this, request-&gt;data)) [mediasoup/worker/src/RTC] Router.cpp (HandleRequest( default )) --&gt; [mediasoup/worker/src/RTC] Router.cpp (transport-&gt;HandleRequest(request)) --&gt; [mediasoup/worker/src/RTC] WebRtcTransport.cpp (WebRtcTransport::HandleRequest( TRANSPORT_CONNECT )) [mediasoup/worker/src/RTC] Router.cpp (HandleRequest( default )) --&gt; [mediasoup/worker/src/RTC] Transport.cpp (HandleRequest(TRANSPORT_PRODUCE)) --&gt; [mediasoup/worker/src/RTC] Transport.cpp (new RTC::Producer(producerId, this, request-&gt;data)) --&gt; [mediasoup/worker/src/RTC] Producer.cpp (Producer()) --&gt; [mediasoup/worker/src/RTC] Transport.cpp (HandleRequest(TRANSPORT_PRODUCE) --&gt; this-&gt;rtpListener.AddProducer(producer) --&gt; this-&gt;listener-&gt;OnTransportNewProducer(this, producer)) [mediasoup/worker/src/RTC] Router.cpp (HandleRequest( default )) --&gt; [mediasoup/worker/src/RTC] Transport.cpp (HandleRequest(TRANSPORT_CONSUME)) --&gt; [mediasoup/worker/src/RTC] Transport.cpp (new RTC::SimpleConsumer()) Mediasoup连接的创建基础知识回顾： 用户身份的认证 DTLS证书的认证 ice-ufrags ice-password ice-role – 服务端和客户端的选择 fingerprint 各模块初始化： 1234567...DepOpenSSL::ClassInit();DepLibSRTP::ClassInit();Utils::Crypto::ClassInit();RTC::DtlsTransport::ClassInit();RTC::SrtpSession::ClassInit();... 12345678[mediasoup/worker/src] main.cpp (main()) --&gt; [mediasoup/worker/src] main.cpp (各个模块的初始化部分) --&gt; [mediasoup/worker/src] main.cpp (RTC::DtlsTransport::ClassInit()) --&gt; [mediasoup/worker/src/RTC] DtlsTransport.cpp (ClassInit()) --&gt; ReadCertificateAndPrivateKeyFromFiles() --&gt; CreateSslCtx() --&gt; GenerateFingerprints() [mediasoup/worker/src] main.cpp (RTC::SrtpSession::ClassInit()) --&gt; [mediasoup/worker/src/RTC] SrtpSession.cpp () --&gt; srtp_install_event_handler() --&gt; OnSrtpEvent() 再论创建WebRtcTransport命令： 12[mediasoup/worker/src/RTC] WebRtcTransport.cpp () --&gt; TODO 详解创建CONNECT命令： 12[mediasoup/worker/src/RTC] WebRtcTransport.cpp (HandleRequest( TRANSPORT_CONNECT )) --&gt; TODO Mediasoup数据流转 123[mediasoup/worker/src/RTC] WebRtcTransport.cpp (WebRtcTransport()) --&gt; (new RTC::UdpSocket(this, listenIp.ip)) --&gt; TODO WebRTC大规模部署方案 总结小结： C/C++ 服务器开发 编写高性能的网络服务器 各种传输协议详解 Mediasoup的使用与详解 C/C++ 服务器开发： 如何实现一个最简单的服务器 Linux信号的处理 fork子进程 基础网络编程 编写高性能的网络服务器： 网络异步I/O事件处理 epoll + fork实现高性能网络服务器 Libevent/libuv实现高性能网络服务器 各种传输协议详解： TCP/IP 详解 UDP/RTP/RTCP 详解 WebRTC协议详解 SDP协议与媒体协商 Mediasoup的使用与详解： 各种WebRTC流媒体服务器的比较 Mediasoup服务器的部署与使用 Mediasoup的信令系统 Mediasoup源码分析 进阶： 大规模WebRTC流媒体服务器的实现 – 路由器 路由表 WebRTC源码分析 如何评测和提升音视频服务质量 OpenCV / 人工智能 OpenGL / Metal 视频特效 行业痛点： 如何通过mediasoup实现自有网络 如何更好的利用好网络 3A 问题 如何将 AI 引入到直播系统中搞服务质量 Reference mediasoup介绍 Mediasoup官网V3设计文档 Mediasoup官网V3 API文档 Ubuntu中安装部署Mediasoup Mediasoup源码分析（1）——架构分析 基于mediasoup的多方通话研究（一） mediasoup-demo解析-客户端 WebRTC网关服务器搭建：开源技术 vs 自行研发 基于webrtc多人音视频的研究（一） 如何打造自己的WebRTC 服务器 webrtc学习: 部署stun和turn服务器 C++ 技术面试基础知识总结 K6K4 笔试面试网 Opengrok的安装及配置 代码阅读工具之 —– Opengrok的安装及使用 如何阅读开源项目]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC 流媒体服务器（二）]]></title>
    <url>%2F2019%2F10%2F12%2FWebRTC%2Fmediaserver-01%2F</url>
    <content type="text"><![CDATA[WebRTC 流媒体服务器TCP/IP详解IP协议详解 TCP协议详解 Ack Number 表示可靠性： TCP三次握手 TCP四次挥手 TCP的ACK机制 TCP滑动窗口 UDP与RTP 实时通信TCP_UDP的选择 一般情况下实时通信会选择UDP，丢包重传、延迟、乱序一般是在应用层去实现。TCP在极端网络下丢包会造成很大的延迟。 TCP在实时通信中的作用一般情况下使用UDP，在UDP无法连通的情况下使用TCP，在全世界使用网络的应用80%以上都是TCP。 在连通性上TCP要比UDP好太多。 所有做音视频实时通信都要关注的一个指标：连通率。默认UDP，UDP不通使用TCP，TCP端口被限制情况下可以使用HTTPS。 UDP/RTP/RTCP详解RTP包的使用延迟要保证在800毫秒以内，更好的的500毫秒以内。 RTCP协议头的分析 RTCP PayloadType介绍 RTCP SR报文详解 RTCP RR SDES报文介绍 BYE APP报文介绍 RTCP FB协议介绍 WebRTC协议STUN协议介绍STUN协议介绍： STUN存在的目的就是进行 NAT 穿越 STUN是典型的客户端 / 服务器模式。客户端发送请求，服务器进行响应 STUN协议： 包括 20 字节的 STUN header Body 中可以有 0 个或多个 Attribute STUN Message Type消息 大小端模式： 大端模式：数据的高字节保存在内存的低地址中 小端模式：数据的高字节保存在内存的高地址中 网络字节顺序：采用大端排序方式 STUN body详解STUN Message Body： 消息头后有 0 或多个属性 每个属性进行 TLV 编码： Type、Lenght、Value ICE工作中原理什么是ICE： ICE：Interactive Connectivity Establishment 需要两端进行交互才能创建连接 Candidate类型： 主机候选者 反射候选择 中继候选者 收集Candidate： Host Candidate：本机所有 IP 和指定端口 Reflexive Candidate：STUN / TURN Relay Candidate：TURN ICE 具体做些什么： 收集 Candidate 对 Candidate Pair 排序 连通性检查 加密解密基本概念什么是非对称加密： 什么是公钥 什么是私钥 数字签名： 数字签名的作用 如何使用数字签名 数字证书： 数字证书的使用 如何获取证书 OpenSSL概念及使用OpenSSL： 什么是 OpenSSL SSL，Secure Sockets Layer TLS，Transport Layer Security TLS协议： TLS 握手协议 TLS 记录协议 OpenSSL原理： SSL_CTX SSL：代表一个 SSL 连接 SSL_Write / SSL_Read DTLS 协议： TLS 是基于 TCP 协议的 DTLS 基于 UDP 协议的 DTLS协议详解 TLS-SRTP协议详解DTLS要解决的问题： 交换密钥 加密算法 SRTP要解决的问题： 对数据加密，保证数据安全 保证数据完整性 SDP协议与WebRTC媒体协商【需要牢牢掌握】媒体协商过程 媒体协商方法： createOffer createAnswer setLocalDescription setRemoteDescription SDP协议简介什么是SDP： SDP（Session Description Protocol） 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。 SDP 规范： 多个媒体级描述 一个会话级描述 由多个 &lt;type&gt; = &lt;value&gt; 组成 会话层： 会话的名称与目的 会话的存活时间 会话中包括多个媒体信息 媒体层： 媒体格式 传输协议 传输 IP 和端口 媒体负载类型 SDP描述信息SDP描述信息： Session Description Media Description Session Description： v=(protocol version) o=(owner/create and session identifier) s=(session name) c=*(conn info - option if included at session-level) t=(time the session is active) a=*(zero or more session attribute lines) Media Description： m=(media name and transport address) c=*(conn info - option if included at session-level) b=*(bandwidth information) a=*(zero or more session attribute lines) SDP关键字段的含义及其使用 WebRTC中的SDP WebRTC中的SDP各个字段含义讲解WebRTC Offer / Answer SDP： SDP报文内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104v=0o=- 2584450093346841581 2 IN IP4 127.0.0.1s=-t=0 0 # 0 0 表示持续有效a=group:BUNDLE audio video dataa=msid-semantic: WMS 616cfbb1-33a3-4d8c-8275-a199d6005549 # WMS：WebRTC Media Streamm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126c=IN IP4 0.0.0.0 a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:sXJ3 # 安全认证的时候使用，STUN 中会使用这两个参数a=ice-pwd:yEclOTrLg1gEubBFefOqtmyV # 安全认证的时候使用a=ice-options:trickle # 新版本中使用trickle之后就没有candidate字段了，只要有合适的就检测连接，然后传输数据，如果有更好的则替换掉a=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79 # 验证证书是否被串改了a=setup:actpass # setup表示建立链接的时候是主动建立还是被动建立，actpass：既可以主动连接也可以被动作为服务端a=mid:audioa=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level # extmap 对与rtp扩展头a=sendrecv # 控制数据流向a=rtcp-mux # rtp与rtcp端口是否复用a=rtpmap:111 opus/48000/2a=rtcp-fb:111 transport-cca=fmtp:111 minptime=10;useinbandfec=1a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:110 telephone-event/48000a=rtpmap:112 telephone-event/32000a=rtpmap:113 telephone-event/16000a=rtpmap:126 telephone-event/8000a=ssrc:120276603 cname:iSkJ2vn5cYYubTve # cname 唯一的标识a=ssrc:120276603 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 1da3d329-7399-4fe9-b20f-69606bebd363a=ssrc:120276603 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:120276603 label:1da3d329-7399-4fe9-b20f-69606bebd363 # label代表了具体设备IDm=video 9 UDP/TLS/RTP/SAVPF 96 98 100 102 127 97 99 101 125c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:sXJ3a=ice-pwd:yEclOTrLg1gEubBFefOqtmyVa=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79a=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:4 urn:3gpp:video-orientationa=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=sendrecva=rtcp-muxa=rtcp-rsize # rtcp传输量太大的时候，网络承受不住的时候，可以简化成最小的trcpa=rtpmap:96 VP8/90000a=rtcp-fb:96 ccm fira=rtcp-fb:96 nacka=rtcp-fb:96 nack plia=rtcp-fb:96 goog-remba=rtcp-fb:96 transport-cca=rtpmap:97 rtx/90000 # 97 表示重传a=fmtp:97 apt=96 # 关联关系：表示 97 是 96 丢包重传的通道a=rtpmap:98 VP9/90000a=rtcp-fb:98 ccm fira=rtcp-fb:98 nacka=rtcp-fb:98 nack plia=rtcp-fb:98 goog-remba=rtcp-fb:98 transport-cca=rtpmap:100 H264/90000a=rtcp-fb:100 ccm fira=rtcp-fb:100 nacka=rtcp-fb:100 nack plia=rtcp-fb:100 goog-remba=rtcp-fb:100 transport-cca=fmtp:100 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01fa=rtpmap:102 red/90000a=rtpmap:127 ulpfec/90000a=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:99 rtx/90000a=fmtp:99 apt=98a=rtpmap:101 rtx/90000a=fmtp:101 apt=100a=rtpmap:125 rtx/90000a=fmtp:125 apt=102a=ssrc-group:FID 2580761338 611523443a=ssrc:2580761338 cname:iSkJ2vn5cYYubTvea=ssrc:2580761338 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:2580761338 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:2580761338 label:bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:611523443 cname:iSkJ2vn5cYYubTvea=ssrc:611523443 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:611523443 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:611523443 label:bf270496-a23e-47b5-b901-ef23096cd961m=application 9 DTLS/SCTP 5000c=IN IP4 0.0.0.0a=ice-ufrag:sXJ3a=ice-pwd:yEclOTrLg1gEubBFefOqtmyVa=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79a=setup:actpassa=mid:dataa=sctpmap:5000 webrtc-datachannel 1024]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC 流媒体服务器（一）]]></title>
    <url>%2F2019%2F10%2F09%2FWebRTC%2Fmediaserver%2F</url>
    <content type="text"><![CDATA[WebRTC 流媒体服务器百万级高并发WebRTC流媒体服务器设计与开发 导学 C++ 知识回顾12# macos 下编译 c++$ clang++ -std=c++11 -g -o hello helloworld.cpp 类的定义和实现C++基础 类 继承 多态 类 构造函数 析构函数 成员变量 成员函数 类的使用 命名空间命名空间格式： 1234namespace avdance&#123; ...&#125; 例子： Human.h 12345678910111213141516171819202122232425262728293031#ifndef __HUMAN_H__#define __HUMAN_H__#include &lt;iostream&gt;namespace avdance &#123; class Human &#123;public: Human()&#123; std::cout &lt;&lt; "construct human..." &lt;&lt; std::endl; age = 0; sex = 0; &#125;; ~Human()&#123; std::cout &lt;&lt; "destruct human..." &lt;&lt; std::endl; &#125;public: void setAge(int a); int getAge(); void setSex(int s); int getSex(); private: int age; // int sex; // 0:male 1:fmale&#125;; &#125; // namespace avdance#endif // __HUMAN_H__ Human.cpp 1234567891011121314151617181920212223// Human.cpp#include &lt;iostream&gt;#include "Human.h"namespace avdance &#123; void Human::setAge(int a)&#123; age = a;&#125;int Human::getAge()&#123; return age;&#125;void Human::setSex(int s)&#123; sex = s;&#125;int Human::getSex()&#123; return sex;&#125; &#125; // namespace avdance class.cpp 123456789101112131415161718192021222324252627282930// class.cpp/** * for testing class and use it * * @author xxx * @date 2019-08-10 * @copyleft GPL 2.0 */#include &lt;iostream&gt;#include "Human.h"using namespace avdance;int main(int argc, char* argv[])&#123;#if 0 Human human; human.setAge(28); human.setSex(1); std::cout &lt;&lt; "human:" &lt;&lt; human.getAge() &lt;&lt; ", " &lt;&lt; human.getSex() &lt;&lt; std::endl;#endif Human* human = new Human(); // avdance::Human* human = new avdance::Human(); human-&gt;setAge(28); human-&gt;setSex(1); std::cout &lt;&lt; "human:" &lt;&lt; human-&gt;getAge() &lt;&lt; ", " &lt;&lt; human-&gt;getSex() &lt;&lt; std::endl;&#125; 1$ clang++ -std=c++11 -g -o class Human.cpp class.cpp 继承 多态 析构函数一般都是多态的 内存地址空间与指针 堆空间与栈空间 内存的申请与释放： new delete/delete[] 深拷贝与浅拷贝 服务器基础编程Linux系统下的信号server.h 123456789101112131415161718192021222324/** * Server Class * * @author * @date 2019-08-07 * @copyleft GPL 2.0 */#ifndef __SERVER_H__#define __SERVER_H__namespace avdance &#123;class Server &#123;public: Server(); //consrtuct ~Server(); //destructpublic: void run();&#125;;&#125; //namespace avdance#endif //__SERVER_H__ server.cpp 12345678910111213141516171819202122232425262728293031/** * the implement of Server Class * * @author * @date 2019-08-07 * @copyleft GPL 2.0 */#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include "server.h"namespace avdance &#123;Server::Server()&#123; std::cout &lt;&lt; "Server construct..." &lt;&lt; std::endl;&#125;Server::~Server()&#123; std::cout &lt;&lt; "Server destruct..." &lt;&lt; std::endl;&#125;void Server::run()&#123; while(1)&#123; std::cout &lt;&lt; "the server is runing..." &lt;&lt; std::endl; ::usleep(1000000); //us sleep 1 second &#125;&#125;&#125; // namesapce avdance main.cpp 12345678910111213141516171819202122/** * a server * * @author lichao * @date 2019-08-07 * @copyleft GPL 2.0 * g++ -std=c++11 -g -o server main.cpp server.cpp */#include &lt;iostream&gt;#include "server.h"int main(int argc, char* argv[])&#123; avdance::Server* server = new avdance::Server(); if(server)&#123; server-&gt;run(); &#125; return 0;&#125; 信号： 什么是信号 信号的处理方式：忽略、捕获、默认处理 都有哪些信号：man 7 signal 安装man中文手册： 安装依赖库和工具 下载、编译、安装man中文手册 修改配置文件 解决乱码问题 12345678910# Ubuntu 下查看中文man手册方法：# 1. 打开终端，输入以下命令安装中文 man 手册$ sudo apt-get install manpages-zh# 2. 查看 man 手册安装到哪里$ dpkg -L manpages-zh | less# 查看到安装在 /usr/share/man/zh_CN# 3. 设一个中文man别名# 修改 ~/.bashrc 添加一个alias :$ alias cman='man -M /usr/share/man/zh_CN'# 4. 重启一个终端就可以用cman查看中文man手册了，当然查英文手册还是用man。 Mac 10.13 安装中文版 man 命令 [转]Mac 配置中文man手册 几个重要的信号 SIGPIPE 管道终止，当写入无人读取的管道时产生该信号，默认终止进程 SIGCHLD 子进程结束或停止时发送 SIGALRM 定时器信号，以秒为单位，默认终止进程 SIGUSR1/SIGUSR2 自定义，默认终止进程 SIGINT 键盘输入的退出信号 SIGQUIT 键盘输入的退出信号 SIGHUP 控制终端的挂起信号 SIGPIPE： 网络程序必须要处理 SIGPIPE 信号，否则当客户端退出后，服务器仍然向改 SOCKET 发送数据时，则会引起 Crash SIGCHLD： 僵尸进程是一个早已死亡的进程，但在进程表中仍占有位置 Linux 中当子进程结束的时候，他并没有完全销毁，因为父进程还要用它的信息 父进程没有处理 SIGCHLD 信号 或 调用 wait/waitpid() 等待子进程结束，就会出现僵尸进程 信号的发送与处理发送信号： 硬件方式 如 ctrl + c、ctrl + \ 等 软件方式 kill pid 通过 sigaction 安装信号 testsig.cpp 123456789101112131415161718#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sighandle(int sig) &#123; std::cout &lt;&lt; "sighup received :" &lt;&lt; sig &lt;&lt; std::endl;&#125;int main(int argc,char **argv)&#123; signal(SIGHUP, sighandle); signal(SIGINT, sighandle); signal(SIGQUIT, sighandle); pause(); return 0;&#125; server.h 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sighandler(int sig)&#123; std::cout &lt;&lt; "received signal: " &lt;&lt; sig &lt;&lt; std::endl;&#125;int main(int argc, char *argv[])&#123; struct sigaction act, oact; act.sa_handler = sighandler; sigfillset(&amp;act.sa_mask); act.sa_flags = 0; sigaction(SIGINT, &amp;act, &amp;oact); pause(); return 0;&#125; 以 fork 的方式创建后台进程后台进程： fork 方式 调用系统的 daemon API Fork 方式： fork 一个子进程，父进程退出，子进程成为孤儿进程，被 init 进程接管 调用 setsid 建立新的进程会话 将当前工作目录切换到根目录 将标注输入、输出、出错重定向到 /dev/null daemon.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;syslog.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/resource.h&gt;/** * 注释1：因为我们从shell创建的daemon子进程，所以daemon子进程会继承shell的umask，如果不清除的话，会导致daemon进程创建文件时屏蔽某些权限。 * 注释2：fork后让父进程退出，子进程获得新的pid，肯定不为进程组组长，这是setsid前提。 * 注释3：调用setsid来创建新的进程会话。这使得daemon进程成为会话首进程，脱离和terminal的关联。 * 注释4：最好在这里再次fork。这样使得daemon进程不再是会话首进程，那么永远没有机会获得控制终端。如果这里不fork的话，会话首进程依然可能打开控制终端。 * 注释5：将当前工作目录切换到根目录。父进程继承过来的当前目录可能mount在一个文件系统上，如果不切换到根目录，那么这个文件系统不允许unmount。 * 注释6：在子进程中关闭从父进程中继承过来的那些不需要的文件描述符。可以通过_SC_OPEN_MAX来判断最高文件描述符(不是很必须). * 注释7：打开/dev/null复制到0,1,2，因为dameon进程已经和terminal脱离了，所以需要重新定向标准输入，标准输出和标准错误(不是很必须). */void daemonize(const char *cmd)&#123; int i, fd0, fd1, fd2; pid_t pid; //struct rlimit rl; //struct sigaction sa; /* * Clear file creation mask. */ //umask(0);//注释1 /* * Get maximum number of file descriptors. */ //if (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; 0) // err_quit("%s: can't get file limit", cmd); /* * Become a session leader to lose controlling TTY. */ if ((pid = fork()) &lt; 0) &#123;//注释2 printf("%s: can't fork", cmd); exit(-1); &#125; else if (pid != 0) /* parent */ exit(0); setsid();//注释3 /* * Ensure future opens won't allocate controlling TTYs. */ /* sa.sa_handler = SIG_IGN; sigemptyset(&amp;sa.sa_mask); sa.sa_flags = 0; if (sigaction(SIGHUP, &amp;sa, NULL) &lt; 0) err_quit("%s: can't ignore SIGHUP", cmd); if ((pid = fork()) &lt; 0)//注释4 err_quit("%s: can't fork", cmd); */ /*else if (pid != 0) *//* parent */ /* exit(0); */ /* * Change the current working directory to the root so * we won't prevent file systems from being unmounted. */ if (chdir("/") &lt; 0) &#123;//注释5 printf("%s: can't change directory to /", cmd); exit(-1); &#125; /* * Close all open file descriptors. */ /* if (rl.rlim_max == RLIM_INFINITY) rl.rlim_max = 1024; for (i = 0; i &lt; rl.rlim_max; i++) close(i);//注释6 */ /* * Attach file descriptors 0, 1, and 2 to /dev/null. */ fd0 = open("/dev/null", O_RDWR);//注释7 //fd1 = dup(0);//注释7 //fd2 = dup(0);//注释7 dup2(fd0, STDIN_FILENO); dup2(fd0, STDOUT_FILENO); dup2(fd0, STDERR_FILENO); /* * Initialize the log file. */ /* openlog(cmd, LOG_CONS, LOG_DAEMON); if (fd0 != 0 || fd1 != 1 || fd2 != 2) &#123; syslog(LOG_ERR, "unexpected file descriptors %d %d %d",fd0, fd1, fd2); exit(1); &#125; */&#125;int main(int argc, char* argv[])&#123; daemonize("test"); while(1) &#123; sleep(60); &#125; return 0;&#125; daemon_api.cpp 12345678910111213#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; if(daemon(0,0) == -1) exit(EXIT_FAILURE); while(1) &#123; sleep(60); &#125; return 0;&#125; 进程间通信方式 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 线程间通信方式#全局变量； #Messages消息机制； #CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。 网络编程基础TCPSerever 实现原理TCP Server 网络编程基本步骤： 创建 socket，指定使用 TCP 协议 将 socket 与 地址和端口绑定 侦听端口 创建新的 socket 使用 recv 接收数据 使用 send 发送数据 使用 close 关闭连接 TCP 常见套接字选项： SO_REUSEADDR 端口处于 WAIT_TIME 仍然可以启动 SO_RCVBUG – 一般设置为4M或者8M SO_SNDBUF 重要结构体 123456789101112131415161718struct sockaddr_in&#123; sa_family_t sin_family; uint16_t sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;struct in_addr&#123; in_addr_t s_addr;&#125;struct sockaddr&#123; sa_family_t sin_family; char sin_zero[14];&#125; tcp_server.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8444#define MESSAGE_SIZE 1024int main()&#123; int ret = -1; int socket_fd = -1; int accept_fd = -1; int curpos = 0; int backlog = 10; int flag = 1; char in_buf[MESSAGE_SIZE] = &#123;0,&#125;; struct sockaddr_in local_addr, remote_addr; //create a tcp socket socket_fd = socket(AF_INET, SOCK_STREAM, 0); if ( socket_fd == -1 )&#123; perror("create socket error"); exit(1); &#125; //set option of socket ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag)); if ( ret == -1 )&#123; perror("setsockopt error"); &#125; //set local address local_addr.sin_family = AF_INET; local_addr.sin_port = htons(PORT); local_addr.sin_addr.s_addr = INADDR_ANY; bzero(&amp;(local_addr.sin_zero), 8); //bind socket ret = bind(socket_fd, (struct sockaddr *)&amp;local_addr, sizeof(struct sockaddr_in)); if(ret == -1 ) &#123; perror("bind error"); exit(1); &#125; ret = listen(socket_fd, backlog); if ( ret == -1 )&#123; perror("listen error"); exit(1); &#125; //loop for(;;)&#123; int addr_len = sizeof( struct sockaddr_in ); //accept an new connection accept_fd = accept( socket_fd, (struct sockaddr *)&amp;remote_addr, &amp;addr_len ); for(;;)&#123; memset(in_buf, 0, MESSAGE_SIZE); //receive network data and print it ret = recv( accept_fd ,(void*)in_buf ,MESSAGE_SIZE ,0 ); if(ret == 0 )&#123; break; &#125; printf( "receive message:%s\n", in_buf ); send(accept_fd, (void*)in_buf, MESSAGE_SIZE, 0); &#125; printf("close client connection...\n"); close(accept_fd); &#125; printf("quit server...\n"); close(socket_fd); return 0;&#125; TCPClient实现TCP Client 网络编程基本步骤： 创建 socket，指定使用TCP协议 使用 connect 连接服务器 使用 recv/send 接收/发送 数据 关闭 socket tcp_client.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 8111#define MESSAGE_LENGTH 1024int main()&#123; int ret = -1; int socket_fd; //server addr struct sockaddr_in serverAddr; char sendbuf[MESSAGE_LENGTH]; char recvbuf[MESSAGE_LENGTH]; int data_len; if((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; perror("socket"); return 1; &#125; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(SERVER_PORT); //inet_addr()函数，将点分十进制IP转换成网络字节序IP serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); if(connect(socket_fd, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0)&#123; perror("connect"); return 1; &#125; printf("success to connect server...\n"); while(1)&#123; memset(sendbuf, 0, MESSAGE_LENGTH); printf("&lt;&lt;&lt;&lt;send message:"); gets(sendbuf); ret = send(socket_fd, sendbuf, strlen(sendbuf), 0); if(ret &lt;= 0 )&#123; printf("the connection is disconnection!\n"); break; &#125; if(strcmp(sendbuf, "quit") == 0)&#123; break; &#125; printf("&gt;&gt;&gt; echo message:"); recvbuf[0] = '\0'; data_len = recv(socket_fd, recvbuf, MESSAGE_LENGTH, 0); recvbuf[data_len] = '\0'; printf("%s\n", recvbuf); &#125; close(socket_fd); return 0;&#125; UDP服务端与客户端实现UDP Server 网络编程基本步骤： 创建 socket，指定使用 UDP 协议 将 socket 与 地址和端口绑定 使用 recv/send 接收/发送数据 使用 close 关闭连接 udp_server.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;pthread.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char * *argv)&#123; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9876); addr.sin_addr.s_addr = htonl(INADDR_ANY); char buff_recv[512] = &#123;0&#125;; char buff_send[512] = "world"; struct sockaddr_in clientAddr; int n; int len = sizeof(clientAddr); int sock; printf("Welcome! This is a UDP server.\n"); if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) &#123; printf("socket error.\n"); exit(1); &#125; if (bind(sock, (struct sockaddr *) &amp;addr, sizeof(addr)) &lt; 0) &#123; printf("bind error.\n"); exit(1); &#125; while (1)&#123; n = recvfrom(sock, buff_recv, 511, 0, (struct sockaddr *) &amp;clientAddr, &amp;len); if (n &gt; 0) &#123; buff_recv[n] = 0; printf("recv data from client:%s %u says: %s\n", inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port), buff_recv); n = sendto(sock, buff_send, n, 0, (struct sockaddr *) &amp;clientAddr, sizeof(clientAddr)); if (n &lt; 0)&#123; printf("sendto error.\n"); break; &#125;else &#123; printf("recv error.\n"); break; &#125; &#125; &#125; return 0;&#125; udp_client.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;pthread.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char * *argv)&#123; struct sockaddr_in addr; int sock; addr.sin_family = AF_INET; addr.sin_port = htons(9876); addr.sin_addr.s_addr = inet_addr("111.231.68.13"); char buff_send[512] = "Hello"; char buff_recv[512] = &#123;0&#125;; int len = sizeof(addr); int n = 0; printf("This is a UDP client\n"); if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)&#123; printf("socket error.\n"); exit(1); &#125; if (addr.sin_addr.s_addr == INADDR_NONE)&#123; printf("Incorrect ip address!"); close(sock); exit(1); &#125; n = sendto(sock, buff_send, strlen(buff_send), 0, (struct sockaddr *) &amp;addr, sizeof(addr)); if (n &lt; 0)&#123; printf("sendto error.\n"); close(sock); &#125; n = recvfrom(sock, buff_recv, 512, 0, (struct sockaddr *) &amp;addr, &amp;len); if (n &gt; 0)&#123; buff_recv[n] = 0; printf("received from sever:"); puts(buff_recv); &#125; else if (n == 0) printf("server closed.\n"); else if (n == -1) printf("recvfrom error.\n"); close(sock); return 0;&#125; 异步 I/O 事件处理通过fork的方式实现高性能网络服务器高性能网络服务器： 通过 fork 实现高性能网络服务器 通过 select 实现高性能网络服务器 通过 epoll 实现高性能网络服务器 利用 I/O 事件处理库来实现高性能网络服务器 以 fork 方式实现高性能网络服务器： 每收到一个连接就创建一个子进程 父进程负责接收连接 通过 fork 创建子进程 fork_tcp_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8888#define MESSAGE_SIZE 1024int main()&#123; int ret = -1; int pid; int socket_fd = -1; int accept_fd = -1; int curpos = 0; int backlog = 10; int flag; struct sockaddr_in local_addr, remote_addr; char in_buf[MESSAGE_SIZE] = &#123;0,&#125;; //create a tcp socket socket_fd = socket(AF_INET, SOCK_STREAM, 0); if ( socket_fd == -1 )&#123; perror("create socket error"); exit(1); &#125; //set option of socket ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;flag, sizeof(flag)); if ( ret == -1 )&#123; perror("setsockopt error"); &#125; //set local address local_addr.sin_family = AF_INET; local_addr.sin_port = htons(PORT); local_addr.sin_addr.s_addr = INADDR_ANY; bzero(&amp;(local_addr.sin_zero), 8); //bind socket ret = bind(socket_fd, (struct sockaddr *)&amp;local_addr, sizeof(struct sockaddr_in)); if(ret == -1 ) &#123; perror("bind error"); exit(1); &#125; ret = listen(socket_fd, backlog); if ( ret == -1 )&#123; perror("listen error"); exit(1); &#125; for(;;)&#123; int addr_len = sizeof( struct sockaddr_in ); //accept an new connection accept_fd = accept( socket_fd, (struct sockaddr *)&amp;remote_addr, &amp;addr_len ); //create a sub process pid = fork(); //子进程 if( pid == 0 )&#123; for(;;)&#123; memset(in_buf, 0, MESSAGE_SIZE); ret = recv(accept_fd ,&amp;in_buf, MESSAGE_SIZE, 0); if(ret == 0)&#123; break; &#125; printf( "receive message:%s\n", in_buf ); send(accept_fd, (void*)in_buf, MESSAGE_SIZE, 0); &#125; printf("close client connection...\n"); close(accept_fd); &#125; //parent process //sleep(1000); &#125; if(pid != 0 )&#123; printf("quit server...\n"); close(socket_fd); &#125; return 0;&#125; fork 方式带来的问题： 资源被长期占用 分配子进程花费时间长 通过select实现高性能服务器什么是异步 I/O： 所谓异步 I/O，是指以事件触发的机制来对 I/O 操作进行处理。 与多进程和多线程技术相比，异步 I/O 技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。 以 select 方式实现高性能网络服务器： 遍历文件描述符集中的所有描述符，找出有变化的描述符 对于侦听的 socket 和 数据处理的 socket 要区别对待 socket 必须设置为非阻塞方式工作 重要 API： FD_ZERO、FD_SET、FD_ISSET flag fcntl(fd, F_SETFL/F_GETFL, flag) events select(nfds, readfds, writefds, exceptfds, timeout) select_tcp_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8888#define FD_SIZE 1024#define MESSAGE_SIZE 1024int main()&#123; int ret = -1; int pid; int accept_fd = -1; int socket_fd = -1; int accept_fds[FD_SIZE] = &#123;-1, &#125;; int curpos = -1; int maxpos = 0; int backlog = 10; int flags = 1; //open REUSEADDR option int max_fd = -1; fd_set fd_sets; int events=0; struct sockaddr_in local_addr, remote_addr; //create a tcp socket socket_fd = socket(AF_INET, SOCK_STREAM, 0); if ( socket_fd == -1 )&#123; perror("create socket error"); exit(1); &#125; //set option of socket ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;flags, sizeof(flags)); if ( ret == -1 )&#123; perror("setsockopt error"); &#125; //NONBLOCK flags = fcntl(socket_fd, F_GETFL, 0); fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK); //set local address local_addr.sin_family = AF_INET; local_addr.sin_port = htons(PORT); local_addr.sin_addr.s_addr = INADDR_ANY; bzero(&amp;(local_addr.sin_zero), 8); //bind socket ret = bind(socket_fd, (struct sockaddr *)&amp;local_addr, sizeof(struct sockaddr_in)); if(ret == -1 ) &#123; perror("bind error"); exit(1); &#125; ret = listen(socket_fd, backlog); if ( ret == -1 )&#123; perror("listen error"); exit(1); &#125; max_fd = socket_fd; //每次都重新设置 max_fd for(int i=0; i&lt; FD_SIZE; i++)&#123; accept_fds[i] = -1; &#125; for(;;) &#123; FD_ZERO(&amp;fd_sets); //清空sets FD_SET(socket_fd, &amp;fd_sets); //将socket_fd 添加到sets for(int k=0; k &lt; maxpos; k++)&#123; if(accept_fds[k] != -1)&#123; if(accept_fds[k] &gt; max_fd)&#123; max_fd = accept_fds[k]; &#125; printf("fd:%d, k:%d, max_fd:%d\n", accept_fds[k], k, max_fd); FD_SET(accept_fds[k], &amp;fd_sets); //继续向sets添加fd &#125; &#125; //遍历所有的fd events = select( max_fd + 1, &amp;fd_sets, NULL, NULL, NULL ); if(events &lt; 0) &#123; perror("select"); break; &#125;else if(events == 0)&#123; printf("select time out ......"); continue; &#125;else if( events )&#123; printf("events:%d\n", events); if( FD_ISSET(socket_fd, &amp;fd_sets))&#123; // 如果来的是新连接 printf("listen event :1\n"); for( int a=0; a &lt; FD_SIZE; a++)&#123; if(accept_fds[a] == -1)&#123; curpos = a; break; &#125; &#125; if(a == FD_SIZE)&#123; printf("the connection is full!\n"); continue; &#125; int addr_len = sizeof( struct sockaddr_in ); accept_fd = accept(socket_fd, (struct sockaddr *)&amp;remote_addr, &amp;addr_len); //创建一个新连接的fd int flags = fcntl(accept_fd, F_GETFL, 0); //取出新连接的 fd 的相关选项 fcntl(accept_fd, F_SETFL, flags | O_NONBLOCK); //设置为非阻塞 accept_fds[curpos] = accept_fd; if(curpos+1 &gt; maxpos)&#123; maxpos = curpos + 1; &#125; if(accept_fd &gt; max_fd)&#123; max_fd = accept_fd; &#125; printf("new connection fd:%d, curpos = %d \n",accept_fd, curpos); &#125; for(int j=0; j &lt; maxpos; j++ )&#123; if( (accept_fds[j] != -1) &amp;&amp; FD_ISSET(accept_fds[j], &amp;fd_sets))&#123; //有事件时 printf("accept event :%d, accept_fd: %d\n",j, accept_fds[j]); char in_buf[MESSAGE_SIZE]; memset(in_buf, 0, MESSAGE_SIZE); int ret = recv(accept_fds[j], &amp;in_buf, MESSAGE_SIZE, 0); if(ret == 0)&#123; close(accept_fds[j]); accept_fds[j] = -1; &#125; printf( "receive message:%s\n", in_buf ); send(accept_fds[j], (void*)in_buf, MESSAGE_SIZE, 0); &#125; &#125; &#125; &#125; printf("quit server...\n"); close(socket_fd); return 0;&#125; 设置 select 超时时间（一般情况想设置成500毫秒）： 1234struct timeval &#123; long tv_sec; /*秒*/ long tv_usec; /*微妙*/&#125; select 函数输入参数的意义： 我们关心的文件描述符 对每个文件描述符我们关心的状态（读，写，异常） 我们要等待的时间（永远（NULL），一段时间（timeval），不等待（0）） 从 select 函数得到的信息： 已经做好准备的文件描述符的个数 对于读、写、异常，那些文件描述符准备好了 理解 select 模型： 理解 select 模型的关键在于理解 fd_set 类型 fd_set 就是多个整型字的集合，每个 bit 代表一个文件描述符 FD_ZERO 表示将说有的位置 0 FD_SET 是将 fd_set 中的某一位置 1 select 函数执行后，系统会修改 fd_set 中的内容 select 函数执行后，应用层要重新设置 fd_set 中的内容 epoll实现高性能服务器epoll基本知识使用 Epoll 的好处： 没有文件描述符的限制 工作效率不会随着文件描述符的增加而下降 Epoll 经过系统优化更高效 Epoll 事件的触发模式（默认是水平触发模式）： Level Trigger （水平触发）没有处理反复发送 Edge Trigger （边缘触发）只发送一次 Epoll 重要的 API ： int epoll_create() 参数无意义，可忽略 int epoll_ctl(epfd, op, fd, struct epoll_event *event) int epoll_wait(epfd, events, maxevents, timeout) Epoll 的事件： EPOLLET – 可以设置边缘触发模式 EPOLLIN EPOLLOUT EPOLLPRI – 出现中断的时候 EPOLLERR EPOLLHUB – 程序挂起的时候出现 epoll_ctl 相关操作： EPOLL_CTL_ADD EPOLL_CTL_MOD – 修改 EPOLL_CTL_DEL Epoll 重要的结构体： 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /*Epoll events*/ epoll_data_t data; /*User data variable*/&#125; epoll_tcp_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8888#define FD_SIZE 20#define MAX_EVENTS 20#define TIME_OUT 500#define MESSAGE_SIZE 1024int main()&#123; int ret = -1; int socket_fd = -1; int accept_fd = -1; int flags = 1; int backlog = 10; struct sockaddr_in local_addr, remote_addr; struct epoll_event ev, events[FD_SIZE]; int epoll_fd = -1; int event_number = 0; //creat a tcp socket socket_fd = socket(AF_INET, SOCK_STREAM, 0); if ( socket_fd == -1 )&#123; perror("create socket error"); exit(1); &#125; //set REUSERADDR ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;flags, sizeof(flags)); if ( ret == -1 )&#123; perror("setsockopt error"); &#125; //set NONBLOCK flags = fcntl(socket_fd, F_GETFL, 0); fcntl(socket_fd, F_SETFL, flags|O_NONBLOCK); //set address local_addr.sin_family = AF_INET; local_addr.sin_port = htons(PORT); local_addr.sin_addr.s_addr = INADDR_ANY; bzero(&amp;(local_addr.sin_zero),8); //bind addr ret = bind(socket_fd, (struct sockaddr *)&amp;local_addr, sizeof(struct sockaddr_in)); if( ret == -1 ) &#123; perror("bind error"); exit(1); &#125; if (listen(socket_fd, backlog) == -1 )&#123; perror("listen error"); exit(1); &#125; //create epoll epoll_fd = epoll_create(256);//the size argument is ignored ev.data.fd=socket_fd; ev.events=EPOLLIN; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;ev); //将socket_fd 添加到epoll中 for(;;)&#123; //events 表示一共有多少事件被侦听 //MAX_EVENTS 表示在 events 个事件中，本次调用最多能返回多少个被触发的事件 //TIME_OUT 表示本次调用最多等多长时间 //event_number 表示本次调用真正有多少事件被解发 event_number = epoll_wait(epoll_fd, events, MAX_EVENTS, TIME_OUT); for(int i=0; i &lt; event_number; i++)&#123; if(events[i].data.fd == socket_fd)&#123; // 如果是侦听端口的事件 printf("listen event... \n"); int addr_len = sizeof( struct sockaddr_in ); accept_fd = accept(socket_fd, (struct sockaddr *)&amp;remote_addr, &amp;addr_len); //将新创建的socket设置为 NONBLOCK 模式 flags = fcntl(accept_fd, F_GETFL, 0); fcntl(accept_fd, F_SETFL, flags|O_NONBLOCK); ev.data.fd=accept_fd; ev.events=EPOLLIN | EPOLLET; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, accept_fd, &amp;ev); printf("new accept fd:%d\n",accept_fd); &#125; else if(events[i].events &amp; EPOLLIN)&#123; //printf("accept event :%d\n",i); char in_buf[MESSAGE_SIZE]; memset(in_buf, 0, MESSAGE_SIZE); //receive data ret = recv( events[i].data.fd, &amp;in_buf, MESSAGE_SIZE, 0 ); if(ret == MESSAGE_SIZE )&#123; printf("maybe have data...."); &#125; if(ret &lt;= 0)&#123; switch (errno)&#123; case EAGAIN: //说明暂时已经没有数据了，要等通知 break; case EINTR: //被终断了，再来一次 printf("recv EINTR... \n"); ret = recv(events[i].data.fd, &amp;in_buf, MESSAGE_SIZE, 0); break; default: printf("the client is closed, fd:%d\n", events[i].data.fd); epoll_ctl(epoll_fd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev); close(events[i].data.fd); &#125; &#125; printf("&gt;&gt;&gt;receive message:%s\n", in_buf); send(events[i].data.fd, &amp;in_buf, ret, 0); &#125; &#125; &#125; return 0;&#125; epoll+fork实现高性能网络服务器epoll_fork_tcp_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8111#define FD_SIZE 20#define MAX_EVENTS 20#define TIME_OUT 500#define MESSAGE_SIZE 1024#define NB_PROCESS 4int main()&#123; int ret = -1; int socket_fd = -1; int accept_fd = -1; int flags = 1; int backlog = 10; struct sockaddr_in local_addr,remote_addr; struct epoll_event ev, events[FD_SIZE]; int epoll_fd = -1; int event_number = 0; int pid; int status; int max_subprocess = NB_PROCESS; //creat a tcp socket socket_fd = socket(AF_INET, SOCK_STREAM, 0); if ( socket_fd == -1 )&#123; perror("create socket error"); exit(1); &#125; //set REUSERADDR ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;flags, sizeof(flags)); if ( ret == -1 )&#123; perror("setsockopt error"); &#125; //set NONBLOCK flags = fcntl(socket_fd, F_GETFL, 0); fcntl(socket_fd, F_SETFL, flags|O_NONBLOCK); //set address local_addr.sin_family = AF_INET; local_addr.sin_port = htons(PORT); local_addr.sin_addr.s_addr = INADDR_ANY; bzero(&amp;(local_addr.sin_zero),8); //bind addr ret = bind(socket_fd, (struct sockaddr *)&amp;local_addr, sizeof(struct sockaddr_in)); if( ret == -1 ) &#123; perror("bind error"); exit(1); &#125; if (listen(socket_fd, backlog) == -1 )&#123; perror("listen error"); exit(1); &#125; //fork some subprocess for(int a=0; a &lt; max_subprocess; a++)&#123; if(pid !=0)&#123; pid = fork(); &#125; &#125; //child process if(pid == 0) &#123; printf("create an new child process..."); //create epoll epoll_fd = epoll_create(256);//the size argument is ignored ev.data.fd=socket_fd; // 多个子进程使用一个监听 fd 会有一些问题 ev.events=EPOLLIN; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;ev); //将socket_fd 添加到epoll中 for(;;)&#123; //events 表示一共有多少事件被侦听 //MAX_EVENTS 表示在events个事件中，本次调用最多能返回多少个被解发的事件 //TIME_OUT 表示本次调用最多等多长时间 //event_number 表示本次调用真正有多少事件被解发 event_number = epoll_wait(epoll_fd, events, MAX_EVENTS, TIME_OUT); for(int i=0; i &lt; event_number; i++)&#123; if(events[i].data.fd == socket_fd)&#123; // 如果是侦听端口的事件 printf("listen event... \n"); int addr_len = sizeof( struct sockaddr_in ); accept_fd = accept(socket_fd, (struct sockaddr *)&amp;remote_addr, &amp;addr_len); //将新创建的socket设置为 NONBLOCK 模式 flags = fcntl(accept_fd, F_GETFL, 0); fcntl(accept_fd, F_SETFL, flags|O_NONBLOCK); ev.data.fd=accept_fd; ev.events=EPOLLIN | EPOLLET; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, accept_fd, &amp;ev); printf("new accept fd:%d\n",accept_fd); &#125; else if(events[i].events &amp; EPOLLIN)&#123; //printf("accept event :%d\n",i); char in_buf[MESSAGE_SIZE]; memset(in_buf, 0, MESSAGE_SIZE); //receive data ret = recv( events[i].data.fd, &amp;in_buf, MESSAGE_SIZE, 0 ); if(ret == MESSAGE_SIZE )&#123; printf("maybe have data...."); &#125; if(ret &lt;= 0)&#123; switch (errno)&#123; case EAGAIN: ret = recv(events[i].data.fd, &amp;in_buf, MESSAGE_SIZE, 0); break; case EINTR: printf("recv EINTR... \n"); break; default: printf("the client is closed, fd:%d\n", events[i].data.fd); epoll_ctl(epoll_fd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev); close(events[i].data.fd); ; &#125; &#125; printf("&gt;&gt;&gt;receive message:%s\n", in_buf); send(events[i].data.fd, &amp;in_buf, ret, 0); &#125; &#125; &#125; &#125;else &#123;// pid != 0 //wait child process to quit wait(&amp;status); #if 0 do &#123; pid = waitpid(-1, NULL, 0); // -1 表示所有等待所有子进程退出 &#125; while(pid != -1); #endif &#125; return 0;&#125; epoll + fork 异步事件的惊群现象： 解决方法： 将侦听的套接字只放在一个进程里边处理，这个进程专门处理连接或者其他一些事务。缺点：大并发连接的时候负担比较大 还是负载，分担出去，在某一个时刻只有一个epoll来管理侦听 加锁 libevent实现高性能网络服务器比较有名的异步 IO 处理库的介绍比较有名的异步事件处理库： libevent – 跨平台 libevthp – 底层使用的是libevent，处理http比较高效 libuv – nodejs 底层使用的库 libev – 只支持linux libevent 重要的函数： event_base_new event_base_dispatch – 事件处理 event_new event_add event_del event_free libevent编译与安装： libevent wget -c addr --no-check-certificate ./configure --prefix=/usr/local/libevent make &amp;&amp; sudo make install bufferevent 的作用： 从外面看它就是一个缓冲区，可以与socket绑定 内部由输入和输出缓冲区组成 每一个socket对应一个 bufferevent 当socket有事件触发时，可以设置回调函数 libevent_tcp_server.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;event2/buffer.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8111void on_read_cb(struct bufferevent *bev, void* ctx)&#123; struct evbuffer *input = NULL; struct evbuffer *output = NULL; input = bufferevent_get_input(bev); output = bufferevent_get_output(bev); evbuffer_add_buffer(output, input); // 将input数据拷贝到output&#125;void on_accept_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void* ctx)&#123; struct event_base *base = NULL; struct bufferevent *bev = NULL; base = evconnlistener_get_base(listener); bev = bufferevent_socket_new(base, fd, 0); bufferevent_enable(bev, EV_READ | EV_WRITE); bufferevent_setcb(bev, on_read_cb, NULL, NULL, NULL);&#125;int main(int argc, char* argv[])&#123; struct sockaddr_in serveraddr; struct event_base *base = NULL; struct evconnlistener *listener = NULL; base = event_base_new(); serveraddr.sin_family = AF_INET; serveraddr.sin_port = htons(PORT); serveraddr.sin_addr.s_addr = INADDR_ANY; listener = evconnlistener_new_bind(base, on_accept_cb, NULL, LEV_OPT_REUSEABLE, 10, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); event_base_dispath(base); return 0;&#125; 123456789101112# 编译完设置 libevent 环境变量$ vi ~/.bashrcunset PKG_CONFIG_LIBexport PKG_CONFIG_PATH=/usr/local/libevent/lib/pkgconfig:$PKG_CONFIG_PATHexport LD_LIBRARY_PATH=/usr/local/libevent/lib:$LD_LIBRARY_PATH# 查看库路径、头文件路径，以及要引用的库名字$ pkg-config --libs --cflags libevent-I/usr/local/libevent/include -L/usr/local/libevent/lib -levent$ evn | grep LDLD_LIBRARY_PATH=/usr/local/libevent/lib:$ g++ -g -o libevent_tcp_server libevent_tcp_server.cpp `pkg-config --libs --cflags libevent`$ netstat -ntpl | grep 8111 libevent实现对UDP的处理libuv实现对UDP的处理]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侯捷C++讲义]]></title>
    <url>%2F2019%2F09%2F03%2FProgram-C%2FHouJieCPlus%2F</url>
    <content type="text"><![CDATA[面向对象高级编程 Part1 面向对象高级编程 Part2 内存管理 Part1 内存管理 Part2]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习笔记]]></title>
    <url>%2F2019%2F08%2F27%2FAndroid%2Fandroid-learn-note%2F</url>
    <content type="text"><![CDATA[Android 开发者文档 Android 官方 开发者文档 中文翻译项目 Progressive Web App 简单介绍一下Progressive Web App(PWA) 下一代 Web 应用模型 —— Progressive Web App LAVAS 基于 Vue.js 的 PWA 解决方案 PWA超简单入门 PWA，现代前端必会的黑科技 Java 知识汇总 JAVA的abstract修饰符 &amp;&amp; 接口interface用法 &amp;&amp; 抽象类和interface的差别]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 常用快捷键]]></title>
    <url>%2F2019%2F08%2F12%2FMacOS%2Fmac-clion-md%2F</url>
    <content type="text"><![CDATA[温馨提示：在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，分别为 Mac OS X 和 Mac OS X 10.5+， 其中 Mac OS X 10.5+ 为 IntelliJ IDEA 默认的快捷键版本。此外，建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。 Mac 键盘符号和修饰键说明 ⌘ ——&gt; Command ⇧ ——&gt; Shift ⌥ ——&gt; Option ⌃ ——&gt; Control ↩︎ ——&gt; Return/Enter ⌫ ——&gt; Delete ⌦ ——&gt; 向前删除键(Fn + Delete) ↑ ——&gt; 上箭头 ↓ ——&gt; 下箭头 ← ——&gt; 左箭头 → ——&gt; 右箭头 ⇞ ——&gt; Page Up(Fn + ↑) ⇟ ——&gt; Page Down(Fn + ↓) ⇥ ——&gt; 右制表符(Tab键) ⇤ ——&gt; 左制表符(Shift + Tab) ⎋ ——&gt; Escape(Esc) End ——&gt; Fn + → Home ——&gt; Fn + ← Editing（编辑） 快捷键 作用 Control + Space 基本的代码补全（补全任何类、方法、变量） Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型） Command + Shift + Enter 自动结束代码，行末自动添加分号 Command + P 显示方法的参数信息 Control + J 快速查看文档 Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） Command + 鼠标放在代码上 显示代码简要信息 Command + F1 在错误或警告处显示具体描述信息 Command + N, Control + Enter, Control + N 生成代码（getter、setter、hashCode、equals、toString、构造函数等） Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + Option + T 包围代码（使用if…else、try…catch、for、synchronized等包围选中的代码） Command + / 注释 / 取消注释与行注释 Command + Option + / 注释 / 取消注释与块注释 Option + 方向键上 连续选中代码块 Option + 方向键下 减少当前选中的代码块 Control + Shift + Q 显示上下文信息 Option + Enter 显示意向动作和快速修复代码 Command + Option + L 格式化代码 Control + Option + O 优化 import Control + Option + I 自动缩进线 Tab / Shift + Tab 缩进代码 / 反缩进代码 Command + X 剪切当前行或选定的块到剪贴板 Command + C 复制当前行或选定的块到剪贴板 Command + V 从剪贴板粘贴 Command + Shift + V 从最近的缓冲区粘贴 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 Command + Shift + U 大小写切换 Command + Shift + ] / Command + Shift + [ 选择直到代码块结束 / 开始 Option + Fn + Delete 删除到单词的末尾 Option + Delete 删除到单词的开头 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift + 加号 展开所以代码块 Command + Shift + 减号 折叠所有代码块 Command + W 关闭活动的编辑器选项卡 Search / Replace（查询/替换） 快捷键 作用 Double Shift 查询任何东西 Command + F 文件内查找 Command + G 查找模式下，向下查找 Command + Shift + G 查找模式下，向上查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径） Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在 Keymap 中设置） Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在 Keymap 中设置） Usage Search（使用查询） 快捷键 作用 Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法 Command + Shift + F7 在文件中突出显示的用法 Command + Option + F7 显示用法 Compile and Run（编译和运行） 快捷键 作用 Command + F9 编译 Project Command + Shift + F9 编译选择的文件、包或模块 Control + Option + R 弹出 Run 的可选择菜单 Control + Option + D 弹出 Debug 的可选择菜单 Control + R 运行 Control + D 调试 Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 Debugging（调试） 快捷键 作用 F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 跳出 Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点 Option + F8 计算表达式（可以更改变量值使其生效） Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） Command + Shift + F8 查看断点信息 Navigation（导航） 快捷键 作用 Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠 Command + Option + O 前往指定的变量 / 方法 Control + 方向键左 / Control + 方向键右 左右切换打开的编辑 tab 页 F12 返回到前一个工具窗口 Esc 从工具窗口进入代码文件窗口 Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 Command + Shift + F4 关闭活动 run/messages/find/… tab Command + L 在当前文件跳转到某一行的指定处 Command + E 显示最近打开的文件记录列表 Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置 Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方 Command + Shift + Delete 跳转到最后一个编辑的地方 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的 Finder) Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Option + Space, Command + Y 快速打开光标所在方法、类的定义 Control + Shift + B 跳转到类型声明处 Command + U 前往当前光标所在方法的父类的方法 / 接口定义 Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个 / 后一个方法名位置 Command + ] / Command + [ 移动光标到当前所在代码的花括号开始 / 结束位置 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） Control + H 显示当前类的层次结构 Command + Shift + H 显示方法层次结构 Control + Option + H 显示调用层次结构 F2 / Shift + F2 跳转到下一个 / 上一个突出错误或警告的位置 F4 / Command + 方向键下 编辑 / 查看代码源 Option + Home 显示到当前文件的导航条 F3 选中文件 / 文件夹 / 代码行，添加 / 取消书签 Option + F3 选中文件 / 文件夹/代码行，使用助记符添加 / 取消书签 Control + 0…Control + 9 定位到对应数值的书签位置 Command + F3 显示所有书签 Refactoring（重构） 快捷键 作用 F5 复制文件到指定目录 F6 移动文件到指定目录 Command + Delete 在文件上为安全删除文件，弹出确认框 Shift + F6 重命名文件 Command + F6 更改签名 Command + Option + N 一致性 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option + P 提取参数 VCS / Local History（版本控制 / 本地历史记录） 快捷键 作用 Command + K 提交代码到版本控制器 Command + T 从版本控制器更新代码 Option + Shift + C 查看最近的变更记录 Control + C 快速弹出版本控制器操作面板 Live Templates（动态代码模板） 快捷键 作用 Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住 Command + J 插入自定义动态代码模板 General（通用） 快捷键 作用 Command + 1…Command + 9 打开相应编号的工具窗口 Command + S 保存所有 Command + Option + Y 同步、刷新 Control + Command + F 切换全屏模式 Command + Shift + F12 切换最大化编辑器 Option + Shift + F 添加到收藏夹 Option + Shift + I 检查当前文件与当前的配置文件 `Control + `` 快速切换当前的 scheme（切换主题、代码样式等） Command + , 打开 IDEA 系统设置 Command + ; 打开项目结构对话框 Shift + Command + A 查找动作（可设置相关选项） Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上 delete，则是关闭对应选中的窗口） ​ ​ ​ ​ ​]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[茶知识]]></title>
    <url>%2F2019%2F07%2F19%2Ftea%2F</url>
    <content type="text"><![CDATA[全网销量最高的近20款茶评测,买前看这一篇就够了 喝茶选对时间，比吃保健品有用100倍 喝普洱生茶选大益还是中茶还是下关，有木有推荐？ 请问有哪些茶企在做普洱中期茶？ 花茶搭配养生 六大茶发酵程度根据加工方式和发酵程度的不同，国内现在一般习惯将茶叶分为六大类。 绿茶（不发酵） 黄茶（10-20%发酵度） 白茶（20-30%发酵度） 青茶（30-60%发酵度） 红茶（80-90%发酵度） 黑茶（100%发酵度） 发酵程度越高的茶，茶性就更温和，对胃的刺激性就不大，比如红茶、黑茶就适合胃不太好的人喝； 相反，不发酵或是轻度发酵的茶，茶性偏寒性，适合降火去燥，适合在夏天饮用，但脾胃较弱的人就应该少喝。 六大茶类的特点1. 绿茶（清汤绿叶）六大茶类中，绿茶的全年消费量，是其他五类茶的总和的两倍以上,是我国产量最多的一类茶叶，目前占世界茶叶市场绿茶贸易量的70％左右。 特点功效：茶多酚含量高，有很好的防辐射作用，适合常在电脑前工作的人。 主要类型：蒸青绿茶、晒青绿茶、烘青绿茶、炒青绿茶。 品质特征：具有“清汤绿叶”的品质特点，色泽绿润，内质香气高鲜，汤色绿明，滋味纯和而爽口，富有收敛性，叶底嫩绿明亮。 工艺流程：鲜叶采摘—摊晾—杀青—揉捻（做形）—干燥 冲泡要点：用 80-90度的水。绿茶的重点在与口感的鲜美和鲜嫩的颜色，所以温泡绿茶才是王道，冲泡时，慢慢将茶叶浸润，即可以保持茶汤鲜美，也能延长冲泡次数。 代表产品：安吉白茶、西湖龙井、洞庭碧螺春、安化松针、安吉白茶、六安瓜片、太平猴魁、华顶云雾等。 2. 黄茶 （黄汤黄叶）特点功效：含有大量的消化酶，对脾胃有好处，适合消化不良，食欲不振，少运动的人。 主要类型：黄芽茶、黄小芽和黄大芽。 品质特征：黄茶主要是“色黄、汤黄、叶底黄”，外形金黄色，毫尖显露，芽壮叶肥，汤色橙黄，香气清高，滋味醇厚爽口。 工艺流程：鲜叶采摘—杀青—揉捻—闷黄—干燥 冲泡要点：黄茶芽头嫩，不能使用高温冲泡，用 85度左右的开水，螺旋状冲泡，千万别闷盖子，否则味道会很“涩”。 代表产品： 黄芽茶——湖南岳阳 君山银针、四川的蒙顶黄芽等 黄小茶——湖南岳阳的北港毛尖、湖南宁乡的沩山毛尖、温州黄汤等 黄大茶——安徽的霍山黄大茶、广东大叶青等 3. 白茶传统白茶不炒不揉片状茶，因茸毛不脱，白毫满身而得名。 特点功效：“女人茶”，含有活性酶，能促进脂肪代谢，血糖平衡，清脑明目。适合三高人群，和青少年。 主要类型：白芽茶和白叶茶。 品质特征：茶芽完整，形态自然、白毫显露、香气清鲜、滋味甘醇、持久耐泡。 工艺流程：鲜叶采摘—萎凋（日晒）—干燥。 冲泡要点：淡淡的茶香与绵甜的汤水，一般用85度左右的开水冲泡，若是老白茶的话，可用高温冲泡，回甘更好，绵厚而丰润。 代表产品：白牡丹、白毫银针、贡眉、寿眉等。 4. 青茶-乌龙茶（绿叶红镶边）青茶属半发酵茶，即制作时适当发酵，使叶片稍有红变，是介于绿茶与红茶之间的一种茶类。它既有绿茶的鲜浓，又有红茶的甜醇。 特点功效：“美容茶”有较好的降血脂、降胆固醇、助消化的功效。适合体型肥胖者的人群。 主要类型：闽北乌龙、闽南乌龙、广东乌龙和台湾乌龙。 品质特征：采用成熟的对口叶为原料，滋味甘醇、香气馥郁，讲究“韵味”，叶底有明显的绿叶红镶边的特征。 工艺流程：鲜叶采摘—萎凋—做青—炒青—揉捻（做形）—干燥 冲泡要点：乌龙茶需要用沸水冲泡。水质、水温、置茶量、冲泡的时间等，都是影响冲泡乌龙茶的重要因素。除了螺旋注水外还可以用定点注水，最好是在杯壁定点，不要直接将水冲在茶叶上，这样可避免出现苦涩感。 条形的单丛茶和岩茶的冲泡要点是即冲即出，而颗粒形乌龙茶时间可以稍微长一点，等茶叶舒展之后再加快出汤速度，而泡到五泡以后，都需要延长时间。 代表产品： 闽北乌龙：武夷岩茶（大红袍、水仙、肉桂、铁罗汉、白鸡冠、水金龟） 闽南乌龙：铁观音、奇兰、黄金桂 广东乌龙：凤凰单枞、凤凰水仙、岭头单枞 台湾乌龙：冻顶乌龙、包种 5. 红茶 （红叶红汤）红茶加工时不经杀青，直接萎凋，使鲜叶失去部分水分，再揉捻，然后发酵，使所含的茶多酚氧化，变成红色的化合物。这种化合物一部分溶于水，一部分不溶于水，而积累在叶片中，从而形成红汤、红叶。 特点功效：所含咖啡碱和芳香物质有利尿作用，茶性温和暖胃，还有舒张血管的作用。适合尿路不畅，胃部不适，心脏病患的人群。 主要类型：小种红茶、功夫红茶和红碎茶。 品质特征：干茶色泽乌润，滋味醇和，汤色红亮鲜明，具有麦芽糖香或焦糖香。 工艺流程：鲜叶采摘—萎凋—-揉捻—发酵—干燥 冲泡要点：开香时水温为 95℃，冲泡时水温为 80℃～85℃。红茶不宜闷泡，注水后尽快出汤，会获得一杯清甜爽口的红茶。使用的盖碗碗口一定要大，散热透气。置茶量可以少一些，让茶叶有充分的透气空间，而不至于闷坏。出汤要滴干净，不要留有水与茶叶接触过久，出完汤把盖子打开散热。 代表产品： 小种红茶——正山小种、烟小种（金骏眉是正山小种茶的顶级品种） 工夫红茶——滇红、祁红、闽红、湖红、宁红 红碎茶——叶茶、碎茶、片茶、末茶 6. 黑茶特点功效：能去油腻，减脂降压，黑茶中所含成分能促进淀粉酶解，改善肠道功能，适合肥胖三高及消化功能差的人。 主要类型：湖南黑茶、湖北老青茶、四川边茶、滇桂黑茶。 品质特征：干茶色泽黑褐或黄褐；汤色橙黄、橙红或琥珀色；叶底色泽黄褐、黑褐油亮。口感醇和爽滑；老茶醇厚顺滑，回甘持久明显，有陈香和药香味。 加工工序：鲜叶采摘—杀青—揉捻—渥堆—干燥（黑毛茶的制作工艺），成品黑茶还需要再次加工精制。 冲泡要点： 盖碗冲泡黑茶时，注水沿着盖碗边缘滑下去，不要直接冲到茶叶上，采用环圈注水或螺旋注水都可以，第一泡洗茶出汤要快速，水温控制在93摄氏度较为合适，如果是散茶，水温在90摄氏度较好。泡它时一般是清洗两遍，第2、3泡适当闷10秒，往下即可闷久点出汤饮用。 代表产品： 安化黑茶：茯砖、黑砖、花砖、花卷、天尖等 湖北黑茶：青砖茶 四川边茶：康砖、方茶、圆茶 滇桂黑茶：云南普洱、广西六堡茶 花茶花茶是由茶叶加香花拌和窨制，使茶叶吸附花香而制成。用来窨制花茶的茶叶素坯简称“茶坯”，依据茶坯的种类不同有烘青花茶、炒青花茶、红茶花茶、乌龙茶花茶等等。依据香花种类的不同有茉莉花茶、珠兰花茶、桂花茶、白兰花茶、玫瑰花茶、玳玳花茶、柚子花茶、金银花茶、菊花茶等。 1、张一元茉莉花茶，茉莉花茶又叫茉莉香片，起源于福建福州，一直都是国家的外事礼茶，香气持久，沁人心脾，味道鲜香浓厚，颜色浅黄清透，白色的花朵泡在茶中赏心悦目，茉莉花茶具有安神、解抑郁，健脾理气，抗衰老，提高身体免疫力的功效，张一元茉莉花茶产自福建福州，极为正宗。 2、艺福堂菊花茶，以菊花为原料，经过鲜花采摘、阴干、生晒蒸煮、烘焙工艺制作而成。菊花是我国传统名花，菊花茶具有散风清热、解毒消炎的作用，味道微甘。自唐朝开始人们就开始饮用菊花茶。艺福堂菊花茶产自桐乡杭白，是有名的茶品。 3、玫瑰花茶，很多人不知道，其实玫瑰花不只是一种观赏花，还是一种珍贵的药材，好看的外表下还有着非常高的药用价值，颜值和内涵并存，冲泡后颜色为淡黄色，味道是玫瑰花香，味甘微苦，可以解抑郁、健脾理气、活血散瘀以及调经止痛，对心脑血管，高血压、心脏病以及妇科病人有治疗作用，还可以美容养颜。 4、thin tea花茶，这是一款混合型的花茶，主要成分是茴香籽，荨麻根、玫瑰花瓣、杜松子、蒲公英根等，都是天然成分，其中蒲公英根和玫瑰花瓣还是一种药材，可以清热解毒、美容养颜，配上其他成分一起清肠排毒、加速新陈代谢、抑制食欲。而且不含番泻叶，不会导致人体腹泻，健康减肥瘦身。这款花茶来自澳大利亚，分为早晚两款，根据早晚体质，成分有所改动，早款清肠排毒，晚款抑制食欲。 普洱茶 普洱茶入门知识经典问答 普洱茶知识合集，读完可入门！ 普洱茶知识及术语，初学者必看！ 关于普洱茶，你应该知道的十件事！ 关于普洱茶的这九大常识，你都知道吗？ 3分钟看懂普洱茶名山头 茶叶存储茶叶储存三大原则：干燥、避光、无异味。 绿黄茶因为比较鲜嫩，所以还需要密封、低温处理，建议密封放置在冰箱里。 红白黑茶因为发酵成熟，所以在常温环境，保持干燥、避光、无异味即可。 茶叶功效绿茶 降糖效果好，抗癌防衰、抗辐射、延年益寿效果显著。 红茶 咖啡碱含量丰富，具有抗癌效果。还能兴奋大脑中枢神经、强心、利尿、消除疲劳、提高工作效率、抵抗酒精和尼古丁等毒害、减轻支气管和胆管痉挛、调节体温、兴奋呼吸中枢。 黑茶（普洱、茯砖、青砖） 富含茶多糖，强大保健功能是：降血糖、降血脂、防辐射、抗凝血及血栓、增强机体免疫功能、抗氧化、抗动脉粥样硬化、降血压和保护心血管等。 白茶（白毫银针、白牡丹、贡眉、寿眉） 美容抗衰、抗炎清火、降脂减肥、调降血糖、调控尿酸、保护肝脏、抵御病毒。 乌龙茶（大红袍、铁观音） 抗氧化、控制体重、防治心血管疾病、抗糖尿病、抗突变及抑制癌症、抗过敏、抗病原菌及肠道调节等功效。 茶性绿茶，核心工艺是“杀青”，本性寒。体质偏热、胃火盛、精力充沛者饮用绿茶有很好的清火、醒脑、提神之功。绿茶有很好的防辐射效果，对电脑前工作者有大益。 白茶，核心工艺是“萎凋、阳光干燥”和自然存放。茶性由寒转凉及至平和。新茶属性与功效大多接近绿茶，但最明显不同的是绿茶陈放为草，而白茶陈放为宝。及至老白茶，茶性反而更加平和，以适应更多人。 青茶(乌龙茶)，茶性寒转平和，由于发酵程度变化跨度太大，但总体是寒向平温转变。核心工艺是“做青”和“焙火”。发酵轻的很接近绿茶，如清香型铁观音，寒性就较大，发酵重的与红茶接近，适应人群更广。 红茶，茶性转温，核心是“发酵”，胃寒、体弱、年龄偏大者都适用，四肢酸懒、手足发凉者饮之更佳，可加奶蜂蜜等调饮，口味更好。 黑茶，茶性转温，核心工艺是“渥堆”。去油腻、解肉毒、降血脂等，保存的好，年份长后口感与疗效更好。 黄茶，茶性有改变，但不是太大，核心工艺是“闷黄”，特别是近些年，传统工艺黄茶由于制作加工较难，人才师傅缺乏，黄茶绿茶化明显。茶性和功效与绿茶相同或很接近，最大区别是口感了，黄茶更醇厚。 喝茶时间及注意事项早上-红茶 促进血液循环，去寒 午后-绿茶/乌龙茶 下午3：00左右喝茶（最重要的一次喝茶） 对人体能起到调理的作用，增强身体的抵抗力、补养、还能防止感冒，去肝火 饭后一小时后，才能喝茶 晚上-黑茶 晚上8：30左右喝茶 黑茶：分解脂肪、暖胃、助消化。 一天中喝茶注意事项： 每天饮茶1—2次，每次茶叶量2—3克、冲泡2—3 分钟、400毫升的饮量是比较适当的。 不宜空腹饮茶，茶入肺腑会冷脾胃。 饭前不宜饮茶，茶水会冲淡胃酸。 不能用茶水服药，茶中鞣酸会影响药效。 喝茶最佳时间早晨因为经过一昼夜的新陈代谢，人体消耗大量的水分，血液的浓度大。饮一杯淡茶水，不仅可以补充水分而且还可以稀释血液，降低血压。特别是老年人，早起后立即饮一杯淡茶水，对健康有利，饮淡茶水是为了防止损伤胃粘膜。 早上适宜喝红茶：人在睡了一夜之后，身体往往处于相对静止的状态，喝红茶则可促进血液循环，同时能够祛除体内寒气，让大脑供血充足。 红茶性质温和，可在每天早上起床后冲泡一杯，在吃过早餐后饮用，也可加入适量牛奶一起饮。需要提醒的是，千万不要空腹喝茶，因为茶叶中含有咖啡因，空腹喝，可令肠道吸收过多的咖啡因，会出现心慌、尿频等不良反应。时间久了，还会影响人体对维生素B的吸收。 喝茶最佳时间午后下午 3:00 左右喝茶，在这个时间喝茶，对人体能起到调理的作用，增强身体的抵抗力、补养、还能防止感冒，此时喝茶是一天中最重要的，俗称下午茶，对一些 “三高” 人群来说，如果坚持喝下午茶，能起到药物都无法达到的效果。 午后适宜喝青茶或绿茶：通常情况下，人体在中午时分会肝火旺盛，此时饮用绿茶或者青茶可使这一症状得到缓解。 青茶(如铁观音)性甘凉，入肝经，能清肝胆热，化解肝脏毒素，且维生素E含量丰富，能抵抗衰老; 绿茶则入肾经，利水去浊，令排尿顺畅。另外，绿茶中茶多酚含量极高，抗氧化、消炎效果好。 喝茶最佳时间晚上晚上 8:30 左右喝茶。有许多人对晚上喝茶有误解，怕影响睡觉，其实不然，在这个时间是人体免疫系统最活跃的时间，如果能喝上一泡茶，人体会很容易修补和恢复免疫系统，再造细胞等。对一些神经衰落人群，可以选择喝半发酵的温性的铁观音。千万不要喝绿茶，因为绿茶是不发酵茶，对人体有一定的刺激。 晚间适宜喝黑茶：人在吃了三餐之后，身体会积聚一些肥腻之物在消化系统内，倘若晚饭后能够饮用一杯黑茶则有助于分解积聚的脂肪，既暖胃又助消化。 黑茶性质较温纯，不会影响睡眠。黑茶首选云南普洱，不过，普洱的味道有些人可能接受不了，那么可用白茶代替，比如福建寿眉。寿眉入肺经，茶性平和，也不会影响睡眠。 日常饮茶的 8 大禁忌 过浓不饮： 浓茶会使人体的“兴奋性”过度增高，会对心血管系统、神经系统等造成不利影响。有心血管疾病者在饮用浓茶后可能会出现心跳过速、心律不齐的现象，易造成病情反复。 睡前不饮： 这一点对于新茶客尤为重要。很多人睡前饮茶后，入睡会变得非常困难，甚至严重影响次日的精神状态，有神经衰弱或失眠症的人要特别注意。 餐前不饮： 进餐前或进餐中少量饮茶并无大碍，但若大量饮茶或饮用过浓的茶，则会影响很多常量元素（如钙等）微量元素（如铁、锌等）的吸收。需要特别注意的是，在喝牛奶或其他奶制品时，不要同时饮茶。因为茶叶中的茶碱和丹宁酸会和奶制品中的钙元素结合成不溶解于水的钙盐，并排出体外，使奶制品的营养价值大为降低。 酒后不饮： 饮酒后，酒中乙醇通过胃肠道进入血液，在肝脏中转化为乙醛，乙醛再转化为乙酸，乙酸再分解成二氧化碳和水排出。酒后饮茶，茶中的茶碱可迅速对肾起到利尿作用，从而促进尚未分解的乙醛过早地进入肾脏。乙醛对肾有较大的刺激作用，会影响肾功能，所以，经常酒后喝浓茶的人易发生肾病。不仅如此，酒中的乙醇对心血管的刺激性很大，而茶同样具有兴奋心脏的作用，两者合二为一，更增强了对心脏的刺激。所以，心脏病患者酒后喝茶危害更大。 新茶不饮： 新茶会刺激胃黏膜，造成肠胃不适，甚至会使病情加重。从营养学角度来讲，太新鲜的茶叶其营养成分不一定是最好的。因为所谓新茶是指采摘下来不足一个月的茶叶，这些茶叶由于没有经过一段时间的放置，存有对身体健康不良影响的物质，如多酚类、醇类、醛类等物质，且没有被完全氧化，如果长时间喝新茶，有可能出现腹泻、腹胀等不舒服的反应。 隔夜茶不饮： 隔夜茶因搁置时间太久，容易受到病源性生物污染，茶水中的复杂成分也易发生变化，饮隔夜茶可导致胃肠疾病。小时候一直被教导“隔夜茶，拉肚子”看来真是自有道理的。 服药不饮： 有些人尤其是爱喝茶的人，会选择用茶水来送药，殊不知茶水中的鞣质可与药物结合而沉淀，会改变药性，阻碍吸收，影响药效，所以，服药应用白开水。这也就日常所说的“茶解药”。 区分四季，过量不饮： 春饮花茶，夏饮绿茶，秋饮青茶，冬饮红茶。春季饮花茶可以散发一冬积存在人体内的寒邪，促进人体阳气发生。绿茶性味苦寒，夏季饮绿茶为佳，可清热、消暑、解毒、止渴、强心。青茶不寒不热，秋季饮青茶能消除体内的余热，恢复津液。冬季饮红茶最为理想，红茶味甘性温，含有丰富的蛋白质，能助消化、补身体，使人体强壮。虽然茶叶中含有多种维生素和氨基酸，对于清油解腻、增强神经兴奋以及消食利尿具有一定的作用，但并不是喝得越多越好，也不是所有的人都适合饮茶。一般来说，每天饮茶一次至两次，每次2～3克茶叶量比较适当。患有神经衰弱、失眠、甲状腺机能亢进、结核病、心脏病、胃病、肠溃疡者不适合饮茶，哺乳期及怀孕妇女和婴幼儿也不宜饮茶。 头茶不饮 茶叶在栽培与加工过程中受到农药等有害物的污染，茶叶表面总有一定的残留，所以，头遍茶有洗涤作用应弃之不喝。 饭后不饮 茶叶中含有大量鞣酸，鞣酸可以与食物中的铁元素发生反应，生成难以溶解的新物质，时间一长引起人体缺铁，甚至诱发贫血症。正确的方法是：餐后一小时再喝茶。 发烧不饮 茶叶中含有茶碱，有升高体温的作用，发烧病人喝茶无异于“火上浇油”。 溃疡病人不饮 茶叶中的咖啡因因可促进胃酸分泌，升高胃酸浓度，诱发溃疡甚至穿孔。 不同茶对身心影响绿茶、乌龙茶汤色透彻，或水清茶绿，或浅黄透绿，天热、心躁之时品饮，给人清凉爽新之感。 有不少好的乌龙茶，特别是陈放佳的乌龙茶，会出现令人愉悦的果酸，中医认为酸入肝经，因此有疏肝理气之功，但脾胃有病症者不宜多饮。而乌龙茶中的武夷岩茶，更是特点鲜明，味重，“令人释躁平矜，怡情悦性”。凤凰单丛茶香气突出，在通窍理气上尤为明显。 红茶花香、蜜香醇厚，味甘性温。甜入脾经，具有补养气血，补充热能，解除疲劳、调和脾胃有好作用。红茶汤色红艳明亮，给人温暖喜悦之感，天气手脚寒凉、情绪低沉之时最宜饮红茶。 黑茶，味苦性温，多年的黑茶木香陈香果香，远年的六堡茶还有怡人的槟榔香。黑茶五行属水，入肾经。如脸黑无光泽，喉咙肿痛，食欲减退，下痢，背脚冰冷，腰痛，精力衰退者，饮此茶为好。 不同体质不同茶阳虚体质忌寒凉，可饮暖胃暖身的温性茶，如黑茶、重发酵焙火到位的乌龙茶，特别是这些茶的有年份的好茶。 阴虚体质会多感到热渴、干燥，需要多补充水滋润，黄茶、白茶等清爽淡雅，都可以。 气虚体质无力虚汗、呼吸短促、疲劳乏力、抵抗力弱。适宜益脾胃的食物，温和性的茶品适宜。 痰湿体质湿气大，宜除湿排毒，饮淡茶。湿热体质，甘平的乌龙茶适宜。 血瘀体质绿茶、白茶、花茶皆可。 过敏体质可以选些发酵度高、焙火适度的茶品，如浓香型铁观音、武夷岩茶、东方美人茶等。 气郁体质可以香气高雅、通窍芬芳的花茶，安吉白茶，花香度高的凤凰单丛。 平和体质什么茶都是来者不拒，春饮花、夏饮绿、秋饮青、冬饮红、一年四季喝乌龙。 年龄性别、特殊时期饮茶老人和孩童，可以饮茶，但不宜大量饮茶、不宜浓茶。 而性别来说，一般男性多喜饮绿茶、乌龙茶，及生普洱茶，特别是有人说武夷岩茶，称之为“男人喝的茶”，刚猛、气沉、刮肠、攻腻、调络、去毒。 对于上了岁数的女性，建议当以“熟茶”，特别是红茶为主茶品，性温活血、安宫暖身心，适量饮陈年上好乌龙茶、黑茶也是好选择。 女性特殊时期那几天，或孕期，可以饮茶，但前提是根据前面所讲茶性、体质选对茶，同时不宜大量饮茶、不宜饮过浓茶，可以喝茶，宜淡茶。隔年岩茶、红茶都是不错的选择，尽量少饮绿茶。 泡茶前，熟知茶叶的本性中国茶， 有六大类。绿茶、黄茶、白茶、乌龙茶、红茶、黑茶，每一种茶都有其特性，且不同的风格，吸引了各自的粉丝群体。 六大茶类，有何特点？ 绿茶：娇嫩，重在鲜爽 黄茶：鲜香，不可错过其清香 白茶：鲜、香、甘、淳、爽，可常年陈放 乌龙茶：清、香、甘、活、醇，风格百变 红茶：温厚、淳朴，水温须把控到位 黑茶：后发酵，茶性温和，带有独特的陈香，易沾染异味 懂得六大茶类的特性后，才能根据它们各自的特点选择冲泡茶具、冲泡水温、出水时间等。 茶器选择，重在因材施教在众多茶器中，一个款名为白瓷盖碗，这可是茶界万金油，不论您冲泡何种茶类，白瓷盖碗均可冲泡。 不过，我们在冲泡时，还是要根据选择出最适合茶类的冲泡茶器。 绿茶：玻璃杯 黄茶：玻璃杯 白茶：白瓷盖碗 乌龙茶：白瓷盖碗 红茶：白瓷盖碗 黑茶：紫砂壶 因茶选择茶器，这一点很重要。若是茶器选择不到位，茶叶的茶性不能得以完美发挥，茶香、茶滋味都将会大打折扣。 选择玻璃杯冲泡白茶和黄茶，便于观察茶叶在水中舒展、游动、变换的过程，同时玻璃杯散热快，不容易闷坏娇嫩的茶叶，不会导致茶汤变色，可泡出鲜爽感十足的茶叶。 选择白瓷盖碗冲泡白茶、乌龙茶、红茶，目的在于感受每一冲风味的变化。 盖碗，是所有茶具里足“无私奉献”的一款，完全为茶叶提供一个舞台，尽情释放茶香，不吸收茶味，能够保证茶汤的原滋原味。 而使用紫砂壶冲泡黑茶，在于紫砂壶可吸收气味，在冲泡时，能起到净化茶香的作用，减少黑茶因后发酵所产生的陈味。 器为茶之父，可见茶器的选择对一款茶叶的影响之大。 泡茶，水温、水质、出水要掌握到位1. 水温水温的选择，请牢记一个原则：好茶不怕沸水泡。 但为了让茶汤的口感更好喝，我们可以根据自己的口感适当调整。 有的茶友，偏爱用沸水冲泡后的口感，滋味浓郁，茶香足。 而有的茶友冲泡，怕自己出水拿捏不到位，反倒影响了茶汤的口感，所以会稍稍地降低冲泡温度。 不论选择何种冲泡方式，主要目的是为了让茶汤更好喝，这点原则不可动摇。 绿茶：90℃左右 黄茶：90℃左右 白茶：100℃ 乌龙茶：100℃ 红茶：100℃ 黑茶：100℃ 具体冲泡温度，可根据个人需求调整。 2. 水质水质，从很大程度上决定决定了茶汤的滋味和口感。 张大复在《梅花草堂笔谈》中说：“茶性必发于水，八分之茶，遇十分之水，茶亦十分矣；八分之水，试十分之茶，茶只八分耳。”可见水对茶的重要性。 陆羽《茶经》有云：“其水，山水上，江水中，井水下。”也说明泡茶用水十分讲究。 如今，我们身边可接触到的冲泡用水，可分为四大类。 山泉水 矿泉水 纯净水 自来水 在这些水质中，首先把自来水淘汰，不到万不得已的情况下，冲泡茶叶不要用自来水，会严重影响茶叶品质。 优选山泉水，如果没有这类资源，选择矿泉水和纯净水也是可以的。 3. 出水不同茶类的出水时间，也要掌握到位。 用玻璃杯冲泡绿茶和黄茶，一般等到茶汤凉了之后就可以饮用，用盖碗冲泡茶类则要注意，选择快出水。 不论是白茶、乌龙茶还是红茶，为必满茶汤滋味过浓，出现苦涩味，在冲泡时请遵循快出水的原则。 紫砂壶冲泡黑茶，因出水口本身就不大，故而在出水速度方面也会比较慢，属于慢出水一类。 泡茶，科学投茶是关键泡茶，有一个细节不可错过，那就是投茶量的选择。 投茶量，往往会被忽视，有茶友随性，直接用手抓取一些，丢进茶器中，注入沸水，倒出茶汤。 这类比较随性的做法，往往会让茶汤的味道变得不可把控。要么茶汤太浓，要么茶汤太淡，无法准确感知茶叶的滋味和香气。 如用玻璃杯冲泡绿茶和黄茶，一般注入300毫升的水，搭配3-4克左右茶叶即可，不宜过多，长时间浸泡下，容易使茶汤苦涩。 用白瓷盖碗泡茶，也要注意茶水比例。 目前，比较经常使用的，是110-120毫升左右的盖碗。 110-120毫升白瓷盖碗冲泡白茶，投茶5克。 110-120毫升白瓷盖碗冲泡武夷岩茶，投茶8克。 110-120毫升白瓷盖碗冲泡红茶，投茶5克。 在科学投茶量下，才可感受到茶叶的香与水，不至于茶汤不是太浓就是太淡。 泡茶，重在选择适合自己体质的茶最后想说的一点，是关于选择茶叶。 中国茶，有六大类之多，这些茶，各有特色，该怎么选？ 最重要的一点，是根据体质选茶。 在中医范畴，人的体质可分为九大类，不同体质适合喝的茶类不同。 根据体质选茶，落实到实处，还是要根据茶性选择。 9 种不同体质该如何喝茶 体质 主要体征 茶类 阴虚体质 面颊潮红或偏红，易长斑，眼睛干涩，口干咽燥，容易失眠，经常大便干结。 绿茶、白茶、黄茶 气虚体质 容易感冒，常出虚汗，体质虚弱，不耐受寒邪、风邪、暑邪。 乌龙茶、白茶、红茶 阳虚体质 手脚发凉，冬不耐受寒冷，夏不耐受空调冷气 乌龙茶、黑茶、老白茶、红茶 特禀体质 容易过敏，皮肤容易起荨麻疹特禀体质的人会出现打喷嚏、流清涕等症状，是因为卫气虚损不能抵御外邪所致。中医认为，“肾为先天之本” “脾为后天之本”，特禀质养生以健脾、补肾气为主。 白茶 血瘀体质 面色晦暗或色素沉着、黄褐色斑块，眼眶暗黑，易烦躁，健忘，性情急躁。 红茶、武夷岩茶、老白茶 痰湿体质 汗多而黏腻，手足心潮湿多汗，常感到肢体酸困沉重、容易困倦、不轻松 红茶、黑茶、白茶 湿热体质 面部和鼻尖总是油光发亮，易生粉刺、常感到口苦、口臭 白茶、黑茶 气郁体质 常感到闷闷不乐、情绪低沉，唉声叹气、紧张心悸、焦虑 绿茶、红茶、乌龙茶 平和体质 正常体质、理想状态各方面体质好 六大茶类均可饮用 依据中医的基本理论，各种药物都具有各自最基本的功能特性（也就是“药性”），中医范畴，可将药性分为寒、凉、温、热四种。在四性之外，还有一类叫平性药。 寒凉与温热是相对立的两种药性，寒凉药材多具有清热泻火的功效，适用于热性病症，如喉咙痛的时候就需要喝寒凉类的药物降火。 温热药材一般都具有温里散寒、补火助阳等功效，适用于寒性病症，如四肢厥冷、面色苍白等。 茶叶的“茶性”其实就源于中医的四性。 绿茶、黄茶性寒凉——部分消化系统不好的茶友，不适宜喝寒凉的茶，因为会刺激肠胃。如果是肝火旺，易上火的人，适合喝这类茶。 老白茶、陈年黑茶、红茶，茶性温和，就适合手脚冰凉的人喝。 故而，茶类的选择，还是要根据自己的体质选择。]]></content>
      <categories>
        <category>茶知识</category>
      </categories>
      <tags>
        <tag>茶知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 高效shell终端设置]]></title>
    <url>%2F2019%2F07%2F10%2FMacOS%2Fmac-shell%2F</url>
    <content type="text"><![CDATA[iterm2 快捷键光标控制 快捷键 描述 ctrl + a 到行首 ctrl + e 行末 ctrl + u 清除当前行 ctrl + f/b 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 ctrl + p 上一条命令，相当于方向键上 ctrl + r 搜索命令历史，这个大家都应该很熟悉了 ctrl + d 删除当前字符 ctrl + h 删除之前的字符 ctrl + w 删除光标前的单词 ctrl + k 删除到文本末尾 ctrl + t 交换光标处文本 ⌘ + —/+/0 调整字体大小 ⌘ + r 清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到 标签 快捷键 描述 command + t 新建标签 command + w 关闭标签 command + 数字 command + 左右方向键 切换标签 command + enter 切换全屏 command + f 查找 分屏 快捷键 描述 command + d 垂直分屏 command + shift + d 水平分屏 command + option + 方向键 或者 command + [ ] 切换屏幕 command + ; 查看历史命令 command + shift + h 查看剪贴板历史 自带有哪些很实用的功能/快捷键 快捷键 描述 ⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴 这个很实用 ⌘ + f 所查找的内容会被自动复制 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 Reference mac：高效shell终端设置 zsh+on-my-zsh配置教程指南（程序员必备）]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构师之路]]></title>
    <url>%2F2019%2F07%2F02%2FArchitect%2F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[架构师入门 我的职业是架构师：12年经验带你入门 软件架构入门 – 阮一峰 成为1个架构师的入门到进阶之路（学习路线图） 架构师之路 W3Cschool架构师之路]]></content>
      <categories>
        <category>架构师</category>
      </categories>
      <tags>
        <tag>架构师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webrtc-专题-02-WebRTC应用]]></title>
    <url>%2F2019%2F06%2F19%2FWebRTC%2Fwebrtc-%E4%B8%93%E9%A2%98-02%2F</url>
    <content type="text"><![CDATA[WebRTC浏览器APIWebRTC实现了多个Web API接口，其中三个重要的Web API分别是: MediaStream：通过 MediaStream 的 API 能够通过设备的摄像头及话筒获得视频、音频的同步流。 RTCPeerConnection：RTCPeerConnection 是 WebRTC 用于构建点对点之间稳定、高效的流传输的组件。 RTCDataChannel：RTCDataChannel 使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据。 这里大致介绍一下这三个API： MediaStream (aka getUserMedia)MediaStream API为WebRTC提供了从设备的摄像头、话筒获取视频、音频流数据的功能. W3C标准详见：https://w3c.github.io/mediacapture-main/getusermedia.html 如何调用？可以通过 navigator.getUserMedia() 这个方法来调用，这个方法接受三个参数： 一个约束对象（constraints object），这个后面会单独讲。 一个调用成功的回调函数，如果调用成功，传递给它一个流对象。 一个调用失败的回调函数，如果调用失败，传递给它一个错误对象。 浏览器兼容性处理由于浏览器实现不同，他们经常会在实现标准版本之前，在方法前面加上前缀，所以一个兼容版本就像这样： 1234var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); 一个超级简单的例子这里写一个超级简单的例子，用来展现 getUserMedia 的效果： 简单的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;GetUserMedia实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id="video" autoplay&gt;&lt;/video&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); getUserMedia.call(navigator, &#123; video: true, audio: true &#125;, function(localMediaStream) &#123; var video = document.getElementById('video'); video.src = window.URL.createObjectURL(localMediaStream); video.onloadedmetadata = function(e) &#123; console.log("Label: " + localMediaStream.label); console.log("AudioTracks" , localMediaStream.getAudioTracks()); console.log("VideoTracks" , localMediaStream.getVideoTracks()); &#125;; &#125;, function(e) &#123; console.log('Rejected!', e); &#125;); /* //或：'use strict';navigator.getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);var constraints = &#123; // 音频、视频约束 audio: true, // 指定请求音频Track video: &#123; // 指定请求视频Track mandatory: &#123; // 对视频Track的强制约束条件 width: &#123;min: 320&#125;, height: &#123;min: 180&#125; &#125;, optional: [ // 对视频Track的可选约束条件 &#123;frameRate: 30&#125; ] &#125;&#125;;function successCallback(localMediaStream) &#123; var video = document.querySelector('video'); if (window.URL) &#123; video.src = window.URL.createObjectURL(localMediaStream); &#125; else &#123; video.src = localMediaStream; &#125; video.onloadedmetadata = function(e) &#123; console.log("Label: " + localMediaStream.label); console.log("AudioTracks" , localMediaStream.getAudioTracks()); console.log("VideoTracks" , localMediaStream.getVideoTracks()); &#125;;&#125;function errorCallback(error) &#123; console.log('navigator.getUserMedia error: ', error);&#125;navigator.getUserMedia(constraints, successCallback, errorCallback); */ &lt;/script&gt;&lt;/html&gt; 将这段内容保存在一个HTML文件中，放在服务器上。用较新版本的Opera、Firefox、Chrome打开，在浏览器弹出询问是否允许访问摄像头和话筒，选同意，浏览器上就会出现摄像头所拍摄到的画面了. 注意，HTML文件要放在服务器上，否则会得到一个 NavigatorUserMediaError 的错误，显示 PermissionDeniedError。 这里使用 getUserMedia 获得流之后，需要将其输出，一般是绑定到 video 标签上输出，需要使用window.URL.createObjectURL(localMediaStream)来创造能在 video 中使用 src 属性播放的 Blob URL，注意在 video 上加入 autoplay 属性，否则只能捕获到一张图片。 流创建完毕后可以通过 label 属性来获得其唯一的标识，还可以通过 getAudioTracks() 和 getVideoTracks() 方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组） 在 JS 中，我们通过 getUserMedia 函数来处理音频和视频，该函数接收三个参数，分别是音视频的约束，成功的回调以及失败的回调。 在底层，浏览器通过音频和视频引擎对捕获的原始音频和视频流加以处理，除了对画质和音质增强之外，还得保证音频和视频的同步。 由于音频和视频是用来传输的，因此，发送方还要适应不断变化的带宽和客户端之间的网络延迟调整输出的比特率。 对于接收方来说，则必须实时解码音频和视频流，并适应网络抖动和时延。其工作原理如下图所示： 如上面源码中成功回调的 localMediaStream 对象中携带者一个或多个同步的 Track，如果你同时在约束中设置了音频和视频为 true，则在 localMediaStream 中会携带有音频 Track 和视频 Track，每个 Track 在时间上是同步的。 localMediaStream 的输出可以被发送到一或多个目的地：本地的音频或视频元素、后期处理的 JavaScript 代理，或者远程另一端。如下图所示： 约束对象(Constraints)约束对象可以被设置在 getUserMedia() 和 RTCPeerConnection 的 addStream 方法中，这个约束对象是WebRTC 用来指定接受什么样的流的，其中可以定义如下属性： video : 是否接受视频流 audio：是否接受音频流 MinWidth : 视频流的最小宽度 MaxWidth：视频流的最大宽度 MinHeight：视频流的最小高度 MaxHiehgt：视频流的最大高度 MinAspectRatio：视频流的最小宽高比 MaxAspectRatio：视频流的最大宽高比 MinFramerate：视频流的最小帧速率 MaxFramerate：视频流的最大帧速率 RTCPeerConnection在获取到音频和视频流后，下一步要做的就是将其发送出去。但这个跟 client-server 模式不同，这是 client-client 之间的传输，因此，在协议层面就必须解决 NAT 穿透问题，否则传输就无从谈起。 另外，由于 WebRTC 主要是用来解决实时通信的问题，可靠性并不是很重要，因此，WebRTC 使用 UDP 作为传输层协议：低延迟和及时性才是关键。 在更深入讲解之前，我们先来思考一下，是不是只要打开音频、视频，然后发送 UDP 包就搞定了？ 当然没那么简单，除了要解决我们上面说的 NAT 穿透问题之外，还需要为每个流协商参数，对用户数据进行加密，并且需要实现拥塞和流量控制。 我们来看一张WebRTC的分层协议图： ICE、STUN 和 TURN 是通过 UDP 建立并维护端到端连接所必需的； SDP 是一种数据格式，用于端到端连接时协商参数； DTLS 用于保障传输数据的安全； SCTP 和 SRTP 属于应用层协议，用于在 UDP 之上提供不同流的多路复用、拥塞和流量控制，以及部分可靠的交付和其他服务。 ICE（Interactive Connectivity Establishment，交互连接建立）：由于端与端之间存在多层防火墙和 NAT 设备阻隔，因此我们需要一种机制来收集两端之间公共线路的 IP，而 ICE 则是干这件事的好帮手。 ICE 代理向操作系统查询本地 IP 地址 如果配置了 STUN 服务器，ICE 代理会查询外部 STUN 服务器，以取得本地端的公共 IP 和端口 如果配置了 TURN 服务器，ICE 则会将 TURN 服务器作为一个候选项，当端到端的连接失败，数据将通过指定的中间设备转发。 WebRTC 使用 SDP（Session Description Protocol，会话描述协议）描述端到端连接的参数。 SDP 不包含媒体本身的任何信息，仅用于描述 “会话状况”，表现为一系列的连接属性：要交换的媒体类型（音频、视频及应用数据）、网络传输协议、使用的编解码器及其设置、带宽及其他元数据。 DTLS 对 TLS 协议进行了扩展，为每条握手记录明确添加了偏移字段和序号，这样就满足了有序交付的条件，也能让大记录可以被分段成多个分组并在另一端再进行组装。 DTLS 握手记录严格按照 TLS 协议规定的顺序传输，顺序不对就报错。 最后，DTLS 还要处理丢包问题：两端都是用计时器，如果预定时间没有收到应答，就重传握手记录。 为保证过程完整，两端都要生成自己签名的证书，然后按照常规的 TLS 握手协议走。但这样的证书不能用于验证身份，因为没有要验证的信任链。因此，在必要情况下， 应用必须自己参与各端的身份验证： 应用可以通过登录来验证用户 每一端也可以在生成 SDP 提议/应答时指定各自的 “身份颁发机构”，等对端接收到 SDP 消息后，可以联系指定的身份颁发机构验证收到的证书 SRTP 为通过 IP 网络交付音频和视频定义了标准的分组格式。SRTP 本身并不对传输数据的及时性、可靠性或数据恢复提供任何保证机制， 它只负责把数字化的音频采样和视频帧用一些元数据封装起来，以辅助接收方处理这些流。 SCTP 是一个传输层协议，直接在 IP 协议上运行，这一点跟 TCP 和 UDP 类似。不过在 WebRTC 这里，SCTP 是在一个安全的 DTLS 信道中运行，而这个信道又运行在 UDP 之上。 由于 WebRTC 支持通过 DataChannel API 在端与端之间传输任意应用数据，而 DataChannel 就依赖于 SCTP。 上讲了这么多，终于到我们的主角 RTCPeerConnection，RTCPeerConnection 接口负责维护每一个端到端连接的完整生命周期： RTCPeerConnection 管理穿越 NAT 的完整 ICE 工作流 RTCPeerConnection 发送自动（STUN）持久化信号 RTCPeerConnection 跟踪本地流 RTCPeerConnection 跟踪远程流 RTCPeerConnection 按需触发自动流协商 RTCPeerConnection 提供必要的 API，以生成连接提议，接收应答，允许我们查询连接的当前状态，等等 WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，这个流数据通道是点对点的，不需要经过服务器进行中转。但是这并不意味着我们能抛弃服务器，我们仍然需要它来为我们传递信令（signaling）来建立这个信道。WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分。 既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道。比如可以使用node的ws模块，在WebSocket上传递信令。 浏览器兼容处理还是前缀不同的问题，采用和上面类似的方法： 1234var PeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection); 创建和使用案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//使用Google的stun服务器var iceServer = &#123; "iceServers": [&#123; "url": "stun:stun.l.google.com:19302" &#125;]&#125;;//兼容浏览器的getUserMedia写法var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);//兼容浏览器的PeerConnection写法var PeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);//与后台服务器的WebSocket连接var socket = __createWebSocketChannel();//创建PeerConnection实例var pc = new PeerConnection(iceServer);//发送ICE候选到其他客户端pc.onicecandidate = function(event)&#123; socket.send(JSON.stringify(&#123; "event": "__ice_candidate", "data": &#123; "candidate": event.candidate &#125; &#125;));&#125;;//如果检测到媒体流连接到本地，将其绑定到一个video标签上输出pc.onaddstream = function(event)&#123; someVideoElement.src = URL.createObjectURL(event.stream);&#125;;//获取本地的媒体流，并绑定到一个video标签上输出，并且发送这个媒体流给其他客户端getUserMedia.call(navigator, &#123; "audio": true, "video": true&#125;, function(stream)&#123; //发送offer和answer的函数，发送本地session描述 var sendOfferFn = function(desc)&#123; pc.setLocalDescription(desc); socket.send(JSON.stringify(&#123; "event": "__offer", "data": &#123; "sdp": desc &#125; &#125;)); &#125;, sendAnswerFn = function(desc)&#123; pc.setLocalDescription(desc); socket.send(JSON.stringify(&#123; "event": "__answer", "data": &#123; "sdp": desc &#125; &#125;)); &#125;; //绑定本地媒体流到video标签用于输出 myselfVideoElement.src = URL.createObjectURL(stream); //向PeerConnection中加入需要发送的流 pc.addStream(stream); //如果是发送方则发送一个offer信令，否则发送一个answer信令 if(isCaller)&#123; pc.createOffer(sendOfferFn); &#125; else &#123; pc.createAnswer(sendAnswerFn); &#125;&#125;, function(error)&#123; //处理媒体流创建失败错误&#125;);//处理到来的信令socket.onmessage = function(event)&#123; var json = JSON.parse(event.data); //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述 if( json.event === "__ice_candidate" )&#123; pc.addIceCandidate(new RTCIceCandidate(json.data.candidate)); &#125; else &#123; pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp)); &#125;&#125;; RTCDataChannel既然能建立点对点的信道来传递实时的视频、音频数据流，为什么不能用这个信道传一点其他数据呢？ RTCDataChannel API就是用来干这个的，基于它我们可以在浏览器之间传输任意数据。DataChannel 是建立在 PeerConnection 上的，不能单独使用。建立 RTCPeerConnection 连接之后，两端可以打开一或多个信道交换文本或二进制数据。 DataChannel 和 WebSocket 的区别如下： 使用DataChannel我们可以使用 channel = pc.createDataCHannel(“someLabel”) ;来在 PeerConnection 的实例上创建 Data Channel，并给与它一个标签。 DataChannel 使用方式几乎和 WebSocket 一样，有几个事件： onopen onclose onmessage onerror 同时它有几个状态，可以通过 readyState 获取： connecting : 浏览器之间正在试图建立channel open：建立成功，可以使用send方法发送数据了 closing：浏览器正在关闭channel closed：channel已经被关闭了 两个暴露的方法: close() : 用于关闭channel send()：用于通过channel向对方发送数据 示例demo如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var ice = &#123; 'iceServers': [ &#123;'url': 'stun:stun.l.google.com:19302'&#125;, // google公共测试服务器 // &#123;"url": "turn:user@turnservera.com", "credential": "pass"&#125; ]&#125;;// var signalingChannel = new SignalingChannel();var pc = new RTCPeerConnection(ice);navigator.getUserMedia(&#123;'audio': true&#125;, gotStream, logError);function gotStream(stram) &#123; pc.addStream(stram); pc.createOffer().then(function(offer)&#123; pc.setLocalDescription(offer); &#125;);&#125;pc.onicecandidate = function(evt) &#123; // console.log(evt); if(evt.target.iceGatheringState == 'complete') &#123; pc.createOffer().then(function(offer)&#123; // console.log(offer.sdp); // signalingChannel.send(sdp); &#125;) &#125;&#125;function handleChannel(chan) &#123; console.log(chan); chan.onerror = function(err) &#123;&#125; chan.onclose = function() &#123;&#125; chan.onopen = function(evt) &#123; console.log('established'); chan.send('DataChannel connection established.'); &#125; chan.onmessage = function(msg)&#123; // do something &#125;&#125;// 以合适的交付语义初始化新的DataChannelvar dc = pc.createDataChannel('namedChannel', &#123;reliable: false&#125;);handleChannel(dc);pc.onDataChannel = handleChannel;function logError()&#123; console.log('error');&#125; 通过Data Channel发送文件大致思路JavaScript 已经提供了 File API 从 input[ type= ‘file’] 的元素中提取文件，并通过 FileReader 来将文件的转换成 DataURL，这也意味着我们可以将 DataURL 分成多个碎片来通过 Channel 来进行文件传输。 WebRTC信令交换本节讲述了WebRTC中所涉及的信令交换以及聊天室中的信令交换，主要内容来自于：WebRTC in the real world: STUN, TURN and signaling WebRTC的服务器WebRTC提供浏览器之间的点对点信道进行数据传输，但是并不意味着WebRTC不需要服务器，建立这个信道，必须有服务器的参与。WebRTC需要服务器对其进行四方面的功能支持： 用户发现以及通信； 信令传输：浏览器之间交换建立通信的元数据（信令）； NAT 防火墙穿越； 如果点对点通信建立失败，可以作为中转服务器。 NAT/防火墙穿越技术NAT简介NAT（Network Address Translation，网络地址转换）属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法 IP 地址的转换技术，主要用于实现私有网络访问公共网络的功能，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。原因很简单，NAT 不仅完美地解决了 lP 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 NAT分类根据 Stun 协议(RFC3489)，NAT 大致分为下面四类： 1) Full Cone（全锥型） 这种 NAT 内部的机器 A 连接过外网机器 C 后，NAT 会打开一个端口。然后外网的任何发到这个打开的端口的 UDP 数据报都可以到达 A，不管是不是 C 发过来的。 例如： ​12345A: 192.168.8.100 NAT: 202.100.100.100 C: 292.88.88.88 A(192.168.8.100:5000) -&gt; NAT(202.100.100.100:8000) -&gt; C(292.88.88.88:2000) 任何发送到 NAT(202.100.100.100:8000) 的数据都可以到达 A(192.168.8.100:5000) 2) Restricted Cone（受限锥型） 这种 NAT 内部的机器 A 连接过外网的机器 C 后，NAT 打开一个端口，然后 C 可以用任何端口和 A 通信，其他的外网机器不行。 例如： 12345A:192.168.8.100 NAT:202.100.100.100 C:292.88.88.88 A(192.168.8.100:5000) -&gt; NAT(202.100.100.100 : 8000) -&gt; C(292.88.88.88:2000) 任何从 C 发送到 NAT(202.100.100.100:8000)的数据都可以到达 A(192.168.8.100:5000) 3) Port Restricted Cone（端口受限锥型） 这种 NAT 内部的机器 A 连接过外网的机器 C 后，NAT打开一个端口，然后 C 可以用原来的端口和 A 通信，其他的外网机器不行。 例如： 1234A:192.168.8.100 NAT:202.100.100.100 C:292.88.88.88 A(192.168.8.100:5000) -&gt; NAT(202.100.100.100 : 8000) -&gt; C(292.88.88.88:2000) C(202.88.88.88:2000)发送到 NAT(202.100.100.100:8000)的数据都可以到达A(192.168.8.100:5000) 以上三种 NAT 通称 Cone NAT(锥型NAT)。我们只能用这种 NAT 进行 UDP 打洞。 4) Symmetic（对称型） 对于这种 NAT 连接不同的外部目标，原来 NAT 打开的端口会变化，而 Cone NAT 不会。虽然可以用端口猜测，但是成功的概率很小。因此放弃这种 NAT 的 UDP 打洞。 UDP hole punching（UDP打洞）对于 Cone NAT，要采用 UDP 打洞，需要一个公网机器 C 来充当 ”介绍人”，内网的 A、B 先分别和 C 通信，打开各自的 NAT 端口，C 这个时候知道 A、B 的公网 IP:Port，现在 A 和 B 想直接连接，比如 A 给 B 发，除非 B 是 Full Cone，否则不能通信。反之亦然，但是我们可以这样： A 要连接 B，A 给 B 发一个 UD P包，同时同，A 让那个介绍人给 B 发一个命令，让 B 同时给 A 发一个 UDP 包，这样双方的 NAT 都会记录对方的 IP，然后就会允许互相通信。 NAT穿越我们目前大部分人连接互联网时都处于防火墙后面或者配置私有子网的家庭(NAT)路由器后面, 这就导致我们的计算机的 IP 地址不是广域网 IP 地址, 故而不能相互之间直接通讯。 正因为这样的一个场景, 我们得想办法去穿越这些防火墙或者家庭(NAT)路由器，让两个同处于私有网络里的计算机能够通讯起来。建立点对点信道的一个常见问题，也就是 NAT 穿越技术问题，即在处于使用了 NAT 设备的私有 TCP/IP 网络中的主机之间需要建立连接时需要使用 NAT 穿越技术。 以往在 VoIP 领域经常会遇到这个问题。目前已经有很多 NAT 穿越技术，但没有一项是完美的，因为 NAT 的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的 IP 地址。 STUN(Simple Traversal of UDP over NATs,NAT 的UDP简单穿越)，STUN 协议服务器就是用来解决这些问题: 探测和发现通讯对方是否躲在防火墙或者NAT路由器后面。 确定内网客户端所暴露在外的广域网的 IP 和端口以及 NAT 类型等信息; STUN 服务器利用这些信息协助不同内网的计算机之间建立点对点的 UDP 通讯. STUN 协议可以很好的解决一般家用(NAT)路由器环境的打洞问题, 但是对于大部分的企业的网络环境就不是很好了。 这时需要一个新的解决方案: TURN（Traversal Using Relay NAT，中继 NAT 实现的穿透）允许在 TCP 或 UDP 的连线上跨越 NAT 或防火墙。 TURN 是一个 Client-Server 协议。TURN 的 NAT 穿透方法与 STUN 类似，都是通过取得应用层中的公有地址达到 NAT 穿透, 但实现 TURN client 的终端必须在通讯开始前与 TURN server 进行交互, 并要求 TURN server 产生 “relay port”, 也就是 relayed-transport-address. 这时 TURN server 会建立 peer, 即远端端点（remote endpoints）, 开始进行中继（relay）的动作, TURN client 利用 relay port 将资料传送至 peer, 再由 peer 转传到另一方的 TURN client. 通过服务器新产生的 peer 来进行数据的中转。 ICE 就是综合前面 2 种协议的综合性 NAT 穿越解决方案。在 RTCPeeConnection 中，使用 ICE 框架来保证 RTCPeerConnection 能实现 NAT 穿越。 ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）, 一种综合性的 NAT 穿越技术，它是一种框架，可以整合各种 NAT 穿越技术如 STUN、TURN。ICE 会先使用 STUN，尝试建立一个基于 UDP 的连接，如果失败了，就会去尝试 TCP（先尝试 HTTP，然后尝试 HTTPS），如果依旧失败 ICE 就会使用一个中继的 TURN 服务器。 通过 offer/answer 模型建立基于 UDP 的通讯。ICE 是 offer/answer 模型的扩展，通过在 offer 和 answer 的 SDP(Session Description Protocol)里面包含多种 IP 地址和端口，然后对本地 SDP 和远程 SDP 里面的 IP 地址进行配对，然后通过 P2P 连通性检查进行连通性测试工作，如果测试通过即表明该传输地址对可以建立连接。 其中 IP 地址和端口（也就是地址）有以下几种： 本机地址 通过STUN服务器反射后获取的server-reflexive地址（内网地址被NAT映射后的地址）、relayed地址（和TURN转发服务器相对应的地址）及Peer reflexive地址等。 我们可以使用 Google 的 STUN 服器：stun:stun.l.google.com:19302，于是乎，一个整合了 ICE 框架的架构应该长这个样子 ： 为什么需要信令？我们需要通过一系列的信令来建立浏览器之间的通信。而具体需要通过信令交换哪些内容呢？这里大概列了一下： 用来控制通信开启或者关闭的连接控制消息 发生错误时用来彼此告知的消息 媒体适配：媒体流元数据，比如像解码器、解码器的配置、带宽、媒体类型等等 用来建立安全连接的关键数据 网络配置：外界所看到的的网络上的数据，比如 IP 地址、端口等 这些信息的交换应该在点对点的流传输之前就全部完成。在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。 为什么WebRTC不去实现信令交换？不去由 WebRTC 实现信令交换的原因很简单： WebRTC 标准的制定者们希望能够最大限度地兼容已有的成熟技术。具体的连接建立方式由一种叫JSEP（JavaScript Session Establishment Protocol）的协议来规定，使用 JSEP 有两个好处： 在 JSEP 中，需要交换的关键信息是多媒体会话描述（multimedia session description）。由于开发者在其所开发的应用程序中信令所使用的协议不同（SIP 或是 XMPP 或是开发者自己定义的协议），WebRTC建立呼叫的思想建立在媒体流控制层面上，从而与上层信令传输相分离，防止相互之间的信令污染。只要上层信令为其提供了多媒体会话描述符这样的关键信息就可以建立连接，不管开发者用何种方式来传递 JSEP 的架构同时也避免了在浏览器上保存连接的状态，防止其像一个状态机一样工作。由于页面经常被频繁的刷新，如果连接的状态保存在浏览器中，每次刷新都会丢失。使用 JSEP 能使得状态被保存在服务器上。 会话描述协议（Session Description Protocol）JSEP 将客户端之间传递的信令分为两种： offer信令 answer信令 他们主要内容的格式都遵循会话描述协议（Session Description Protocal，简称 SDP）。一个 SDP 的信令的内容大致上如下： SDP信令内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263v=0o=- 7806956 075423448571 2 IN IP4 127.0.0.1s=-t=0 0a=group:BUNDLE audio video dataa=msid-semantic: WMS 5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30gm=audio 1 RTP/SAVPF 111 103 104 0 8 106 105 13 126c=IN IP4 0.0.0.0a=rtcp:1 IN IP4 0.0.0.0a=ice-ufrag:grnpQ0BSTSnBLroqa=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5a=ice-options:google-icea=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7Ba=setup:actpassa=mid:audioa=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-levela=recvonlya=rtcp-muxa=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFVa=rtpmap:111 opus/48000/2a=fmtp:111 minptime=10a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:126 telephone-event/8000a=maxptime:60m=video 1 RTP/SAVPF 100 116 117c=IN IP4 0.0.0.0a=rtcp:1 IN IP4 0.0.0.0a=ice-ufrag:grnpQ0BSTSnBLroqa=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5a=ice-options:google-icea=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7Ba=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=sendrecva=rtcp-muxa=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFVa=rtpmap:100 VP8/90000a=rtcp-fb:100 ccm fira=rtcp-fb:100 nacka=rtcp-fb:100 goog-remba=rtpmap:116 red/90000a=rtpmap:117 ulpfec/90000a=ssrc:3162115896 cname:/nERF7Ern+udqf++a=ssrc:3162115896 msid:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g 221b204e-c9a0-4b01-b361-e17e9bf8f639a=ssrc:3162115896 mslabel:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30ga=ssrc:3162115896 label:221b204e-c9a0-4b01-b361-e17e9bf8f639m=application 1 DTLS/SCTP 5000c=IN IP40.0.0.0a=ice-ufrag:grnpQ0BSTSnBLroqa=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5a=ice-options:google-icea=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7Ba=setup:actpassa=mid:dataa=sctpmap:5000 webrtc-datachannel 1024 它是一个在点对点连接中描述自己的字符串，我们可以将其封装在 JSON 中进行传输，在 PeerConnection 建立后将其通过服务器中转后，将自己的 SDP 描述符和对方的 SDP 描述符交给 PeerConnection 就行了。若想深入了解，可以参考SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04进行解析。 令与RTCPeerConnection建立在上一章节中介绍过，WebRTC 使用 RTCPeerConnection 来在浏览器之间传递流数据，在建立 RTCPeerConnection 实例之后，想要使用其建立一个点对点的信道，我们需要做两件事： 确定本机上的媒体流的特性，比如分辨率、编解码能力啥的（SDP 描述符） 连接两端的主机的网络地址（ICE Candidate） 需要注意的是，由于连接两端的主机都可能在内网或是在防火墙之后，我们需要一种对所有联网的计算机都通用的定位方式。这其中就涉及 NAT/防火墙穿越技术，以及 WebRTC 用来达到这个目的所 ICE 框架。 通过offer和answer交换SDP描述符大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况， RTCPeerConnection 简称 PC）： 甲和乙各自建立一个 PC 实例 甲通过 PC 所提供的 createOffer() 方法建立一个包含甲的 SDP 描述符的 offer信令 甲通过 PC 所提供的 setLocalDescription() 方法，将甲的 SDP 描述符交给甲的 PC 实例 甲将 offer信令 通过服务器发送给乙 乙将甲的 offer信令 中所包含的的 SDP 描述符提取出来，通过 PC 所提供的 setRemoteDescription() 方法交给乙的 PC 实例 乙通过 PC 所提供的 createAnswer() 方法建立一个包含乙的 SDP 描述符 answer信令 乙通过 PC 所提供的 setLocalDescription() 方法，将乙的 SDP 描述符交给乙的 PC 实例 乙将 answer信令 通过服务器发送给甲 甲接收到乙的 answer信令 后，将其中乙的 SDP 描述符提取出来，调用 setRemoteDescripttion() 方法交给甲自己的 PC 实例 通过在这一系列的信令交换之后，甲和乙所创建的 PC 实例都包含甲和乙的 SDP 描述符了，完成了两件事的第一件。我们还需要完成第二件事——获取连接两端主机的网络地址。 通过ICE框架建立NAT/防火墙穿越的连接这个网络地址应该是能从外界直接访问，WebRTC 使用 ICE 框架来获得这个地址。RTCPeerConnection 在创立的时候可以将 ICE 服务器的地址传递进去，如： 123456var iceServer = &#123; "iceServers": [&#123; "url": "stun:stun.l.google.com:19302" &#125;]&#125;;var pc = new RTCPeerConnection(iceServer); 当然这个地址也需要交换，还是以甲乙两位为例，交换的流程如下（RTCPeerConnection 简称 PC）： 甲、乙各创建配置了 ICE 服务器的 PC 实例，并为其添加 onicecandidate 事件回调 当网络候选可用时，将会调用 onicecandidate 函数 在回调函数内部，甲或乙将网络候选的消息封装在 ICE Candidate 信令中，通过服务器中转，传递给对方 甲或乙接收到对方通过服务器中转所发送过来 ICE Candidate 信令时，将其解析并获得网络候选，将其通过 PC 实例的 addIceCandidate() 方法加入到 PC 实例中 这样连接就创立完成了，可以向 RTCPeerConnection 中通过 addStream() 加入流来传输媒体流数据。将流加入到 RTCPeerConnection 实例中后，对方就可以通过 onaddstream 所绑定的回调函数监听到了。调用 addStream() 可以在连接完成之前，在连接建立之后，对方一样能监听到媒体流。 聊天室中的信令上面是两个用户之间的信令交换流程，但我们需要建立一个多用户在线视频聊天的聊天室。所以需要进行一些扩展，来达到这个要求。 用户操作首先需要确定一个用户在聊天室中的操作大致流程： 打开页面连接到服务器上 进入聊天室 与其他所有已在聊天室的用户建立点对点的连接，并输出在页面上 若有聊天室内的其他用户离开，应得到通知，关闭与其的连接并移除其在页面中的输出 若又有其他用户加入，应得到通知，建立于新加入用户的连接，并输出在页面上 离开页面，关闭所有连接 从上面可以看出来，除了点对点连接的建立，还需要服务器至少做如下几件事： 新用户加入房间时，发送新用户的信息给房间内的其他用户 新用户加入房间时，发送房间内的其他用户信息给新加入房间的用户 用户离开房间时，发送离开用户的信息给房间内的其他用户 实现思路以使用 WebSocket 为例，上面用户操作的流程可以进行以下修改： 浏览器与服务器建立 WebSocket 连接 发送一个加入聊天室的信令（join），信令中需要包含用户所进入的聊天室名称 服务器根据用户所加入的房间，发送一个其他用户信令（peers），信令中包含聊天室中其他用户的信息，浏览器根据信息来逐个构建与其他用户的点对点连接 若有用户离开，服务器发送一个用户离开信令（remove_peer），信令中包含离开的用户的信息，浏览器根据信息关闭与离开用户的信息，并作相应的清除操作 若有新用户加入，服务器发送一个用户加入信令（new_peer），信令中包含新加入的用户的信息，浏览器根据信息来建立与这个新用户的点对点连接 用户离开页面，关闭 WebSocket 连接 服务器实现由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了 WebSocket 的连接： 123456789101112var server = new WebSocketServer();var sockets = [];server.on('connection', function(socket)&#123; socket.on('close', function()&#123; var i = sockets.indexOf(socket); sockets.splice(i, 1); //关闭连接后的其他操作 &#125;); sockets.push(socket); //连接建立后的其他操作&#125;); 由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。 同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）: 于是乎代码大致就变成这样： 服务器实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var server = new WebSocketServer();var sockets = [];var rooms = &#123;&#125;;/*join信令所接收的格式&#123; "eventName": "join", "data": &#123; "room": "roomName" &#125;&#125;*/var joinRoom = function(data, socket) &#123; var room = data.room || "__default"; var curRoomSockets; //当前房间的socket列表 var socketIds = []; //房间其他用户的id curRoomSockets = rooms[room] = rooms[room] || []; //给所有房间内的其他人发送新用户的id for (var i = curRoomSockets.length; i--;) &#123; socketIds.push(curRoomSockets[i].id); curRoomSockets[i].send(JSON.stringify(&#123; "eventName": "new_peer", "data": &#123; "socketId": socket.id &#125; &#125;)); &#125; //将新用户的连接加入到房间的连接列表中 curRoomSockets.push(socket); socket.room = room; //给新用户发送其他用户的信息，及服务器给新用户自己赋予的id socket.send(JSON.stringify(&#123; "eventName": "peers", "data": &#123; "socketIds": socketIds, "you": socket.id &#125; &#125;));&#125;;server.on('connection', function(socket) &#123; //为socket构建一个特有的id，用来作为区分用户的标记 socket.id = getRandomString(); //用户关闭连接后，应做的处理 socket.on('close', function() &#123; var i = sockets.indexOf(socket); var room = socket.room; var curRoomSockets = rooms[room]; sockets.splice(i, 1); //通知房间内其他用户 if (curRoomSockets) &#123; for (i = curRoomSockets.length; i--;) &#123; curRoomSockets[i].send(JSON.stringify(&#123; "eventName": "remove_peer", "data": &#123; "socketId": socket.id &#125; &#125;)); &#125; &#125; //从room中删除socket if (room) &#123; i = this.rooms[room].indexOf(socket); this.rooms[room].splice(i, 1); if (this.rooms[room].length === 0) &#123; delete this.rooms[room]; &#125; &#125; //关闭连接后的其他操作 &#125;); //根据前台页面传递过来的信令进行解析，确定应该如何处理 socket.on('message', function(data) &#123; var json = JSON.parse(data); if (json.eventName) &#123; if (json.eventName === "join") &#123; joinRoom(data, socket); &#125; &#125; &#125;); //将连接保存 sockets.push(socket); //连接建立后的其他操作&#125;); 最后再加上点对点的信令转发就行了，一份完整的代码可参考SkyRTC项目源码 WebRTC点对点通信WebRTC 给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于 DataChannel ——在浏览器之间建立一个点对点的数据通道。 在 DataChannel 之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器 A 发送数据给服务器，服务器处理，服务器再转发给浏览器 B。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。 其实最理想的方式就是浏览器 A 直接与浏览 B 进行通信，服务器不需要参与其中。WebRTC DataChannel 就提供了这样一种方式。当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程： DataChannel连接的建立故事一：老刘和老姚去钓鱼 背景： 老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话 片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定 门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达 现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了: 门卫老大爷认识老刘和老姚 老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚 老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了 老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘 老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了 老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了 换个角度 我们把角色做一个映射： 老刘：浏览器A 老姚：浏览器B 片区：不同网段 保安：防火墙 片区凭证：ICE candidate 物业：ICE server 门牌号：session description 门卫老大爷：server 于是乎故事就变成了这样： 浏览器 A 和浏览器 B 在 server 上注册，并保有连接 浏览器 A 从 ice server 获取 ice candidate 并发送给 server，并生成包含 session description 的 offer，发送给 server server 发送浏览器 A 的 offer 和 ice candidate 给浏览器 B 浏览器 B 发送包含 session description 的 answer 和 ice candidate 给 server server 发送浏览器 B 的 answer 和 ice candidate 给浏览器 A 这样，就建立了一个点对点的信道。 DataChannel的分片传输故事二：老姚送礼物 老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。 这里可以做如下类比： 10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了） 分成10份：将文件分片，转成多个 chunk 老姚一次只能带一斤：datachannel 每次传输的数据量不宜太大（找到最合适的大小） 这其实就是通过 datachannel 传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件 分片 通过 HTML5 的 File API 可以将 type 为 file 的 input 选中的文件读取出来，并转换成 data url 字符串。这也就为我们提供了很方便的分片方式： 12345var reader = new window.FileReader(file);reader.readAsDataURL(file);reader.onload = function(event, text) &#123; chunkify(event.target.result);//将数据分片&#125;; 组合 通过 datachannel 发送的分片数据，我们需要将其进行组合，由于是 data url 字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的 data url 字符串，那么我们如何将这个字符串转换成文件呢？ 方案一：直接跳转下载 既然是个 dataurl，我们直接将其赋值给 window.location.href 自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼 方案二：通过 a 标签下载 这个原理和跳转下载类似，都是使用 dataurl 本身的特性，通过创建一个 a 标签，将 dataurl 字符串赋值给 href 属性，然后使用 download 确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为 dataurl 有大小限制 方案三：blob 其实可以通过给 a 标签创建 blob url 的方式来进行下载，这个没有大小限制。但是我们手上是 dataurl，所以需要先进行转换： 12345678function dataURItoBlob(dataURI, dataTYPE) &#123; var binary = atob(dataURI.split(',')[1]), array = []; for (var i = 0; i &lt; binary.length; i++) array.push(binary.charCodeAt(i)); return new Blob([new Uint8Array(array)], &#123; type: dataTYPE &#125;);&#125; 获得 blob 后，我们就可以通过 URL API 来下载了： 12345678910var a = document.createElement("a");document.body.appendChild(a);a.style = "display: none";var blob = dataURItoBlob(data, 'octet/stream');var url = window.URL.createObjectURL(blob);a.href = url;a.download = filename;a.click();!moz &amp;&amp; window.URL.revokeObjectURL(url);a.parentNode.removeChild(a); 这里有几个点： datachannel 其实是可以直接传送 blob 的，但是只有 firefox 支持，所以传 data url chrome 下载是直接触发的，不会进行询问，firefox 会先询问后下载，在询问过程中如果执行了 revokeObjectURL，下载就会取消。 DataChannel传输的升级如我们所知，WebRTC 最有特点的地方其实是可以传输 getUserMedia 获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32 位机上一个连接至少 20M 左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含 datachannel 的连接用于传输数据，然后在需要时升级成可以传输视频、音频。 看看我们之前传输的 session description，它其实来自Session Description Protocol。可以看到 wiki 上的介绍： The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters. 这意味着什么呢？我们之前建立 datachannel 是没有加视频、音频流的，而这个流的描述是写在 SDP 里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得 SDP，然后构建 offer 和 answer 再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的 ice candidate。 from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything. 有用的链接Specifications: WebRTC 1.0: Real-time Communication Between Browsers：https://www.w3.org/TR/webrtc/ Media Capture and Streams：https://w3c.github.io/mediacapture-main/ Media Capture from DOM Elements：https://w3c.github.io/mediacapture-fromelement/ Getting started:WebRTC官方网站：https://webrtc.org/start/ A Study of WebRTC Security：http://webrtc-security.github.io/ Tutorials:https://www.html5rocks.com/en/tutorials/webrtc/basics/ WebRTC API:https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API WebRTC codelab:A step-by-step guide that explains how to build a complete video chat app, including a simple signaling server.https://www.bitbucket.org/webrtc/codelab Javascript frameworks Video chat: https://github.com/andyet/SimpleWebRTC https://github.com/priologic/easyrtc https://github.com/webRTC-io/webRTC.io Peer-to-peer data: http://peerjs.com/ https://github.com/peer5/sharefest Demos:https://121.15.167.230:8090/demos/ https://webrtc.github.io/samples/ https://www.webrtc-experiment.com/ https://webcamtoy.com/zh/app/ https://idevelop.ro/ascii-camera/ WebRTC教程: WebRTC基础: Scaledrone —这个简单的教程会教你： 1231) WebRTC 基础知识2) 如何建立一个 1 对 1 视频通话3) 如何使用 Scaledrone 进行信令传输，这样就不需要编写服务器代码了 CodeLabs —这个教程包括了 WebRTC 介绍，一些简单的代码和 demo。 Tutorial’s Point —这篇教程会帮助所有想要学习如何搭建像实时广告，多人游戏，直播互动，网上学习这些应用的开发人员。 WebRTC.ventures Email课程—在这一系列的免费邮件中，你会学到 WebRTC 的基本知识，以及它的优缺点及使用方法。包括这些话题： 12345671) WebRTC 基础2) WebRTC 优点3) WebRTC 缺点4) 信令5) 建立 WebRTC 通话6) WebRTC 中的 DataChannel7) WebRTC 设计 Verto —在这个教程中，我们会通过例子学到如何建立，调入 verto jQuery 库来创建一个基础的网络视频会议应用。 CPASS教程: Tokbox —这是教程会一步一步指导你建立自己的 OpenTok 实时视频软件中的内容。在完成基本教程之后，你就可以继续跟着 Tokbox 的教程学习进阶内容： 123451) 归档2) 文字聊天3) 自定义视频渲染4) 自定义音频驱动5) 以及更多内容 Twilio —这个网页应用会向你展示如何使用 Twilio 客户端来创建一个浏览器-手机以及浏览器-浏览器通话。 Vidyo.io —Vidyo.io 通过教育视频聊天教程向我们展示： 1231) 生成 Vidyo.io Token2) 用几分钟的时间就搭建一个 iOS 版的移动端视频聊天软件3) 用几分钟的时间就搭建一个 Android 版的移动端视频聊天软件 信令 Html5Rocks.com —在这个教程文章中，你会学到如何搭建一个信令服务，以及如何通过使用 STUN 和 TURN 服务器来处理现实世界中连接性产生的各种奇怪问题。还解释了 WebRTC 应用是如何处理多方通话以及与 VoIP 和 PSTN 这些服务互动的。 媒体服务器 Kurento教程 —这些教程会给你展示如何使用 Kurento 框架搭建不同种类的 WebRTC 及多媒体应用。教程从三个角度出发：Java，浏览器 JavaScript 和 Node.js。 WebRTC服务提供商: 国外: https://xirsys.com https://tokbox.com/developer/ https://cloud.aculab.com/documents/webrtcdemo https://www.twilio.com/webrtc http://www.frafos.com/webrtc/ http://www.sightcall.com/ 国内: 声网：https://www.agora.io/cn/ 融云：http://www.rongcloud.cn/ 亲加云：http://www.gotye.com.cn/ 环信：https://www.easemob.com/ 野狗通信云：https://www.wilddog.com/]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webrtc-专题-01-WebRTC框架介绍]]></title>
    <url>%2F2019%2F06%2F16%2FWebRTC%2Fwebrtc-%E4%B8%93%E9%A2%98-01%2F</url>
    <content type="text"><![CDATA[什么是WebRTC？众所周知，浏览器本身不支持相互之间直接建立信道进行通信，都是通过服务器进行中转。比如现在有两个客户端，甲和乙，他们俩想要通信，首先需要甲和服务器、乙和服务器之间建立信道。甲给乙发送消息时，甲先将消息发送到服务器上，服务器对甲的消息进行中转，发送到乙处，反过来也是一样。这样甲与乙之间的一次消息要通过两段信道，通信的效率同时受制于这两段信道的带宽。同时这样的信道并不适合数据流的传输，如何建立浏览器之间的点对点传输，一直困扰着开发者。WebRTC应运而生。 WebRTC，名称源自网页实时通信（Web Real-Time Communication）的缩写，是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输，支持网页浏览器进行实时语音对话或视频对话。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。它是谷歌2010年5月以6820万美元收购拥有编解码、回声消除等技术的Global IP Solutions公司而获得的一项技术。该项目是由GIPS项目和libjingle项目融合而成。其中GIPS部分主要提供媒体的处理的功能。libjingle项目部分主要提供P2P传输部分的功能。2011年5月开放了工程的源代码，与相关机构 IETF 和 W3C 制定行业标准，组成了现有的 WebRTC 项目，在行业内得到了广泛的支持和应用，成为下一代视频通话的标准。 WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口。说的简单明了一点就是让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频。 WebRTC并不是单一的协议， 包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。同时WebRTC 并不是一个孤立的协议，它拥有灵活的信令，可以便捷的对接现有的SIP 和电话网络的系统。 关键要认识到的是，点对点并不意味着不涉及服务器，这只是意味着正常的数据没有经过它们。至少，两台客户机仍然需要一台服务器来交换一些基本信息（我在网络上的哪些位置，我支持哪些编解码器），以便他们可以建立对等的连接。用于建立对等连接的信息被称为信令，而服务器被称为信令服务器。 WebRTC没有规定您使用什么信令服务器或什么协议。 Websockets是最常见的，但也可以使用长轮询甚至邮件协议。 WebRTC的目标WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。 WebRTC（Web Real-Time Communication）项目的最终目的主要是让Web开发者能够基于浏览器（Chrome\FireFox…）轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web开发者也无需关注多媒体的数字信号处理过程，只需编写简单的Javascript程序即可实现，W3C等组织正在制定Javascript 标准API，目前是WebRTC 1.0版本，Draft状态；另外WebRTC还希望能够建立一个多互联网浏览器间健壮的实时通信的平台，形成开发者与浏览器厂商良好的生态环境。同时，Google也希望和致力于让WebRTC的技术成为HTML5标准之一，可见Google布局之深远。 WebRTC 提供了视频会议的核心技术，包括音视频的采集、编解码、网络传输、显示等功能，并且还支持跨平台：windows，linux，mac，android。 WebRTC的应用场景WebRTC的点对点方式能够运用在很多场景： 社交平台，如视频聊天室应用 远程实时监控 远程学习，如在线教育、在线培训 远程医疗，如在线医疗 人力资源和招聘，如在线面试 会议和联系中心之间的协作，如客户服务、呼叫中心 Web IM，如web qq 游戏娱乐，如双人对战游戏（如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送） 屏幕共享 人脸检测识别 虚拟现实 市场调研 金融服务 其它即时通信业务 WebRTC方案在多方实时音视频的应用及局限性实时音视频有两种会话方式，一种是点对点的，就是2个设备之间进行交流。就像2个人视频聊天这种场景的。另外一种是多方会话，就像视频会议这样的场景。 WebRTC适合做视频直播或音视频会议吗？先说结论：完全可以！ 但是，凡事总有但是，也没那么简单。你以为调用几个Chrome的API就能直播了？too simple 那正确的方法是什么呢？ 你得有一个实现了WebRTC相关协议的客户端。比如Chrome浏览器。 架设一个类似MCU系统的服务器。（不知道MCU是什么？看这：MCU（视频会议系统中心控制设备）） 第一步，用你的客户端，比如Chrome浏览器，通过WebRTC相关的媒体API获取图像及声音信源，再用WebRTC中的通信API将图像和声音数据发送到MCU服务器。如果你只是做着玩玩，完全可以直接用Chrome浏览器做你的直播客户端。把摄像头麦克风连上电脑之后，Chrome可以用相关的js的API获取到摄像头和麦克风的数据。缺点就是如果长时间直播，Chrome的稳定性堪忧，因为chrome这样运行24小时以上内存占用很厉害，而且容易崩溃。 第二步，MCU服务器根据你的需求对图像和声音数据进行必要的处理，比如压缩、混音等。你可能要问，WebRTC可以直接在浏览器之间P2P地传输流，为什么还要有中转的MCU服务器？因为Chrome的功能很弱，视频的分辨率控制、多路语音的混音都做不了，所以需要MCU参与。最重要的是，Chrome同时给6个客户端发视频流就很消耗资源了，所以你如果有超过10个用户收看的话，Chrome很容易崩溃。 第三步，需要看直播的用户，通过他们的Chrome浏览器，链接上你的MCU服务器，并收取服务器转发来的图像和声音流。 所以，这就要看你用的客户端是什么。如果你是想用浏览器，那WebRTC不是好方案。但如果你是用app，可以肯定回答：可以，而且强烈建议你基于WebRTC。 WebRTC使web浏览器通过简单的JavaScript api接口实现实时通信功能。在这方面基本已成事实上标准，正如上面写的，它成为标准不是新闻，不成为标准才是新闻。国内就有不少从事和WebRTC相关的开发者，像有的公司就基于WebRTC包做些修改、然后给其它开发者用、号称是视频聊天SDK。这样公司好多，但真正做大却有点难。我想有两个原因：Javascript的限制，浏览器的限制。 Javascript的限制。Javascript是脚本语言，能有什么功能取决于实现它的虚拟机，也就是浏览器这个应用程序。由于受限，问题来了，人民群众的需求总是琳琅满目，你都能提供吗？举个例子，直播过程中，要让对方的头上自动加顶红帽子，——当然，修改浏览器代码让加个帽子不是难事，可谁又知道接下会发生什么，难道要一个改一个？聊天往往是娱乐，娱乐经常是没啥规矩。由于这限制，开发者用它时会有这看法：东西是很好，但总是有那么点不足，而且即使是努力了也不可能解决（自个写浏览器除外）。 浏览器的限制。这就要涉及到聊天场景。很现实问题，如果我想和你聊天，身边有手机，你认为会用浏览器吗？对PC，网页比app方便，而移动设备却有点反着来，而且将来移动设备会越来越多。关于这个再深入个问题：如果PC用浏览器，手机用app，聊天是否可行？技术实现上没问题，可事实上基本不会做，代价太高划不来。浏览器时，信令走的是Websocket，app用Websocket纯粹是没事找抽，直接C Socket既简单又高效。浏览器时，两socket间没啥心跳包机制，app时心跳包机制可很大提升效率。浏览器时，由于用Javascript开发，功能受限，app时用Native Code，自个想要什么就能实现什么。而且，WebRTC是跨平台包，基于C/C++的跨平台SDK也不是没有，何不在开发时顺便开发出个Windows平台app。以上导致了app不太可能和网页聊天，这又让浏览器少去很多应用场景。 综合来说，在浏览器不是WebRTC不行，而是其它原因导致有那么点尴尬。想做一个“完美”用户体验的聊天工具，终归还得用app。 为什么说对App是完全可行呢？浏览器在用的WebRTC其实分两层，底层是个用C++写的库（Native Code），然后上层写个Javascript封装，以便供HTML5调用。既然是写app，那完全不用管上层Js封装，而且Google在开发WebRTC时已考虑用在app，底层C++库的API已做得很完善了。也就是说，一旦直接用Native Code，完全和浏览器无关了，作为C/C++开发者，他就可以用WebRTC去实现自个想实现的所有东西。 对直播使用场景，很多人是用移动设备，移动设备基本都是用app。而WebRTC中的Native Code部分跨平台特性很好，基本不用改，就能写出完全跨iOS、Android、Windows平台的代码，所以有了iOS/Android app，基本不耗成本Windows上的app就出来了。——当然，如果有人在Windows还是坚持要用浏览器，那只能说在Windows不得不留有瑕疵。 为什么有人一想到Windows，直观就认为只有p2p？我猜是和默认的信令服务器是p2p有关。关于这默认的信令服务器是怎么个交互流程，如下图所示： 根据这个图，你可以发现，只要换了信令服务器，就有可能变成直播。而事实也的确是这样。就像有人说直播时图像单向就够了（主播传向观众），而WebRTC是双向，只要改信令服务器，立刻就单向了。 为什么强烈建议你基于WebRTC？对直播系统，难的不是服务器，而是客户端。客户端难的地方则主要体现在两个方面，一是网络传输有关，像侦听事件，同步主线程和读线程，穿透；二是流数据有关，像编码、解码、回声消除。而这些正是WebRTC帮你解决了。也正因为如此，现在很多直播系统最早的客户端其实是以WebRTC为根的，只是后面自个不断优化，慢慢地变成自个系统而已。诚然，官方WebRTC是有地方不尽如意，但它们不断更新。 概括的说： WebRTC整体的技术并不适合做直播。WebRTC设计的初衷只是为了在两个浏览器/native app之间解决直接连接发送media streaming/data数据的，也就是所谓的peer to peer的通信，大多数的情况下不需要依赖于服务器的中转，因此一般在通信的逻辑上是一对一。而我们现在的直播服务大部分的情况下是一对多的通信，一个主播可能会有成千上万个接收端，这种方式用传统的P2P来实现是不可能的，所以目前直播的方案基本上都是会有直播服务器来做中央管理，主播的数据首先发送给直播服务器，直播服务器为了能够支持非常多用户的同事观看，还要通过边缘节点CDN的方式来做地域加速，所有的接收端都不会直接连接主播，而是从服务器上接收数据。 WebRTC内部包含的技术模块是非常适合解决直播过程中存在的各种问题的，而且应该在大多数直播技术框架中都已经得到了部分应用，例如音视频数据的收发、音频处理回音消除降噪等。 所以综上，可以使用WebRTC内部的技术模块来解决直播过程中存在的技术问题，但是不适合直接用WebRTC来实现直播的整体框架。 多方会话实现方式WebRTC针对这多方会话提供了两种实现方式。 第一种实现方式：实现多个浏览器之间的对等连接——全网状模型 多个浏览器通过Web服务器访问网站，浏览器之间的通话并不通过任何流媒体服务器，而是直接通过对等连接，通过UDP来实现浏览器之间的通信。这个叫做全网状模型。 第二种实现方式：浏览器和媒体服务器建立对等连接——集中式模型 服务端除了Web服务器之外还需要架构一个台媒体服务器，媒体服务器和各个浏览器之间实现对点连接。架设媒体服务器的目的在于接收各个浏览器的媒体流，之后通过媒体服务器把媒体流发给各个浏览器。 两种实现方式的利弊 ： 全网状：不需要架设媒体服务器，媒体延迟低质量高。但是如果人数很多的话就会导致浏览器的本地宽带增加，不适合多人会议。 集中式：比较适合多人会话，节省本地宽带，但是只有少量浏览器查询的时候，这种体系的效率非常低（因为要走媒体服务器）。 业内哪些App在使用WebRTC？目前，国内外有很多App都在使用WebRTC或者其相关技术，下面仅列举部分案例： 腾讯QQ和微信 腾讯的QQ音视频在使用GIPS方案（WebRTC的核心源于GIPS），据说微信内部已大量使用WebRTC组件，其内嵌的浏览器也支持WebRTC。 陌陌 由国内知名WebRTC服务提供商声网提供技术支持。 荔枝FM 由国内知名WebRTC服务提供商声网提供技术支持。 MeetMe 由国内知名WebRTC服务提供商声网提供技术支持。 狼人杀 由国内知名WebRTC服务提供商声网提供技术支持。 去哪儿 由国内知名WebRTC服务提供商声网提供技术支持。 WebRTC的优缺点优点： 方便。对于用户来说，在WebRTC出现之前想要进行实时通信就需要安装插件和客户端，但是对于很多用户来说，插件的下载、软件的安装和更新这些操作是复杂而且容易出现问题的，现在WebRTC技术内置于浏览器中，用户不需要使用任何插件或者软件就能通过浏览器来实现实时通信。对于开发者来说，在Google将WebRTC开源之前，浏览器之间实现通信的技术是掌握在大企业手中，这项技术的开发是一个很困难的任务，现在开发者使用简单的HTML标签和JavaScript API就能够实现Web音/视频通信的功能。 跨平台。因为基于浏览器，所以可跨浏览器（浏览器支持WebRTC）和跨操作系统平台，windows、Linux、ios、 android……全部支持。 P2P的优势。使用P2P技术处理数据（音频、视频和文件等）的传输，可减少服务器端的性能压力和带宽成本（这是有条件的，有些网络环境下可能无法使用P2P） 一整套的解决方案。从采集，编解码，RTP打包，流量控制，音频处理，多通道混音，都给于了很好的支持，并且是开源的代码，大大节省了开发时间和成本。 免费。虽然WebRTC技术已经较为成熟，其集成了最佳的音/视频引擎，十分先进的codec，但是Google对于这些技术不收取任何费用。 强大的打洞能力。WebRTC技术包含了使用STUN、ICE、TURN、RTP-over-TCP的关键NAT和防火墙穿透技术，并支持代理。 缺点： WebRTC中很多的参数都是由GIPS公司的工程师们依靠经验所设定的值，这就会出现卡顿、延时、回声、丢包、多人视频不稳定等问题，并且由于公网的稳定性或机型适配等外在因素，以上问题在项目上线后会更加严重。 WebRTC缺乏服务器方案的设计和部署。 传输质量难以保证。WebRTC的传输设计基于P2P，难以保障传输质量，优化手段也有限，只能做一些端到端的优化，难以应对复杂的互联网环境。比如对跨地区、跨运营商、低带宽、高丢包等场景下的传输质量基本是靠天吃饭，而这恰恰是国内互联网应用的典型场景。 WebRTC比较适合一对一的单聊，虽然功能上可以扩展实现群聊，但是没有针对群聊，特别是超大群聊进行任何优化。 设备端适配，如回声、录音失败等问题层出不穷。这一点在安卓设备上尤为突出。由于安卓设备厂商众多，每个厂商都会在标准的安卓框架上进行定制化，导致很多可用性问题（访问麦克风失败）和质量问题（如回声、啸叫）。 对Native开发支持不够。WebRTC顾名思义，主要面向Web应用，虽然也可以用于Native开发，但是由于涉及到的领域知识（音视频采集、处理、编解码、实时传输等）较多，整个框架设计比较复杂，API粒度也比较细，导致连工程项目的编译都不是一件容易的事。 总而言之，WebRTC虽然提供了一套音视频实时通讯的解决方案，但是在实际应用中，由于网络传输、设备适配以及多方通话上都存在很多问题，效果并不理想。 由此可见，WebRTC是一个优缺点兼有的技术，在拥有诱人的优点的同时，其缺点也十分的严重。在进行WebRTC的开发之前，请根据自身的情况来决定是自主开发还是使用第三方SDK。目前在市场上有很多第三方的音视频SDK可供选择，比如声网、腾讯、Intel、天翼RTC、网易云信、环信、融云、anychat等等，虽然这么多厂商提供的服务都大同小异，但他们的技术架构可能完全不同，比如天翼RTC是WebRTC SDK，腾讯是Native SDK。 由于WebRTC的复杂性和尚未完善性，下面的这些建议结合自己的实际参考： 音视频不是公司的核心方向，建议使用第三方SDK。 项目时间紧，有多人视频场景，使用场景依赖于手机端，建议使用第三方SDK。 公司没人音视频技术人才，建议使用第三方SDK或者技术外包。 如果公司实力、财力、人力雄厚，时间也不紧急，可考虑WebRTC集成开发，虽然会有很多坑，但总是能填平的。 如果音视频技术是公司的核心方向，但不想花太多时间去研究WebRTC，可直接找熟悉WebRTC的人来培训。 项目时间不紧急、没有多人视频需求且音视频质量要求不高，可考虑WebRTC集成开发。 直播领域所用协议的现状及其优缺点比较直播领域常用到的推送协议主要有： HTTP-FLV，即将音视频数据封装成FLV，然后通过HTTP协议传输给客户端。这种直播传输实际上就是利用的flv文件的特点，只需要一个matedata和音视频各自header，后面的音视频数据就可以随意按照时间戳传输，当然视频得按照gop段来传输，这种直播数据实际上就是一个无限大的HTTP传输的flv文件，客户端利用flv特性，可以一边接受数据边解码播放。 RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。RTMP其实实质上也是传输的flv格式的数据，同样是flv tag，只不过RTMP在传输上封装了一层，比如RTMP不仅可以直播，也可以推流。RTMP的直播原理同样也是利用了flv文件的特性，只需要一些头信息，后面就可以随意传输音视频数据，达到边传输边播放。RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。 HTTP Live Streaming（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。但是，即使苹果偶尔地提交一些小的更新，IETF却没有关于制定此标准的有关进一步的动作。HLS在大部分的浏览器利用html5video是可以直接播放的。 WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准。WebRTC默认使用UDP协议(实际上使用的是RTP/RTCP协议)进行音视频数据的传输，但是也可以通过TCP传输。 目前主要应用于视频会议和连麦中。 这几个协议的优缺点比较如下： 协议 优点 缺点 HTTP FLV 实时性和RTMP相等； 相比于RTMP省去了一些协议交互时间，首屏时间更短，可拓展的功能更多； 将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等 不支持双向互动；目前在网页上只能用flash或者插件的方式解码播放，而且flash在cpu和内存上都是占用很高。 RTMP CDN 支持良好，主流的 CDN 厂商都支持；协议简单，在各平台上实现容易，PC flash原生支持；支持双向互动；实时性很好；防HTTP下载。 基于TCP，传输成本高，在弱网环境丢包率高的情况下问题显著；不支持浏览器推送；Adobe 私有协议，Adobe已经不再更新； 需要访问1935端口，国内网络情况的恶劣程度，并不是每个网络防火墙都允许1935包通过；目前在网页上只能用flash或者插件的方式解码播放，而且flash在cpu和内存上都是占用很高。 HLS 跨平台，支持度高，H5浏览器支持比较好，可以直接打开播放；IOS、安卓原生支持；技术实现简单。 延迟性比较大。 WebRTC W3C 标准，主流浏览器支持程度高；Google 在背后支撑，并在各平台有参考实现；底层基于 SRTP 和 UDP，弱网情况优化空间大；可以实现点对点通信，通信双方延时低。 传统CDN没有ICE、STUN、TURN及类似的服务提供 WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer Answer 模型 WebRTC架构图 WebRTC architecture (from webrtc.org) 架构图颜色标识说明： （1）紫色部分是Web开发者API层； （2）蓝色实线部分是面向浏览器厂商的API层（也就是红色框标内模块，也是本人专注研究的部分）; （3）蓝色虚线部分浏览器厂商可以自定义实现。 将WebRTC架构图分解为内部结构简化图和协议栈后如下： 图1 为 WebRTC 内部结构简化图，最底层是硬件设备，上面是音频捕获模块和视频捕获模块。中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化。在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API。 图2 是 WebRTC 涉及到的协议栈，WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的。其中： ICE、STUN、TURN 用于内网穿透, 解决了获取与绑定外网映射地址，以及 keep alive 机制。DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，这一层是必须的。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议。 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上。 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输。 RTCDataChannel 用来支持端到端的任意二进制数据传输。 WebRTC架构组件介绍 1）Your Web App Web开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。 2）Web API 面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用，最新的标准化进程可以查看这里。 3）WebRTC Native C++ API 本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。 4）Transport / Session 传输/会话层，会话层组件采用了 libjingle 库的部分组件实现，无须使用 xmpp/jingle 协议 a. RTP Stack协议栈 Real Time Protocol b. STUN/ICE 可以通过 STUN 和 ICE 组件来建立不同类型网络间的呼叫连接。 c. Session Management 一个抽象的会话层，提供会话建立和管理功能。该层协议留给应用开发者自定义实现。 5）VoiceEngine 音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。 PS：VoiceEngine是WebRTC极具价值的技术之一，是Google收购GIPS公司后开源的。在VoIP上，技术业界领先，后面的文章会详细了解 a. iSAC Internet Speech Audio Codec （网络音频编解码） 针对VoIP和音频流的宽带和超宽带音频编解码器，是WebRTC音频引擎的默认的编解码器 采样频率： 16khz 24kh 32khz（默认为16khz） 自适应速率为： 10kbit/s ~ 52kbit/s 自适应包大小： 30~60ms 算法延时： frame + 3ms b. iLBC Internet Low Bitrate Codec VoIP音频流的窄带语音编解码器 采样频率： 8khz 20ms 帧比特率为 15.2kbps 30ms 帧比特率为 13.33kbps 标准由 IETF RFC3951 和 RFC3952 定义 c. NetEQ for Voice 针对音频软件实现的语音信号处理元件 NetEQ算法：自适应抖动控制算法以及语音包丢失隐藏算法。使其能够快速且高解析度地适应不断变化的网络环境，确保音质优美且缓冲延迟最小。是GIPS公司独步天下的技术，能够有效的处理由于网络抖动和语音包丢失时候对语音质量产生的影响。 PS：NetEQ 也是WebRTC中一个极具价值的技术，对于提高VoIP质量有明显效果，加以AEC\NR\AGC等模块集成使用，效果更好。 d. Acoustic Echo Canceler (AEC) 回声消除器是一个基于软件的信号处理元件，能实时的去除mic采集到的回声。 e. Noise Reduction (NR) 噪声抑制也是一个基于软件的信号处理元件，用于消除与相关VoIP的某些类型的背景噪声（嘶嘶声，风扇噪音等等… …） 6）VideoEngine WebRTC视频处理引擎 VideoEngine是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。 a. VP8 视频图像编解码器，是WebRTC视频引擎的默认的编解码器 VP8 适合实时通信应用场景，因为它主要是针对低延时而设计的编解码器。 PS:VPx编解码器是Google收购ON2公司后开源的，VPx现在是WebM项目的一部分，而WebM项目是Google致力于推动的HTML5标准之一 b. Video Jitter Buffer 视频抖动缓冲器，可以降低由于视频抖动和视频信息包丢失带来的不良影。 c. Image enhancements 图像质量增强模块，对网络摄像头采集到的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。 WebRTC核心模块API网络传输模块：libjingleWebRTC重用了libjingle的一些组件，主要是network和transport组件，关于libjingle的文档资料可以查看这里。 音频、视频图像处理的主要数据结构常量\VideoEngine\VoiceEngine 注意：以下所有的方法、类、结构体、枚举常量等都在webrtc命名空间里 类、结构体、枚举常量 头文件 说明 Structures common_types.h Lists the structures common to the VoiceEngine &amp; VideoEngine Enumerators common_types.h List the enumerators common to the VoiceEngine &amp; VideoEngine Classes common_types.h List the classes common to VoiceEngine &amp; VideoEngine class VoiceEngine voe_base.h How to allocate and release resources for the VoiceEngine using factory methods in the VoiceEngine class. It also lists the APIs which are required to enable file tracing and/or traces as callback messages class VideoEngine vie_base.h How to allocate and release resources for the VideoEngine using factory methods in the VideoEngine class. It also lists the APIs which are required to enable file tracing and/or traces as callback messages 音频引擎（VoiceEngine）模块 APIs下表列的是目前在 VoiceEngine中可用的sub APIs sub-API 头文件 说明 VoEAudioProcessing voe_audio_processing.h Adds support for Noise Suppression (NS), Automatic Gain Control (AGC) and Echo Control (EC). Receiving side VAD is also included. VoEBase voe_base.h Enables full duplex VoIP using G.711.NOTE: This API must always be created. VoECallReport voe_call_report.h Adds support for call reports which contains number of dead-or-alive detections, RTT measurements, and Echo metrics. VoECodec voe_codec.h Adds non-default codecs (e.g. iLBC, iSAC, G.722 etc.), Voice Activity Detection (VAD) support. VoEDTMF voe_dtmf.h Adds telephone event transmission, DTMF tone generation and telephone event detection. (Telephone events include DTMF.) VoEEncryption voe_encryption.h Adds external encryption/decryption support. VoEErrors voe_errors.h Error Codes for the VoiceEngine VoEExternalMedia voe_external_media.h Adds support for external media processing and enables utilization of an external audio resource. VoEFile voe_file.h Adds file playback, file recording and file conversion functions. VoEHardware voe_hardware.h Adds sound device handling, CPU load monitoring and device information functions. VoENetEqStats voe_neteq_stats.h Adds buffer statistics functions. VoENetwork voe_network.h Adds external transport, port and address filtering, Windows QoS support and packet timeout notifications. VoERTP_RTCP voe_rtp_rtcp.h Adds support for RTCP sender reports, SSRC handling, RTP/RTCP statistics, Forward Error Correction (FEC), RTCP APP, RTP capturing and RTP keepalive. VoEVideoSync voe_video_sync.h Adds RTP header modification support, playout-delay tuning and monitoring. VoEVolumeControl voe_volume_control.h Adds speaker volume controls, microphone volume controls, mute support, and additional stereo scaling methods. 视频引擎（VideoEngine）模块 APIs下表列的是目前在 VideoEngine中可用的sub APIs sub-API 头文件 说明 ViEBase vie_base.h Basic functionality for creating a VideoEngine instance, channels and VoiceEngine interaction.NOTE: This API must always be created. ViECapture vie_capture.h Adds support for capture device allocation as well as capture device capabilities. ViECodec vie_codec.h Adds non-default codecs, codec settings and packet loss functionality. ViEEncryption vie_encryption.h Adds external encryption/decryption support. ViEErrors vie_errors.h Error codes for the VideoEngine ViEExternalCodec vie_external_codec.h Adds support for using external codecs. ViEFile vie_file.h Adds support for file recording, file playout, background images and snapshot. ViEImageProcess vie_image_process.h Adds effect filters, deflickering, denoising and color enhancement. ViENetwork vie_network.h Adds send and receive functionality, external transport, port and address filtering, Windows QoS support, packet timeout notification and changes to network settings. ViERender vie_render.h Adds rendering functionality. ViERTP_RTCP vie_rtp_rtcp.h Adds support for RTCP reports, SSRS handling RTP/RTCP statistics, NACK/FEC, keep-alive functionality and key frame request methods.]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实时音视频互动系列]]></title>
    <url>%2F2019%2F06%2F09%2FWebRTC%2F01-%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BA%92%E5%8A%A8%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[又拍云UTUN网络详解如何定义实时音视频互动, 延迟 400ms 内才能无异步感实时音视频互动如果存在1秒左右的延时会给交流者带来异步感，必须将视频播放延迟限制在 400ms 以内，才能给用户较好的交互体验。 当延迟控制在 400ms 以内时，两个人音视频互动是实时的，不会有异步感存在，即实时音视频互动。 实时音视频互动产生延迟的原因音视频互动的延迟是如何产生的？ 我们先假设这样一个场景：位于北京的A客户端与位于广州的B客户端进行实时音视频互动。 该场景会有以下几个产生延迟的原因： 光的传输耗时 30ms； 网络处理耗时 10ms； 应用服务处理耗时 10ms； 客户端发送处理耗时 50ms（采集、编码、缓冲…）； 客户端接收处理耗时 50ms（缓冲、解码、渲染…）； 网络层面，在跨地区、跨运营商等情况下，传输延时会非常高并且不稳定，尤其在晚高峰或者网络拥堵的情况下延时更加无法把控。单纯通讯环境导致超过100ms的延迟时间，因此需要在技术层面达到较高的性能才能将延迟控制在200ms以内。 又拍云 UTUN 通讯网，数据传输耗时低于50ms 为了解决这个问题，又拍云设计了基于公网的通讯网 UTUN，以此实现所有客户端接入又拍云通讯网之后再进行交互。 UTUN 是一个分布式网络路由器，加入 UTUN 可以将数据以最快的速度传达到目的地，同时无需担心跨地区、跨 ISP、负载均衡、容灾等问题。 又拍云 UTUN 网络基于又拍云 CDN 网络部署，同时拥有200多个边缘接入节点、4000多台服务器、覆盖3大运营商、3个小运营商。 通过又拍云 UTUN 网络进行数据传输，国内可以做到传输低于50ms，海外传输低于200ms。计算入上文提到的应用层产生延时的点，50ms加上其他因素所导致的延时，又拍云国内传输可以做到100200ms音视频互动。国际传输音视频互动延时等于应用层所消耗掉的100200ms再加上网络传输的延时，又拍云能够做到400ms之内。 基于 WebRTC 技术的实战解析在 WebRTC 项目中，又拍云团队做到了覆盖系统全局，保证项目进程流畅。这牵涉到主要三大块技术点： 网络端、服务端的开发和传输算法 WebRTC 协议中牵扯到服务端的应用协议和信令服务 客户端iOS、安卓 H.264 编解码技术 实时音视频互动必须遵守三大点 必须基于 UDP 协议，否则不要谈实时 因为 TCP 协议的重传机制（传输保障）会导致累积延迟问题，用 UDP 协议没有传输保障机制，但需要自行完善丢包容错逻辑。 又拍云音视频互动方案是基于UDP 协议，使用 TCP 协议无法保障实时性。 TCP 协议有包重传机制，保证传输内容100%传输到目的地，这个特性导致延时增加。当然，由于UDP协议没有包重传机制，需要完善业务的容错性。目前来说，UTUN 网络提供的两种配置，都可以保证数据100%传输。 在极差的网络状态下，可以选择容忍丢包，使用算法保障90%以上的数据包正常到达，以此达到200ms以内延迟。 UDP协议相比TCP协议具有多链路传输的优势。 TCP协议只支持单一链路传输。当连麦、音画同时需要传输时，TCP协议只有一条通道进行数据传输。而通过UDP协议，音视频可以通过两个节点将数据一分为二来传输，A路传输50%数据包，B路传输50%数据包。终端收到两路数据流，再合并放到应用层做解码处理。 考虑多终端适配，使用 WebRTC 协议 客户端网络跨地区和跨运营商信号很差，所以不能使用 P2P 模式。目前包括苹果Safari 在内的所有的桌面端浏览器都已支持 WebRTC 协议。 网络层使用 P2P 模式无法解决跨地域、跨 ISP 的跨运营商网络问题，会导致延时过高的情况产生。如果一直纠结于P2P模式，那么QOS码率控制、包容忍等问题就无法在算法上有所突破。 云服务化 单机、单机房存在硬件瓶颈，唯有云服务化才能按需做到横向扩展。 随着用户量的提升，单台服务器所能支撑的并发量直播有限，RTMP Server、WebRTC Server一般八核服务器能承受的并发量只有2000~4000路，单机房也会成为硬件瓶颈，而公有云能承受几十万甚至上百万的数量压力，所以机房中不能存在单点，必须是云服务化分布式的。 云服务化非常重要，上文提到的 UTUN 网络属于完全分布式网络，分布在又拍云两百多个节点，四千台服务器上。只需要接入又拍云任意边缘服务器，就可以做到自主服务，自动选择出一条甚至数条路径，让用户与通讯网中任何地点的人交互。 又拍云 WebRTC 架构中遇到的经验和问题又拍云 WebRTC 相比外部的 WebRTC 有较大的差别。即使你在同一个地方、同一个服务商、同一个无线信号下，又拍云都没有使用P2P模式，都是通过云服务来进行网络传输的。 我们严格遵循官方标准搭建包括服务端、客户端在内的 WebRTC 体系。目前 WebRTC 版本为可变性非常大的1.0版本，未来该技术可能会有革命性的迭代。如果采用自研的方式，会有无法跟进版本技术更新的风险。再者如果完全自主编写 Server 端或者客户端势必要投入非常大的精力和研发时间。 因此又拍云选择紧跟官方的步伐，无论官方有何种bug修复，都选择同步更新。 在实践中遇到的问题： 当 iOS 端使用新版本 WebRTC 时，由于音频处理部分导致的 Bug，会导致 CPU 占用率过高； 服务 Server 端由于编码传输时 WebRTC 是可变码率、可变帧率的，但是内核代码在进行传输时却使用了固定帧率操作，时间戳不一致的 Bug 导致了音视频不同步的情况，声音与画面不同步最大延时可以达到数十秒，不断累积。为了解决这个 Bug 需要把视频时间戳进行修正，统一使用音频的时间戳，来保证音视频同步； Android 端不支持高通外的芯片硬解码，又拍云在近期把各个 Android 端编解码功能完善，目前已经能够适配华为、MTK、三星等品牌的机型； 目前客户端解码能力有限，会话人数最好控制在8个人以内； 自动根据参与人数控制总带宽在2Mbps以内； 美颜、滤镜等功能的接入会增加延迟，加入额外功能不能过度消耗客户端 CPU 资源。 音视频互动最大的难点——业务信令目前业务信令还没有一套完整的解决方法，业务信令在 WebRTC 中虽然是开源的，但是没有形成标准的信令协议，这个部分需要我们自行构建。 架构网络电话场景时，牵扯到三个信令：呼叫、等待接听、通话。 但是实际中会有更多信令，假设一个会议场景，A邀请参会B，A会设置多个邀请途径：1.A直接将B拉到会议室；2.A把会议室号码给B，B自行进入；3.A配置房间权限控制，需要得到授权才能进入房间等。随着业务的发展，业务信令会不断增加，我们需要构建一套完善的信令体系显得非常重要。 我们在编写信令系统时，把信令系统分成了两类：1.底层系统信令，2.公共业务信令。 底层系统信令只需编写公共业务信令的总通道协议和 API 接口，让应用程序对接，将业务信令进行统一标准化。比如在房间里，发送一条广播给所有参会者的业务信令S，而业务信令S只想传达给B，但是C在同一个会议室也听到了，C会选择性的对业务信令S忽略以此达成这个业务功能。 目前来说必须面临的现实问题： 客户端硬件性能未能支持高清码率：多人互动不可能做到720P分辨率，一般来说都是在320P或者460P分辨率。一般手机因为客户端的解码能力支撑不了多路高清解码，达到6路以上码率只能做到300K以下； 硬编解码兼容性差：Android 机型太多，仅能有限支持H.264硬编解码，同时iOS和Android 端均不支持 H.265 硬编解码； 手机发热、耗电量大：参加会议iPhone电量支撑两、三个小时。桌面端耗电、发热最严重，测试时使用Chrome硬解码电量只能支持两个小时。 以上三点是目前整个业内所都要面临的最大的问题，只能等待终端的解码能力提升，相信到明年手机解码能力就可以支持多路高清互联。]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC视频统计信息之延迟抖动与丢包]]></title>
    <url>%2F2019%2F06%2F07%2FWebRTC%2Fwebrtc%E7%9A%84%E8%A7%86%E9%A2%91%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%BB%B6%E8%BF%9F%E6%8A%96%E5%8A%A8%E4%B8%8E%E4%B8%A2%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言 这篇文章主要想说明的是WebRTC内部对视频上下行延时、抖动、丢包如何更新，上层又怎么获取到这些统计信息的。对应的WebRTC版本：63。 背景 最近在内网情况下测试视频会议，视频下行延时很大，很多时候超过100ms。另外，视频的上下行抖动总是稳定在30~40ms这个区间。这些统计在内网环境下是不正常的，于是决定看看是哪里导致这些问题的。 在解决这些问题的过程中，也对WebRTC内部视频统计数据做了一次梳理。 阅读这篇文章之前，最好对RTP、RTCP、SR、RR有一些了解。这里就不过多展开，可以参考以下文章： RTP Data Transfer Protocol RTP Control Protocol – RTC RTP/RTSP/RTCP有什么区别 综述下图是WebRTC内部获取视频统计信息和统计信息如何被更新的流程图：（其中的箭头代表函数调用） 上图共有两个大的模块，如何取 和 如何更新： 如何取上面部分“客户端视频数据统计入口”中，左下角的WebRtcVideoChannel::GetStats是WebRTC对外暴露的获取统计信息的入口，视频的上下行统计数据最终分别使用右上角SendStatisticsProxy::stats_、ReceiveStatisticsProxy::stats_和CallStats::avg_rtt_ms_来填充返回。 如何更新下面部分“延时、抖动、丢包更新流程”部分，从网络接收到RTP/RTCP之后，使用三个不同颜色代表三种统计信息的更新流程，比如红色代表下行抖动/丢包更新流程、蓝色代表RTT的更新流程等。 统计信息大多不是由一条调用流程完成的（这就是下文会说到的“阶段”），会有几次类似缓冲区的“中转”，然后由另外的线程或函数继续做统计信息的整理，最终达到上一步的 SendStatisticsProxy::stats_、ReceiveStatisticsProxy::stats_ 和 CallStats::avg_rtt_ms_，等待上层获取。 几个统计信息详细介绍延时 这里统计的延时指的是往返延时 rtt。WebRTC使用SR/RR来计算rtt。 (1) 延时的计算1) SR和RR报文格式 Sender Report RTCP Packet Receiver Report RTCP Packet 2) 计算rtt 以下流程通过结合SR/RR包报文格式，浏览RTCPReceiver::HandleReceiverReport、RTCPReceiver::HandleReportBlock、ModuleRtpRtcpImpl::SendCompoundRTCP、RTCPSender::BuildSR、RTCPSender::BuildRR函数。前面2个函数是接收端计算rtt，后面3个函数是对端在构造RR时LSR/DLSR如何设置的。 首先，发送端构造SR时，sender info部分的NTP字段被设置为当前ntp时间戳； 接收端收到最新的SR之后，使用last_received_sr_ntp_字段记录当前ntp时间戳； 接收端构造RR时，设置RR的DLSR字段为当前ntp时间戳 - last_received_sr_ntp_，之后发出RR包； 发送端在接收到RR包之后，记录RR包到达时间A； 使用公式 A - LSR - DLSR 计算rtt。 3) 用一个图描述上述RTT计算流程 SR与RR的个数并不完全相同，因为RR并不是对SR的回应，它们的发送各自独立；另外丢包也会导致一部分SR/RR没有被对方接收。因此上图中，SR和RR传输中，实线代表发了一次SR/RR，并且被被对方接收了。这里想说明的是：即便SR或RR丢失一部分，只要发送端收到了RR，它总能计算出rtt，因为RR中使用的LSR和DLSR字段都是从最近一次收到的SR中取到的。 (2) 延时的更新流程 下文所说的第一阶段、第二阶段等，都是指 数据从一个位置转移到另一个位置的过程，或者说是一次推或拉模式。比如：F1函数把数据从A点转移到B点就返回了，F2函数把数据从B点转移到C点就返回了，那A-&gt;B就是第一阶段，B-&gt;C就是第二阶段。如下： 1) rtt统计第一阶段由上文可知：从RR可以计算出往返延时rtt，这个rtt最终保存在RTCPReceiver::received_report_blocks_。 2) rtt统计第二阶段ModuleRtpRtcpImpl::Process会定时把rtt从RTCPReceiver::received_report_blocks_更新到CallStats::reports_，这个更新过程，CallStats::reports_中每个rtt都会与一个更新时间戳绑定。参考CallStats::OnRttUpdate 函数。 3) rtt统计第三阶段CallStats继承Module，CallStats::Process函数会定时做以下三个步骤： 根据第二阶段绑定的时间戳，清理掉 reports_ 中距当前时间1.5s以前的rtt； 计算1.5s内的平均rtt； 使用平均rtt，更新 avg_rtt_ms 成员； (3) 获取延时调用CallStats::avg_rtt_ms函数获取rtt时，直接返回 avg_rtt_ms_ ; 下行抖动和丢包 下行抖动和丢包，通过在接收端根据收到的RTP包来计算和更新。 (1) 抖动和丢包的计算1) 抖动定义抖动被定义为：一对数据包在接收端与发送端的数据包时间间距之差。如下： 如果Si代表第i个包的发送时间戳，Ri代表第i个包的接收时间戳。Sj、Rj同理。抖动(i, j) = |(Rj - Ri) - (Sj - Si)| = |(Rj - Sj) - (Ri - Si)| WebRTC为了统一抖动，并且为了很好的降噪、降低突发抖动的影响，把上面的抖动(i, j)定义为D(i, j)，抖动J(i)定义为:J(i) = J(i-1) + (|D(i-1, i)| - J(i - 1)) / 16 我虽然看不出J(i)和D(i)的关系，但是D(i-1, j)是唯一引起J(i)变化的因素，是需要重点关注的。 2) 抖动计算存在的问题：RTP报文头部，有timestamp字段，该字段用来表示该RTP包所属帧的capture time。接收RTP包时如果记录接收时间戳，再根据头部的timestamp字段，D(i, j)就可以计算出来，J也就有了。（事实上webrtc原本也是这样干的，而且这种方式计算的抖动还对外暴露，可以参考StreamStatisticianImpl::UpdateJitter函数） 但是这样计算抖动是存在问题的：每一帧的视频数据放进多个RTP包之后，这些RTP包的头部timestamp字段都是一样的（都是帧的capture time），但是实际发送时间不一样，到达时间也不同。 3) 如何正确计算抖动：计算D(i, j)时，Si不能只使用RTP timestamp，而是应该使用该RTP实际发送到网络的时间戳。这种抖动被命名为jitter_q4_transmission_time_offset，意为考虑了transmission_time_offset的jitter。 a. transmission_time_offset是什么? transmission_time_offset是一段时间间隔，该时间间隔代表属于同一帧的RTP的实际发送时间距离帧的capture time的 偏移量 。下图是对transmission_offset_time的解释： 其中，箭头代表一个RTP，发送端的竖线代表时间轴，虚线代表帧的capture time。 最开始三个RTP包在距离capture time offset1时间之后发送到网络，因此这三个RTP包的transmission_time_offset应该是offset1。同理第四个RTP包的transmission_time_offset应该是offset2，第五个RTP包的transmission_time_offset应该是offset3。 b. transmission_time_offset在RTP包的哪里放着? transmission_time_offset存在于RTP的扩展头部，设置该扩展头可以参考RTPSender::SendToNetwork函数，但使用之前该扩展头之前需要注册，否则在设置transmission_time_offset扩展头会失败。 下面的代码段是WebRTC中D(i, j)的计算： 12345678// Extended jitter report, RFC 5450.// Actual network jitter, excluding the source-introduced jitter.int32_t time_diff_samples_ext = (receive_time_rtp - last_receive_time_rtp) - ((header.timestamp + header.extension.transmissionTimeOffset) - (last_received_timestamp_ + last_received_transmission_time_offset_)); 其中： receive_time_rtp 代表当前RTP的到达时间戳； last_receive_time_rtp 是上一个RTP到达时记录的时间戳； header.timestamp + header.extension.transmissionTimeOffset 前者是capture time，后者是对应的transmission time offset，两者相加代表该RTP实际发送到网络的时间戳； last_received_timestamp_ + last_received_transmission_time_offset_ 含义同上，但是代表的是上一个RTP的实际发送到网络的时间戳； (2) 下行抖动的更新流程1) 抖动统计第一阶段接收端收到的RTP包，会经过StreamStatisticianImpl::UpdateJitter函数，该函数内部会计算经过这个RTP包之后的抖动值，并更新到成员jitter_q4_transmission_time_offset_成员中。 2) 抖动统计第二阶段ModuleRtpRtcpImpl::Process会定时发送RR，在构建RR的Report Block时，会搜集本地接收报告并把第一阶段保存的jitter_q4_transmission_time_offset_信息更新到ReceiveStatisticsProxy::stats_ 。 (3) 下行丢包的更新流程1) 丢包统计第一阶段接收端收到的RTP包，会经过StreamStatisticianImpl::UpdateCounters 函数，在该函数内部，会累加接收到的RTP包的个数和重传包的个数，以及当前收到的最大的sequence。 2) 丢包统计第二阶段下图是WebRTC内部计算下行丢包： 丢包率更新的周期是发送一次RR，在发送RR时，会根据第一阶段记录的数据统计丢包，丢包根据下面的公式： fraction_lost = RTP包丢失个数 / 期望接收的RTP包个数 其中： 包丢失个数 = 期望接收的RTP包个数 - 实际收到的RTP包个数 期望接收的RTP包个数 = 当前最大sequence - 上次最大sequence 实际收到的RTP包个数 = 正常有序RTP包 + 重传包 计算出来的丢包，连同抖动一起被更新到ReceiveStatisticsProxy::stats_。 (3) 获取下行抖动和丢包下行抖动和丢包最终会从ReceiveStatisticsProxy::stats_ 获取。 上行抖动和丢包 下行抖动和丢包，从对方发来的RR包中获取。RR包格式参考上文链接。 (1) 上行抖动和丢包的更新流程本地上行抖动和丢包，就是对端下行抖动和丢包，对端按照上面介绍的方式计算下行抖动和丢包，然后通过RR返回。 从RR获取抖动和丢包，没有太多阶段，只有一次推过程。接收端在收到RR之后，就把内部的抖动和丢包更新到SendStatisticsProxy::stats_中，这里就是客户端主动获取上行抖动和丢包时最终的数据源。 (2) 获取上行抖动和丢包上行抖动和丢包最终会从SendStatisticsProxy::stats_ 获取。]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC 镜像源]]></title>
    <url>%2F2019%2F05%2F30%2FWebRTC%2Fwebrtc-src%2F</url>
    <content type="text"><![CDATA[WebRTC 镜像源 WebRTC 镜像源 webrtc src WebRTC-编译以及运行IOS的Demo WebRTC iOS&amp;OSX 库的编译 生成WebRTC的DEMO并运行 使用xcode来生成webrtc的Demo webrtc ios client 源码拉取和编译 webrtc视频jitterbuffer原理机制(描述版) jitter buffer QoS的解决方案 webrtc中的码率控制 WebRTC介绍 WebRTC源码解读一 WebRTC架构简介 C/C++ Linux 程序员必须了解的 10 个工具 C++设计一个类不能偷懒的地方 设计性能良好系统的指导思想 WebRTC实时音视频技术的整体架构介绍 WebRTC 开发（二）源码下载与编译 查看和下载特定版本的webrtc代码注：这个方法已经不适用了 gclient：如果不知道 gclient 是什么东西 。。。 就别再往下看了。 下载特定版本的代码： 1$ gclient sync --revision src@31000 其中31000是版本号 查看自己下载代码的版本号： 12345$ gclient revinfo -awebrtc@ubuntu:~/code/webrtc/src/talk$ gclient revinfo -asrc: http://webrtc.googlecode.com/svn/trunk@**7706**src/third_party/gflags/src: http://gflags.googlecode.com/svn/trunk/src@84src/third_party/junit/:http://webrtc.googlecode.com/svn/deps/third_party/junit@3367 其中7706是版本号 如何在官网上浏览特定版本的代码： https://code.google.com/p/webrtc/source/browse/?r=7643 其中7643是版本号 12# 同步第三方依赖库$ gclient sync 创建xcode的mac 工程 123$ export GYP_GENERATOR_FLAGS="xcode_project_version=7.2 xcode_ninja_target_pattern=All_mac xcode_ninja_executable_target_pattern=AppRTCDemo output_dir=out_mac"$ export GYP_GENERATORS="ninja,xcode-ninja"$ ./webrtc/build/gyp_webrtc.py 创建xcode的iOS工程 123$ export GYP_GENERATOR_FLAGS="xcode_project_version=7.2 xcode_ninja_target_pattern=All_iOS xcode_ninja_executable_target_pattern=AppRTCDemo output_dir=out_ios"$ export GYP_GENERATORS="ninja,xcode-ninja"$ ./webrtc/build/gyp_webrtc.py 运行后在 webrtc 根目录下生成 all.ninja.xcodeproj 和 sources_for_indexing.xcodeproj， 分别用来编译和浏览源代码。 webrtc技术难点笔记 — 带github工程 webrtc代码研究 webrtc工程有点大，自己强攻了一个多月，基本被拖进了无穷无尽多工程结构梳理中。 现在的思路就是： 总结webrtc里面的工程难点，然后到对应的github上去找开源项目，然后一个一个项目的研究，然后再回过头去研究工程. webrtc的研究点包括: 1.音视频的网络抖动缓冲策略 2.网络的拥塞处理策略 3.丢包重传策略 4. 对应的开源github工程: 1.video jitter buffer https://github.com/TaoistKing/Video-Jitter-Buffer 介绍video jitter buffer设计原理的文章: https://blog.csdn.net/u012635648/article/details/72953237 2.网络拥塞流控 https://github.com/yuanrongxi/razor 相关文档: https://blog.csdn.net/chinabinlang/article/details/78294464?locationNum=7&amp;fps=1]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用的计算机工具库]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%AE%9E%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在我们平时的工作过程中，经常会用到各种工具，每次遇到问题都得各种百度搜索，今天给大家带来几个私藏多年的工具库，有了它，你再也不用到处找工具了，里面包含了大量的使用工具。 MikuTools网站地址 一个轻量的工具集合，里面包含有媒体类，图片类，文字处理类，编程开发类，日常实用类工具，基本覆盖了我们所有的需求，登录后还有更多的隐藏功能。 atoolbox网站地址 一个工具箱，里面包含了143个在线工具，包括加密解密，文字编辑，编程开发，单位换算，日期时间，图形图像，金融理财，生活日常等各个门类，应该算是很全面了。 在线工具网站地址 程序员必备，里面包含各种常用的开发工具。 FrontEndNav网站地址 前端程序员必备，收集了大量高质量的前端相关资源。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg的H.264解码器源代码简单分析]]></title>
    <url>%2F2019%2F05%2F28%2FFFmpeg%2FFFmpeg%E7%9A%84H.264%E8%A7%A3%E7%A0%81%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[文章参考汇总至雷神笔记 编码 - x264概述最近正在研究H.264和HEVC的编码方式，因此分析了一下最常见的H.264编码器——x264的源代码。本文简单梳理一下它的结构。X264的源代码量比较大而且涉及到很多的算法，目前还有很多不懂的地方，因此也不能保证分析的完全正确。目前打算先把已经理解的部分整理出来以作备忘。 函数调用关系图 下面解释一下图中关键标记的含义。 函数背景色函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用： 白色背景的函数：不加区分的普通内部函数。 浅红背景的函数：libx264类库的接口函数（API）。 粉红色背景函数：滤波函数（Filter）。用于环路滤波，半像素插值，SSIM/PSNR的计算。 黄色背景函数：分析函数（Analysis）。用于帧内预测模式的判断，或者帧间预测模式的判断。 绿色背景的函数：宏块编码函数（Encode）。通过对残差的DCT变换、量化等方式对宏块进行编码。 紫色背景的函数：熵编码函数（Entropy Coding）。对宏块编码后的数据进行CABAC或者CAVLC熵编码。 蓝色背景函数：汇编函数（Assembly）。做过汇编优化的函数。图中主要画出了这些函数的C语言版本，此外这些函数还包含MMX版本、SSE版本、NEON版本等。 浅蓝色背景函数：码率控制函数（Rate Control）。对码率进行控制的函数。具体的方法包括了ABR、CBR、CRF等。 区域整个关系图可以分为以下几个区域： 最左边区域——x264命令行程序函数区域。 左边中间区域——libx264内部函数区域。 右上方粉红色区域——滤波模块。其中包括了环路滤波，半像素插值，SSIM/PSNR计算。 右上方黄色区域——分析模块。其中包含了帧内预测模式分析以及帧间运动估计等。 右中间绿色区域——宏块编码模块。其中包含了针对编码帧的DCT变换，量化，Hadamard变换等；以及针对重建帧的DCT反变换，反量化，Hadamard反变换等。 右下方紫色区域——熵编码模块。其中包含了CABAC或者CAVLC熵编码。 箭头线箭头线标志了函数的调用关系： 黑色箭头线：不加区别的调用关系。 粉红色的箭头线：滤波函数（Filter）之间的调用关系。 黄色箭头线：分析函数（Analysis）之间的调用关系。 绿色箭头线：宏块编码函数（Encode）之间的调用关系。 紫色箭头线：熵编码函数（Entropy Coding）之间的调用关系。 函数所在的文件每个函数标识了它所在的文件路径。 几个关键的部分下文简单记录图中几个关键的部分。 x264命令行程序x264命令行程序指的是x264项目提供的控制台程序。通过这个程序可以调用libx264编码YUV为H.264码流。该程序的入口函数为 main()。main() 函数首先调用 parse() 解析输入的参数，然后调用 encode() 编码YUV数据。 parse()首先调用 x264_param_default() 为保存参数的 x264_param_t 结构体赋默认值；然后在一个大循环中通过 getopt_long() 解析通过命令行传递来的存储在 argv[] 中的参数，并作相应的设置工作；最后调用 select_input() 和 select_output() 完成输入文件格式（yuv，y4m等）和输出文件格式（裸流，mp4，mkv，FLV等）的设置。 encode()首先调用 x264_encoder_open() 打开编码器；接着在一个循环中反复调用 encode_frame() 一帧一帧地进行编码；最后在编码完成后调用 x264_encoder_close() 关闭编码器。 encode_frame()则调用 x264_encoder_encode() 将存储YUV数据的 x264_picture_t 编码为存储H.264数据的 x264_nal_t。 libx264类库的接口在一个x264编码流程中，至少需要调用如下API函数（参考文章《最简单的视频编码器：基于libx264（编码YUV为H.264）》）： 123456x264_param_default() // 设置参数集结构体x264_param_t的缺省值。x264_picture_alloc() // 为图像结构体x264_picture_t分配内存。x264_encoder_open() // 打开编码器。x264_encoder_encode() // 编码一帧图像。x264_encoder_close() // 关闭编码器。x264_picture_clean() // 释放x264_picture_alloc()申请的资源。 libx264主干函数libx264主干函数指的是编码API之后，x264_slice_write() 之前的函数。这一部分函数较多，暂时不详细分析，仅仅举几个例子列一下它们的功能。 1234567891011x264_encoder_open() // 调用了下面的函数：x264_validate_parameters() // 检查输入参数（例如输入图像的宽高是否为正数）。x264_predict_16x16_init() // 初始化Intra16x16帧内预测汇编函数。x264_predict_4x4_init() // 初始化Intra4x4帧内预测汇编函数。x264_pixel_init() // 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。x264_dct_init() // 初始化DCT变换和DCT反变换相关的汇编函数。x264_mc_init() // 初始化运动补偿相关的汇编函数。x264_quant_init() // 初始化量化和反量化相关的汇编函数。x264_deblock_init() // 初始化去块效应滤波器相关的汇编函数。x264_lookahead_init() // 初始化Lookahead相关的变量。x264_ratecontrol_new() // 初始化码率控制模块。 x264_encoder_headers() 调用了下面的函数： 123x264_sps_write() // 输出SPSx264_pps_write() // 输出PPSx264_sei_version_write() // 输出SEI x264_encoder_encode()调用了下面的函数： 12345678910111213x264_frame_pop_unused() // 获取1个x264_frame_t类型结构体fenc。如果frames.unused[]队列不为空，就调用x264_frame_pop()从unused[]队列取1个现成的；否则就调用x264_frame_new()创建一个新的。x264_frame_copy_picture() // 将输入的图像数据拷贝至fenc。x264_lookahead_put_frame() // 将fenc放入lookahead.next.list[]队列，等待确定帧类型。x264_lookahead_get_frames() // 通过lookahead分析帧类型。该函数调用了x264_slicetype_decide()，x264_slicetype_analyse()和x264_slicetype_frame_cost()等函数。经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。x264_frame_shift() // 从frames.current[]队列取出一帧用于编码。x264_reference_update() // 更新参考帧列表。x264_reference_reset() // 如果为IDR帧，调用该函数清空参考帧列表。x264_reference_hierarchy_reset() // 如果是I（非IDR帧）、P帧、B帧（可做为参考帧），调用该函数（还没研究）。x264_reference_build_list() // 创建参考帧列表list0和list1。x264_ratecontrol_start() // 开启码率控制。x264_slice_init() // 创建 Slice Header。x264_slices_write() // 编码数据（最关键的步骤）。其中调用了x264_slice_write()完成了编码的工作（注意“x264_slices_write()”和“x264_slice_write()”名字差了一个“s”）。x264_encoder_frame_end() // 编码结束后做一些后续处理，例如释放一些中间变量以及打印输出一些统计信息。其中调用了x264_frame_push_unused()将fenc重新放回frames.unused[]队列，并且调用x264_ratecontrol_end()关闭码率控制。 x264_slice_write()x264_slice_write() 用于编码 Slice。该函数中包含了一个很长的 for() 循环。该循环每执行一遍编码一个宏块。x264_slice_write() 中以下几个函数比较重要： 123456789101112x264_nal_start() // 开始写一个NALU。x264_macroblock_thread_init() // 初始化存储宏块的重建数据缓存fdec_buf[]和编码数据缓存fenc_buf[]。x264_slice_header_write() // 输出 Slice Header。x264_fdec_filter_row() // 滤波模块。该模块包含了环路滤波，半像素插值，SSIM/PSNR的计算。x264_macroblock_cache_load() // 将要编码的宏块的周围的宏块的信息读进来。x264_macroblock_analyse() // 分析模块。该模块包含了帧内预测模式分析以及帧间运动估计等。x264_macroblock_encode() // 宏块编码模块。该模块通过对残差的DCT变换、量化等方式对宏块进行编码。x264_macroblock_write_cabac() // CABAC熵编码模块。x264_macroblock_write_cavlc() // CAVLC熵编码模块。x264_macroblock_cache_save() // 保存当前宏块的信息。x264_ratecontrol_mb() // 码率控制。x264_nal_end() // 结束写一个NALU。 滤波模块滤波模块对应的函数是 x264_fdec_filter_row()。该函数完成了环路滤波，半像素插值，SSIM/PSNR 的计算的功能。该函数调用了以下及个比较重要的函数： 1234x264_frame_deblock_row() // 去块效应滤波器。x264_frame_filter() // 半像素插值。x264_pixel_ssd_wxh() // PSNR计算。x264_pixel_ssim_wxh() // SSIM计算。 分析模块分析模块对应的函数是 x264_macroblock_analyse()。该函数包含了帧内预测模式分析以及帧间运动估计等。该函数调用了以下比较重要的函数（只列举了几个有代表性的函数）： 123456789x264_mb_analyse_init() // Analysis模块初始化。x264_mb_analyse_intra() // I 宏块帧内预测模式分析。x264_macroblock_probe_pskip() // 分析是否是skip模式。x264_mb_analyse_inter_p16x16() // P16x16宏块帧间预测模式分析。x264_mb_analyse_inter_p8x8() // P8x8宏块帧间预测模式分析。x264_mb_analyse_inter_p16x8() // P16x8宏块帧间预测模式分析。x264_mb_analyse_inter_b16x16() // B16x16宏块帧间预测模式分析。x264_mb_analyse_inter_b8x8() // B8x8宏块帧间预测模式分析。x264_mb_analyse_inter_b16x8() // B16x8宏块帧间预测模式分析。 宏块编码模块宏块编码模块对应的函数是 x264_macroblock_encode()。该模块通过对残差的 DCT 变换、量化等方式对宏块进行编码。对于 Intra16x16 宏块，调用 x264_mb_encode_i16x16() 进行编码，对于 Intra4x4，调用 x264_mb_encode_i4x4() 进行编码。对于Inter类型的宏块则直接在函数体里面编码。 熵编码模块CABAC 熵编码对应的函数是 x264_macroblock_write_cabac()。CAVLC 熵编码对应的函数是 x264_macroblock_write_cavlc()。x264_macroblock_write_cavlc() 调用了以下几个比较重要的函数： 12345x264_cavlc_mb_header_i() // 写入I宏块MB Header数据。包含帧内预测模式等。x264_cavlc_mb_header_p() // 写入P宏块MB Header数据。包含MVD、参考帧序号等。x264_cavlc_mb_header_b() // 写入B宏块MB Header数据。包含MVD、参考帧序号等。x264_cavlc_qp_delta() // 写入QP。x264_cavlc_block_residual() // 写入残差数据。 码率控制模块码率控制模块函数分布在x264源代码不同的地方，包含了以下几个比较重要的函数： 123456x264_encoder_open() 中的 x264_ratecontrol_new() // 创建码率控制。x264_encoder_encode() 中的 x264_ratecontrol_start() // 开始码率控制。x264_slice_write() 中的 x264_ratecontrol_mb() // 码率控制算法。x264_encoder_encode() 中的 x264_ratecontrol_end() // 结束码率控制。x264_encoder_close() 中的 x264_ratecontrol_summary() // 码率控制信息。x264_encoder_close() 中的 x264_ratecontrol_delete() // 释放码率控制。 x264命令行工具该命令行工具可以调用 libx264 将 YUV 格式像素数据编码为 H.264 码流。 函数调用关系图 从图中可以看出，X264命令行工具调用了libx264的几个API完成了H.264编码工作。使用libx264的API进行编码可以参考《最简单的视频编码器：基于libx264（编码YUV为H.264）》，这个流程中最关键的API包括： 12345x264_param_default() // 设置参数集结构体x264_param_t的缺省值。x264_encoder_open() // 打开编码器。x264_encoder_headers() // 输出SPS，PPS，SEI等信息。x264_encoder_encode() // 编码输出一帧图像。x264_encoder_close() // 关闭编码器。 在X264命令行工具中，main() 首先调用 parse() 解析输入的命令行参数，然后调用 encode() 进行编码。 parse() 首先调用 x264_param_default() 为存储参数的结构体 x264_param_t 赋默认值；然后在一个大循环中调用 getopt_long() 逐个解析输入的参数，并作相应的处理；最后调用 select_input() 和 select_output() 解析输入文件格式（例如yuv，y4m…）和输出文件格式（例如raw，flv，MP4…）。 encode() 首先调用 x264_encoder_open() 打开H.264编码器，然后调用 x264_encoder_headers() 输出H.264码流的头信息（例如SPS、PPS、SEI），接着进入一个循环并且调用 encode_frame() 逐帧编码视频，最后调用 x264_encoder_close() 关闭解码器。其中 encode_frame() 中又调用了 x264_encoder_encode() 完成了具体的编码工作。下文将会对上述流程展开分析。 main()main() 的定义很简单，它主要调用了两个函数：parse() 和 encode() 。main() 首先调用 parse() 解析输入的命令行参数，然后调用 encode() 进行编码。下面分别分析这两个函数。 parse()parse() 用于解析命令行输入的参数（存储于 argv[] 中） 下面简单梳理 parse() 的流程： （1）调用 x264_param_default() 为存储参数的结构体 x264_param_t 赋默认值 （2）调用 x264_param_default_preset() 为 x264_param_t 赋值 （3）在一个大循环中调用 getopt_long() 逐个解析输入的参数，并作相应的处理。举几个例子： a) “-h”：调用 help() 打开帮助菜单。 b) “-V” 调用 print_version_info() 打印版本信息。 c)对于长选项，调用 x264_param_parse() 进行处理。 （4）调用 select_input() 解析输出文件格式（例如raw，flv，MP4…） （5）调用 select_output() 解析输入文件格式（例如yuv，y4m…） 下文按照顺序记录parse()中涉及到的函数： 1234567x264_param_default()x264_param_default_preset()help()print_version_info()x264_param_parse()select_input()select_output() x264_param_default() 是一个x264的API。该函数用于设置x264中 x264_param_t 结构体的默认值。 x264_param_default_preset() 是一个 libx264 的 API，用于设置 x264 的 preset 和 tune。 从源代码可以看出，x264_param_default_preset() 调用 x264_param_apply_preset() 设置 preset，调用 x264_param_apply_tune() 设置 tune。记录一下这两个函数。 help() 用于打印帮助菜单。在 x264 命令行程序中添加 “-h” 参数后会调用该函数。 print_version_info() 用于打印 x264 的版本信息。在x264命令行程序中添加 “-V” 参数后会调用该函数。 x264_param_parse() 是一个 x264 的 API。该函数以字符串键值对的方式设置 x264_param_t 结构体的一个成员变量。 x264_param_parse() 中判断参数的宏 OPT() 和 OPT2() 实质上就是 strcmp()。由此可见该函数的流程首先是调用 strcmp() 判断当前输入参数的名称 name，然后再调用 atoi()，atof()，或者 atobool() 等将当前输入参数值 value 转换成相应类型的值并赋值给对应的参数。 x264_param_apply_profile() 是一个 x264 的 API。该函数用于设置 x264 的 profile select_output() 用于设定输出的文件格式。 select_input() 用于设定输入的文件格式。 encode()encode() 编码 YUV 为 H.264 码流 从源代码可以梳理出来 encode() 的流程： （1）调用 x264_encoder_open() 打开 H.264 编码器。 （2）调用 x264_encoder_parameters() 获得当前的参数集 x264_param_t，用于后续步骤中的一些配置。 （3）调用输出格式（H.264裸流、FLV、mp4等）对应 cli_output_t 结构体的 set_param() 方法，为输出格式的封装器设定参数。其中参数源自于上一步骤得到的 x264_param_t。 （4）如果不是在每个keyframe前面都增加 SPS/PPS/SEI 的话，就调用 x264_encoder_headers() 在整个码流前面加 SPS/PPS/SEI。 （5）进入一个循环中进行一帧一帧的将 YUV 编码为 H.264： a)调用输入格式（YUV、Y4M等）对应的 cli_vid_filter_t 结构体 get_frame() 方法，获取一帧YUV数据。 b)调用 encode_frame() 编码该帧YUV数据为H.264数据，并且输出出来。该函数内部调用x264_encoder_encode() 完成编码工作，调用输出格式对应 cli_output_t 结构体的 write_frame() 完成了输出工作。 c)调用输入格式（YUV、Y4M等）对应的 cli_vid_filter_t 结构体 release_frame() 方法，释放刚才获取的 YUV 数据。 d)调用 print_status() 输出一些统计信息。 （6）编码即将结束的时候，进入另一个循环，输出编码器中缓存的视频帧： a)不再传递新的YUV数据，直接调用 encode_frame()，将编码器中缓存的剩余几帧数据编码输出出来。 b)调用 print_status() 输出一些统计信息。 （7）调用 x264_encoder_close() 关闭 H.264 编码器。 encode() 的流程中涉及到 libx264 的几个关键的 API： 1234x264_encoder_open() // 打开H.264编码器。x264_encoder_headers() // 输出SPS/PPS/SEI。x264_encoder_encode() // 编码一帧数据。x264_encoder_close() // 关闭H.264编码器。 此外上述流程中涉及到两个比较简单的函数：encode_frame() 和 print_status()。其中 encode_frame() 用于编码一帧数据，而 print_status() 用于输出一帧数据编码后的统计信息。下文记录一下这两个函数的定义。 encode_frame() 内部调用 x264_encoder_encode() 完成编码工作，调用输出格式对应 cli_output_t 结构体的 write_frame()完成了输出工作。 print_status()的代码不再详细记录，它的输出效果如下图中红框中的文字。 X264 控制台程序中和输入输出相关的结构体在x264控制台程序中有3个和输入输出相关的结构体： 123cli_output_t // 输出格式对应的结构体。输出格式一般为H.264裸流、FLV、MP4等。cli_input_t // 输入格式对应的结构体。输入格式一般为纯YUV像素数据，Y4M格式数据等。cli_vid_filter_t // 输入格式滤镜结构体。滤镜可以对输入数据做一些简单的处理，例如拉伸、裁剪等等（当然滤镜也可以不作任何处理，直接读取输入数据）。 在 x264 的编码过程中，调用 cli_vid_filter_t 结构体的 get_frame() 读取 YUV 数据，调用 cli_output_t 的 write_frame() 写入数据。 编码器主干部分“主干部分”指的就是libx264中最核心的接口函数—— x264_encoder_encode() ，以及相关的几个接口函数x264_encoder_open()，x264_encoder_headers()，和 x264_encoder_close()。 函数调用关系图 从图中可以看出，x264 主干部分最复杂的函数就是 x264_encoder_encode()，该函数完成了编码一帧 YUV 为H.264 码流的工作。与之配合的还有打开编码器的函数 x264_encoder_open()，关闭编码器的函数 x264_encoder_close()，以及输出 SPS/PPS/SEI 这样的头信息的 x264_encoder_headers()。 x264_encoder_open() 用于打开编码器，其中初始化了 libx264 编码所需要的各种变量。它调用了下面的函数： 12345678910x264_validate_parameters() // 检查输入参数（例如输入图像的宽高是否为正数）。x264_predict_16x16_init() // 初始化Intra16x16帧内预测汇编函数。x264_predict_4x4_init() // 初始化Intra4x4帧内预测汇编函数。x264_pixel_init() // 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。x264_dct_init() // 初始化DCT变换和DCT反变换相关的汇编函数。x264_mc_init() // 初始化运动补偿相关的汇编函数。x264_quant_init() // 初始化量化和反量化相关的汇编函数。x264_deblock_init() // 初始化去块效应滤波器相关的汇编函数。x264_lookahead_init() // 初始化Lookahead相关的变量。x264_ratecontrol_new() // 初始化码率控制相关的变量。 x264_encoder_headers() 输出 SPS/PPS/SEI 这些 H.264 码流的头信息。它调用了下面的函数： 123x264_sps_write() // 输出SPSx264_pps_write() // 输出PPSx264_sei_version_write() // 输出SEI x264_encoder_encode() 编码一帧 YUV 为 H.264 码流。它调用了下面的函数： 12345678910111213x264_frame_pop_unused() // 获取1个x264_frame_t类型结构体fenc。如果frames.unused[]队列不为空，就调用x264_frame_pop()从unused[]队列取1个现成的；否则就调用x264_frame_new()创建一个新的。x264_frame_copy_picture() // 将输入的图像数据拷贝至fenc。x264_lookahead_put_frame() // 将fenc放入lookahead.next.list[]队列，等待确定帧类型。x264_lookahead_get_frames() // 通过lookahead分析帧类型。该函数调用了x264_slicetype_decide()，x264_slicetype_analyse()和x264_slicetype_frame_cost()等函数。经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。x264_frame_shift() // 从frames.current[]队列取出1帧用于编码。x264_reference_update() // 更新参考帧列表。x264_reference_reset() // 如果为IDR帧，调用该函数清空参考帧列表。x264_reference_hierarchy_reset() // 如果是I（非IDR帧）、P帧、B帧（可做为参考帧），调用该函数。x264_reference_build_list() // 创建参考帧列表list0和list1。x264_ratecontrol_start() // 开启码率控制。x264_slice_init() // 创建 Slice Header。x264_slices_write() // 编码数据（最关键的步骤）。其中调用了x264_slice_write()完成了编码的工作（注意“x264_slices_write()”和“x264_slice_write()”名字差了一个“s”）。x264_encoder_frame_end() // 编码结束后做一些后续处理，例如记录一些统计信息。其中调用了x264_frame_push_unused()将fenc重新放回frames.unused[]队列，并且调用x264_ratecontrol_end()关闭码率控制。 x264_encoder_close() 用于关闭解码器，同时输出一些统计信息。它调用了下面的函数： 123x264_lookahead_delete() // 释放Lookahead相关的变量。x264_ratecontrol_summary() // 汇总码率控制信息。x264_ratecontrol_delete() // 关闭码率控制。 x264_encoder_open()x264_encoder_open() 是一个 libx264 的 API。该函数用于打开编码器，其中初始化了 libx264 编码所需要的各种变量。 根据函数调用的顺序，看一下 x264_encoder_open() 调用的下面几个函数： 12345678910x264_sps_init() // 根据输入参数生成H.264码流的SPS信息。x264_pps_init() // 根据输入参数生成H.264码流的PPS信息。x264_predict_16x16_init() // 初始化Intra16x16帧内预测汇编函数。x264_predict_4x4_init() // 初始化Intra4x4帧内预测汇编函数。x264_pixel_init() // 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。x264_dct_init() // 初始化DCT变换和DCT反变换相关的汇编函数。x264_mc_init() // 初始化运动补偿相关的汇编函数。x264_quant_init() // 初始化量化和反量化相关的汇编函数。x264_deblock_init() // 初始化去块效应滤波器相关的汇编函数。mbcmp_init() // 决定像素比较的时候使用SAD还是SATD。 相关知识简述简单记录一下帧内预测的方法。帧内预测根据宏块左边和上边的边界像素值推算宏块内部的像素值，帧内预测的效果如下图所示。其中左边的图为图像原始画面，右边的图为经过帧内预测后没有叠加残差的画面。 H.264 中有两种帧内预测模式：16x16 亮度帧内预测模式和 4x4 亮度帧内预测模式。其中 16x16 帧内预测模式一共有 4 种，如下图所示。 这 4 种模式列表如下。 模式 描述 Vertical 由上边像素推出相应像素值 Horizontal 由左边像素推出相应像素值 DC 由上边和左边像素平均值推出相应像素值 Plane 由上边和左边像素推出相应像素值 4x4 帧内预测模式一共有 9 种，如下图所示。 简单记录几个像素计算中的概念。SAD 和 SATD 主要用于帧内预测模式以及帧间预测模式的判断。有关 SAD、SATD、SSD 的定义如下： SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。 SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。它和SAD的区别在于多了一个“变换”。 SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。它和SAD的区别在于多了一个“平方”。 H.264中使用SAD和SATD进行宏块预测模式的判断。早期的编码器使用SAD进行计算，近期的编码器多使用SATD进行计算。为什么使用SATD而不使用SAD呢？关键原因在于编码之后码流的大小是和图像块DCT变换后频域信息紧密相关的，而和变换前的时域信息关联性小一些。SAD只能反应时域信息；SATD却可以反映频域信息，而且计算复杂度也低于DCT变换，因此是比较合适的模式选择的依据。 使用SAD进行模式选择的示例如下所示。下面这张图代表了一个普通的 Intra16x16 的宏块的像素。它的下方包含了使用Vertical，Horizontal，DC和Plane四种帧内预测模式预测的像素。通过计算可以得到这几种预测像素和原始像素之间的SAD（SAE）分别为3985，5097，4991，2539。由于Plane模式的SAD取值最小，由此可以断定Plane模式对于这个宏块来说是最好的帧内预测模式。 简单记录一下DCT相关的知识。DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。二维 8x8 DCT变换常见的示意图如下所示。 早期的DCT变换都使用了 8x8 的矩阵（变换系数为小数）。在 H.264 标准中新提出了一种 4x4 的矩阵。这种 4x4 DCT变换的系数都是整数，一方面提高了运算的准确性，一方面也利于代码的优化。4x4 整数DCT变换的示意图如下所示（作为对比，右侧为 4x4 块的Hadamard变换的示意图）。 简单记录一下半像素插值的知识。《H.264标准》中规定，运动估计为 1/4 像素精度。因此在H.264编码和解码的过程中，需要将画面中的像素进行插值——简单地说就是把原先的 1 个像素点拓展成 4x4 一共16个点。下图显示了H.264编码和解码过程中像素插值情况。可以看出原先的 G 点的右下方通过插值的方式产生了a、b、c、d等一共 16 个点。 如图所示，1/4 像素内插一般分成两步： （1）半像素内插。这一步通过 6 抽头滤波器获得 5 个半像素点。 （2）线性内插。这一步通过简单的线性内插获得剩余的 1/4 像素点。 图中半像素内插点为 b、m、h、s、j 五个点。半像素内插方法是对整像素点进行 6 抽头滤波得出，滤波器的权重为( 1/32, -5/32, 5/8, 5/8, -5/32, 1/32 )。例如 b 的计算公式为： b=round( (E - 5F + 20G + 20H - 5I + J ) / 32) 剩下几个半像素点的计算关系如下： 1234m：由B、D、H、N、S、U计算h：由A、C、G、M、R、T计算s：由K、L、M、N、P、Q计算j：由cc、dd、h、m、ee、ff计算。需要注意j点的运算量比较大，因为cc、dd、ee、ff都需要通过半像素内插方法进行计算。 在获得半像素点之后，就可以通过简单的线性内插获得 1/4 像素内插点了。1/4 像素内插的方式如下图所示。例如图中 a 点的计算公式如下： A=round( (G+b)/2 ) 在这里有一点需要注意：位于 4 个角的e、g、p、r 四个点并不是通过 j 点计算计算的，而是通过b、h、s、m四个半像素点计算的。 x264_encoder_headers()x264_encoder_headers() 是libx264的一个API函数，用于输出 SPS/PPS/SEI 这些 H.264 码流的头信息。 x264_encoder_close()x264_encoder_close() 是libx264的一个API函数。该函数用于关闭编码器，同时输出一些统计信息。 x264_encoder_encode()x264_encoder_encode() 是libx264的API函数，用于编码一帧 YUV 为 H.264 码流。 x264_encoder_encode() 的流程大致如下： （1）调用 x264_frame_pop_unused 获取一个空的 fenc（x264_frame_t类型）用于存储一帧编码像素数据。 （2）调用 x264_frame_copy_picture() 将外部结构体的 pic_in（x264_picture_t类型）的数据拷贝给内部结构体的 fenc（x264_frame_t 类型）。 （3）调用 x264_lookahead_put_frame() 将 fenc 放入 Lookahead 模块的队列中，等待确定帧类型。 （4）调用 x264_lookahead_get_frames() 分析 Lookahead 模块中一个帧的帧类型。分析后的帧保存在frames.current[] 中。 （5）调用 x264_frame_shift() 从 frames.current[] 中取出分析帧类型之后的 fenc。 （6）调用 x264_reference_update() 更新参考帧队列 frames.reference[]。 （7）如果编码帧 fenc 是 IDR 帧，调用 x264_reference_reset() 清空参考帧队列 frames.reference[]。 （8）调用 x264_reference_build_list() 创建参考帧列表 List0 和 List1。 （9）根据选项做一些配置： a) 如果 b_aud 不为 0，输出 AUD 类型 NALU b) 在当前帧是关键帧的情况下，如果 b_repeat_headers 不为 0，调用 x264_sps_write() 和 x264_pps_write() 输出 SPS 和 PPS。 c) 输出一些特殊的 SEI 信息，用于适配各种解码器。 （10）调用 x264_slice_init() 初始化 Slice Header 信息。 （11）调用 x264_slices_write() 进行编码。该部分是 libx264 的核心，在后续文章中会详细分析。 （12）调用 x264_encoder_frame_end() 做一些编码后的后续处理。 x264_slice_write() 是完成编码工作的函数。该函数中包含了去块效应滤波，运动估计，宏块编码，熵编码等模块。 x264_slice_write()x264_slice_write() 是 x264 项目的核心，它完成了编码了一个 Slice 的工作。根据功能的不同，该函数可以分为滤波（Filter），分析（Analysis），宏块编码（Encode）和熵编码（Entropy Encoding）几个子模块。 函数调用关系图 x264_slice_write()调用了如下函数： 123456789101112x264_nal_start() // 开始写一个NALU。x264_macroblock_thread_init() // 初始化宏块重建数据缓存fdec_buf[]和编码数据缓存fenc_buf[]。x264_slice_header_write() // 输出 Slice Header。x264_fdec_filter_row() // 滤波模块。该模块包含了环路滤波，半像素插值，SSIM/PSNR的计算。x264_macroblock_cache_load() // 将要编码的宏块的周围的宏块的信息读进来。x264_macroblock_analyse() // 分析模块。该模块包含了帧内预测模式分析以及帧间运动估计等。x264_macroblock_encode() // 宏块编码模块。该模块通过对残差的DCT变换、量化等方式对宏块进行编码。x264_macroblock_write_cabac() // CABAC熵编码模块。x264_macroblock_write_cavlc() // CAVLC熵编码模块。x264_macroblock_cache_save() // 保存当前宏块的信息。x264_ratecontrol_mb() // 码率控制。x264_nal_end() // 结束写一个NALU。 根据源代码简单梳理了 x264_slice_write() 的流程，如下所示： （1）调用 x264_nal_start() 开始输出一个 NALU。 （2）x264_macroblock_thread_init()：初始化宏块重建像素缓存 fdec_buf[] 和编码像素缓存 fenc_buf[]。 （3）调用 x264_slice_header_write() 输出 Slice Header。 （4）进入一个循环，该循环每执行一遍编码一个宏块： a) 每处理一行宏块，调用一次 x264_fdec_filter_row() 执行滤波模块。 b) 调用 x264_macroblock_cache_load_progressive() 将要编码的宏块的周围的宏块的信息读进来。 c) 调用 x264_macroblock_analyse() 执行分析模块。 d) 调用 x264_macroblock_encode() 执行宏块编码模块。 e) 调用 x264_macroblock_write_cabac()/x264_macroblock_write_cavlc() 执行熵编码模块。 f) 调用 x264_macroblock_cache_save() 保存当前宏块的信息。 g) 调用 x264_ratecontrol_mb() 执行码率控制。 h) 准备处理下一个宏块。 （5）调用 x264_nal_end() 结束输出一个 NALU。 重要的数据结构X264在宏块编码方面涉及到下面几个比较重要的结构体： 宏块像素存储缓存 fenc_buf[] 和 fdec_buf[] ——位于 x264_t.mb.pic 中，用于存储宏块的亮度和色度像素。宏块各种信息的缓存 Cache——位于 x264_t.mb.pic 中，用于存储宏块的信息例如 4x4 帧内预测模式、DCT 的非 0 系数个数、运动矢量、参考帧序号等。 图像半像素点存储空间 filtered[] ——位于 x264_frame_t 中，用于存储半像素插值后的点。 宏块像素存储缓存 fenc_buf[] 和 fdec_buf[]fenc_buf[] 和 fdec_buf[] 为 x264_t.mb.cache 中的结构体，用于存储一个宏块的像素数据。其中 fenc_buf[] 用于存储宏块编码像素数据，而 fdec_buf[] 用于存储宏块重建像素数据。他们的定义如下所示。 123456/* space for p_fenc and p_fdec */#define FENC_STRIDE 16#define FDEC_STRIDE 32//存储编码宏块fenc和重建宏块fdec的内存uint8_t fenc_buf[48*FENC_STRIDE]uint8_t fdec_buf[52*FDEC_STRIDE] 从定义可以看出，fenc_buf[] 每行 16 个数据；而 fdec_buf[] 每行 32 个数据。在 x264_t.mb.cache 中和 fenc_buf[] 和 fdec_buf[] 相关的指针数组还有 p_fenc[3] 和 p_fdec[3] ，它们中的 3 个元素 [0]、[1]、[2] 分别指向分别指向对应缓存 buf 的 Y、U、V 分量。下图画出了像素格式为 YUV420P 的时候 fenc_buf[] 的存储示意图。图中灰色区域存储 Y，蓝色区域存储 U，粉红区域存储 V。p_fenc[0] 指向 Y 的存储区域，p_fenc[1] 指向 U 的存储区域，p_fenc[2] 指向 V 的存储区域，在图中以方框的形式标注了出来。 下图画出了像素格式为 YUV420P 的时候 fdec_buf[] 的存储示意图。图中灰色区域存储 Y，蓝色区域存储 U，粉红区域存储 V。p_fenc[0] 指向 Y 的存储区域，p_fenc[1] 指向 U 的存储区域，p_fenc[2] 指向 V 的存储区域，在图中以方框的形式标注了出来。 从图中可以看出，fdec_buf[] 和 fenc_buf[] 主要的区别在于 fdec_buf[] 像素块的左边和上边包含了左上方相邻块用于预测的像素。 宏块各种信息的缓存Cache在 x264 中 x264_t.mb.cache 结构体中包含了存储宏块信息的各种各样的缓存 Cache。例如： intra4x4_pred_mode：Intra4x4 帧内预测模式的缓存 non_zero_count：DCT 的非 0 系数个数的缓存 mv：运动矢量缓存 ref：运动矢量参考帧的缓存 滤波（Filter）部分x264_fdec_filter_row() 对应着 x264 中的滤波模块。滤波模块主要完成了下面 3 个方面的功能： （1）环路滤波（去块效应滤波） （2）半像素内插 （3）视频质量指标PSNR和SSIM的计算 函数调用关系图 从图中可以看出，滤波模块对应的x264_fdec_filter_row()调用了如下函数： 1234x264_frame_deblock_row() // 去块效应滤波器。x264_frame_filter() // 半像素插值。x264_pixel_ssd_wxh() // PSNR计算。x264_pixel_ssim_wxh() // SSIM计算。 从源代码可以看出，x264_fdec_filter_row() 完成了三步工作： （1）环路滤波（去块效应滤波）。通过调用 x264_frame_deblock_row() 实现。 （2）半像素内插。通过调用 x264_frame_filter() 实现。 （3）视频质量 SSIM 和 PSNR 计算。PSNR在这里只计算了 SSD，通过调用 x264_pixel_ssd_wxh() 实现；SSIM 的计算则是通过 x264_pixel_ssim_wxh() 实现。 宏块分析（Analysis）部分-帧内宏块（Intra）x264_macroblock_analyse() 对应着 x264 中的分析模块。分析模块主要完成了下面 2 个方面的功能： （1）对于帧内宏块，分析帧内预测模式 （2）对于帧间宏块，进行运动估计，分析帧间预测模式 函数调用关系图 从图中可以看出，分析模块的 x264_macroblock_analyse() 调用了如下函数（只列举了几个有代表性的函数）： 123456789x264_mb_analyse_init() // Analysis模块初始化。x264_mb_analyse_intra() // Intra宏块帧内预测模式分析。x264_macroblock_probe_pskip() // 分析是否是skip模式。x264_mb_analyse_inter_p16x16() // P16x16宏块帧间预测模式分析。x264_mb_analyse_inter_p8x8() // P8x8宏块帧间预测模式分析。x264_mb_analyse_inter_p16x8() // P16x8宏块帧间预测模式分析。x264_mb_analyse_inter_b16x16() // B16x16宏块帧间预测模式分析。x264_mb_analyse_inter_b8x8() // B8x8宏块帧间预测模式分析。x264_mb_analyse_inter_b16x8() // B16x8宏块帧间预测模式分析。 尽管 x264_macroblock_analyse() 的源代码比较长，但是它的逻辑比较清晰，如下所示： （1）如果当前是 I Slice，调用 x264_mb_analyse_intra() 进行 Intra 宏块的帧内预测模式分析。 （2）如果当前是 P Slice，则进行下面流程的分析： a)调用 x264_macroblock_probe_pskip() 分析是否为 Skip 宏块，如果是的话则不再进行下面分析。 b)调用 x264_mb_analyse_inter_p16x16() 分析 P16x16 帧间预测的代价。 c)调用 x264_mb_analyse_inter_p8x8() 分析 P8x8 帧间预测的代价。 d)如果 P8x8 代价值小于 P16x16，则依次对 4 个 8x8 的子宏块分割进行判断： i.调用 x264_mb_analyse_inter_p4x4() 分析 P4x4 帧间预测的代价。 ii.如果 P4x4 代价值小于 P8x8 ，则调用 x264_mb_analyse_inter_p8x4() 和x264_mb_analyse_inter_p4x8() 分析 P8x4 和 P4x8 帧间预测的代价。 e)如果 P8x8 代价值小于 P16x16，调用 x264_mb_analyse_inter_p16x8() 和x264_mb_analyse_inter_p8x16() 分析 P16x8 和 P8x16 帧间预测的代价。 f)此外还要调用 x264_mb_analyse_intra() ，检查当前宏块作为 Intra 宏块编码的代价是否小于作为 P 宏块编码的代价（P Slice中也允许有 Intra 宏块）。 （3）如果当前是 B Slice，则进行和 P Slice类似的处理。 总体说来 x264_mb_analyse_intra() 通过计算 Intra16x16，Intra8x8（暂时没有研究），Intra4x4 这 3 中帧内预测模式的代价，比较后得到最佳的帧内预测模式。该函数的等流程大致如下： （1）进行 Intra16X16 模式的预测 a)调用 predict_16x16_mode_available() 根据周围宏块的情况判断其可用的预测模式（主要检查左边和上边的块是否可用）。 b)循环计算 4 种 Intra16x16 帧内预测模式： i.调用 predict_16x16[]() 汇编函数进行 Intra16x16 帧内预测 ii.调用 x264_pixel_function_t 中的 mbcmp[]() 计算编码代价（mbcmp[]() 指向 SAD 或者 SATD 汇编函数）。 c)获取最小代价的 Intra16x16 模式。 （2）进行 Intra8x8 模式的预测（未研究，流程应该类似） （3）进行 Intra4X4 块模式的预测 a)循环处理 16 个 4x4 的块： i.调用 x264_mb_predict_intra4x4_mode() 根据周围宏块情况判断该块可用的预测模式。 ii.循环计算 9 种 Intra4x4 的帧内预测模式： 1)调用 predict_4x4 []() 汇编函数进行 Intra4x4 帧内预测 2)调用 x264_pixel_function_t 中的 mbcmp[]() 计算编码代价（mbcmp[]() 指向 SAD 或者 SATD 汇编函数）。 iii.获取最小代价的 Intra4x4 模式。 b)将 16 个 4X4 块的最小代价相加，得到总代价。 （4）将上述 3 中模式的代价进行对比，取最小者为当前宏块的帧内预测模式。 宏块分析（Analysis）部分-帧间宏块（Inter）x264_macroblock_analyse() 对应着 x264 中的分析模块。分析模块主要完成了下面 2 个方面的功能： （1）对于帧内宏块，分析帧内预测模式 （2）对于帧间宏块，进行运动估计，分析帧间预测模式 详细功能说明 宏块编码（Encode）部分x264_macroblock_encode() 对应着 x264 中的宏块编码模块。宏块编码模块主要完成了 DCT 变换和量化两个步骤。 函数调用关系图 从图中可以看出，宏块编码模块的 x264_macroblock_encode() 调用了 x264_macroblock_encode_internal() ，而 x264_macroblock_encode_internal() 完成了如下功能： 12345x264_macroblock_encode_skip() // 编码Skip类型宏块。x264_mb_encode_i16x16() // 编码Intra16x16类型的宏块。该函数除了进行DCT变换之外，还对16个小块的DC系数进行了Hadamard变换。x264_mb_encode_i4x4() // 编码Intra4x4类型的宏块。// 帧间宏块编码：这一部分代码直接写在了函数体里面。x264_mb_encode_chroma() // 编码色度块。 x264_macroblock_encode() 用于编码宏块。该函数的定义位于 encoder\macroblock.c x264_macroblock_encode_internal() 的流程大致如下： （1）如果是 Skip 类型，调用 x264_macroblock_encode_skip() 编码宏块。 （2）如果是 Intra16x16 类型，调用 x264_mb_encode_i16x16() 编码宏块。 （3）如果是 Intra4x4 类型，循环 16 次调用 x264_mb_encode_i4x4() 编码宏块。 （4）如果是 Inter 类型，则不再调用子函数，而是直接进行编码： a)对 16x16 块调用 x264_dct_function_t 的 sub16x16_dct() 汇编函数，求得编码宏块数据 p_fenc 与重建宏块数据 p_fdec 之间的残差（“sub”），并对残差进行 DCT 变换。 b)分成 4 个 8x8 的块，对每个 8x8 块分别调用 x264_quant_function_t 的 quant_4x4x4() 汇编函数进行量化。 c)分成 16 个 4x4 的块，对每个 4x4 块分别调用 x264_quant_function_t 的 dequant_4x4() 汇编函数进行反量化（用于重建帧）。 d)分成 4 个 8x8 的块，对每个 8x8 块分别调用 x264_dct_function_t 的 add8x8_idct() 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。 （5） 如果对色度编码，调用 x264_mb_encode_chroma() 。 从 Inter 宏块编码的步骤可以看出，编码就是 “DCT变换+量化” 两步的组合。 简单整理一下 x264_mb_encode_i16x16() 的逻辑，如下所示： （1）调用 predict_16x16[]() 汇编函数对重建宏块数据 p_fdec 进行帧内预测。 （2）调用 x264_dct_function_t 的 sub16x16_dct() 汇编函数，计算重建宏块数据 p_fdec 与编码宏块数据p_fenc 之间的残差，然后对残差做 DCT 变换。 （3）抽取出来 16 个 4x4DCT 小块的 DC 系数，存储于 dct_dc4x4[]。 （4）分成 4 个 8x8 的块，对每个 8x8 块分别调用 x264_quant_function_t 的 quant_4x4x4() 汇编函数进行量化。 （5）分成 16 个 4x4 的块，对每个 4x4 块分别调用 x264_quant_function_t 的 dequant_4x4() 汇编函数进行反量化（用于重建帧）。 （6）对于 dct_dc4x4[] 中 16 个小块的 DC 系数作如下处理： a)调用 x264_dct_function_t 的 dct4x4dc() 汇编函数进行 Hadamard 变换。 b)调用 x264_quant_function_t 的 quant_4x4_dc() 汇编函数进行 DC 系数的量化。 c)调用 x264_dct_function_t 的 idct4x4dc() 汇编函数进行 Hadamard 反变换。 d)调用 x264_quant_function_t 的 dequant_4x4_dc() 汇编函数进行 DC 系数的反量化。 e)将反量化后的 DC 系数重新放到 16x16 块对应的位置上。 （7）调用 x264_dct_function_t 的 add16x16_idct() 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。 可以看出 Intra16x16 编码的过程就是一个 “DCT变换 + 量化 + Hadamard变换” 的流程。其中 “DCT变换 + 量化” 是一个通用的编码步骤，而 “Hadamard变换” 是专属于 Intra16x16 宏块的步骤。 简单整理一下 x264_mb_encode_i4x4() 的逻辑，如下所示： （1）调用 predict_4x4[]() 汇编函数对重建宏块数据 p_fdec 进行帧内预测。 （2）调用 x264_dct_function_t 的 sub4x4_dct () 汇编函数，计算重建宏块数据 p_fdec 与编码宏块数据 p_fenc 之间的残差，然后对残差做 DCT 变换。 （3）调用 x264_quant_function_t 的 quant_4x4() 汇编函数进行量化。 （4）调用 x264_quant_function_t 的 dequant_4x4() 汇编函数进行反量化（用于重建帧）。 （5）调用 x264_dct_function_t 的 add4x4_idct() 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。 可以看出 Intra4x4 编码的过程就是一个 “DCT变换 + 量化” 的流程。 熵编码（Entropy Encoding）部分x264_macroblock_write_cavlc() 对应着x264中的熵编码模块。熵编码模块主要完成了编码数据输出的功能。 函数调用关系图 从图中可以看出，熵编码模块包含两个函数 x264_macroblock_write_cabac() 和x264_macroblock_write_cavlc()。如果输出设置为 CABAC 编码，则会调用x264_macroblock_write_cabac()；如果输出设置为 CAVLC 编码，则会调用 x264_macroblock_write_cavlc() 。本文选择 CAVLC 编码输出函数 x264_macroblock_write_cavlc() 进行分析。该函数调用了如下函数： 12345x264_cavlc_mb_header_i() // 写入I宏块MB Header数据。包含帧内预测模式等。x264_cavlc_mb_header_p() // 写入P宏块MB Header数据。包含MVD、参考帧序号等。x264_cavlc_mb_header_b() // 写入B宏块MB Header数据。包含MVD、参考帧序号等。x264_cavlc_qp_delta() // 写入QP。x264_cavlc_block_residual() // 写入残差数据。 从源代码可以看出，x264_macroblock_write_cavlc() 的流程大致如下： （1）根据 Slice 类型的不同，调用不同的函数输出宏块头（MB Header）： a)对于 P Slice，调用 x264_cavlc_mb_header_p() b)对于 B Slice，调用 x264_cavlc_mb_header_b() c)对于 I Slice，调用 x264_cavlc_mb_header_i() （2）调用 x264_cavlc_qp_delta() 输出宏块 QP 值 （3）调用 x264_cavlc_block_residual() 输出 CAVLC 编码的残差数据 FFmpeg与libx264接口源代码简单分析本文简单记录一下 FFmpeg 的 libavcodec 中与 libx264 接口部分的源代码。该部分源代码位于 “libavcodec/libx264.c” 中。正是有了这部分代码，使得 FFmpeg 可以调用 libx264 编码 H.264 视频。 函数调用关系图 从图中可以看出，libx264 对应的 AVCodec 结构体 ff_libx264_encoder 中设定编码器初始化函数是 X264_init()，编码一帧数据的函数是 X264_frame()，编码器关闭函数是 X264_close()。 X264_init() 调用了如下函数： 123456[libx264 API] x264_param_default() // 设置默认参数。[libx264 API] x264_param_default_preset() // 设置默认preset。convert_pix_fmt() // 将FFmpeg像素格式转换为libx264像素格式。[libx264 API] x264_param_apply_profile() // 设置Profile。[libx264 API] x264_encoder_open() // 打开编码器。[libx264 API] x264_encoder_headers() // 需要全局头的时候，输出头信息。 X264_frame()调用了如下函数： 123[libx264 API] x264_encoder_encode() // 编码一帧数据。[libx264 API] x264_encoder_delayed_frames() // 输出编码器中缓存的数据。encode_nals() // 将编码后得到的x264_nal_t转换为AVPacket。 X264_close() 调用了如下函数： 1[libx264 API] x264_encoder_close() // 关闭编码器。 解码 - libavcodec H.264 解码器概述本文简单记录 FFmpeg 中 libavcodec 的 H.264 解码器（H.264 Decoder）的源代码。这个 H.264 解码器十分重要，可以说 FFmpeg 项目今天可以几乎“垄断”视音频编解码技术，很大一部分贡献就来自于这个 H.264 解码器。这个 H.264 解码器一方面功能强大，性能稳定；另一方面源代码也比较复杂，难以深入研究。本文打算梳理一下这个 H.264 解码器的源代码结构，以方便以后深入学习 H.264 使用。 PS：这部分代码挺复杂的，还有不少地方还比较模糊，还需要慢慢学习…… 函数调用关系图H.264解码器的函数调用关系图如下所示。 下面解释一下图中关键标记的含义。 作为接口的结构体FFmpeg和H.264解码器之间作为接口的结构体有2个： ff_h264_parser：用于解析 H.264 码流的 AVCodecParser 结构体。 ff_h264_decoder：用于解码 H.264 码流的 AVCodec 结构体。 函数背景色函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用： 白色背景的函数：普通内部函数。 粉红色背景函数：解析函数（Parser）。这些函数用于解析SPS、PPS等信息。 紫色背景的函数：熵解码函数（Entropy Decoding）。这些函数读取码流数据并且进行CABAC或者CAVLC熵解码。 绿色背景的函数：解码函数（Decode）。这些函数通过帧内预测、帧间预测、DCT反变换等方法解码压缩数据。 黄色背景的函数：环路滤波函数（Loop Filter）。这些函数对解码后的数据进行滤波，去除方块效应。 蓝色背景函数：汇编函数（Assembly）。这些函数是做过汇编优化的函数。图中主要画出了这些函数的C语言版本，此外这些函数还包含MMX版本、SSE版本、NEON版本等。 箭头线箭头线标志了函数的调用关系： 黑色箭头线：不加区别的调用关系。 粉红色的箭头线：解析函数（Parser）之间的调用关系。 紫色箭头线：熵解码函数（Entropy Decoding）之间的调用关系。 绿色箭头线：解码函数（Decode）之间的调用关系。 黄色箭头线：环路滤波函数（Loop Filter）之间的调用关系。 函数所在的文件每个函数标识了它所在的文件路径。 几个关键部分下文简单记录几个关键的部分。 FFmpeg和H.264解码器之间作为接口的结构体FFmpeg和H.264解码器之间作为接口的结构体有2个：ff_h264_parser和ff_h264_decoder。 ff_h264_parser ff_h264_parser是用于解析H.264码流的AVCodecParser结构体。AVCodecParser中包含了几个重要的函数指针： parser_init()：初始化解析器。 parser_parse()：解析。 parser_close()：关闭解析器。 在ff_h264_parser结构体中，上述几个函数指针分别指向下面几个实现函数： init()：初始化H.264解析器。 h264_parse()：解析H.264码流。 close()：关闭H.264解析器。 ff_h264_decoder ff_h264_decoder是用于解码H.264码流的AVCodec结构体。AVCodec中包含了几个重要的函数指针： init()：初始化解码器。 decode()：解码。 close()：关闭解码器。 在ff_h264_decoder结构体中，上述几个函数指针分别指向下面几个实现函数： ff_h264_decode_init()：初始化H.264解码器。 h264_decode_frame()：解码H.264码流。 h264_decode_end()：关闭H.264解码器。 普通内部函数普通内部函数指的是H.264解码器中还没有进行分类的函数。下面举几个例子。 ff_h264_decoder中ff_h264_decode_init()调用的初始化函数： ff_h264dsp_init()：初始化DSP相关的函数。包含了IDCT、环路滤波函数等。 ff_h264qpel_init()：初始化四分之一像素运动补偿相关的函数。 ff_h264_pred_init()：初始化帧内预测相关的函数。 ff_h264_decode_extradata()：解析AVCodecContext中的extradata。 ff_h264_decoder中h264_decode_frame()逐层调用的和解码Slice相关的函数： decode_nal_units()，ff_h264_execute_decode_slices()，decode_slice()等。 ff_h264_decoder中h264_decode_end()调用的清理函数： ff_h264_remove_all_refs()：移除所有参考帧。 ff_h264_free_context()：释放在初始化H.264解码器的时候分配的内存。 ff_h264_parser中h264_parse()逐层调用的和解析Slice相关的函数： h264_find_frame_end()：查找NALU的结尾。 parse_nal_units()：解析一个NALU。 解析函数（Parser）解析函数（Parser）用于解析H.264码流中的一些信息（例如SPS、PPS、Slice Header等）。在parse_nal_units()和decode_nal_units()中都调用这些解析函数完成了解析。下面举几个解析函数的例子。 ff_h264_decode_nal()：解析NALU。这个函数是后几个解析函数的前提。 ff_h264_decode_slice_header()：解析Slice Header。 ff_h264_decode_sei()：解析SEI。 ff_h264_decode_seq_parameter_set()：解析SPS。 ff_h264_decode_picture_parameter_set()：解析PPS。 熵解码函数（Entropy Decoding）熵解码函数（Entropy Decoding）读取码流数据并且进行CABAC或者CAVLC熵解码。CABAC解码函数是ff_h264_decode_mb_cabac()，CAVLC解码函数是ff_h264_decode_mb_cavlc()。熵解码函数中包含了很多的读取指数哥伦布编码数据的函数，例如get_ue_golomb_long()，get_ue_golomb()，get_se_golomb()，get_ue_golomb_31()等等。 在获取残差数据的时候需要进行CAVLC/CABAC解码。例如解码CAVLC的时候，会调用decode_residual()函数，而decode_residual()会调用get_vlc2()函数，get_vlc2()会调用OPEN_READER()，UPDATE_CACHE()，GET_VLC()，CLOSE_READER()几个函数读取CAVLC格式的数据。此外，在获取运动矢量的时候，会调用pred_motion()以及类似的几个函数获取运动矢量相关的信息。 解码函数（Decode）解码函数（Decode）通过帧内预测、帧间预测、DCT反变换等方法解码压缩数据。解码函数是ff_h264_hl_decode_mb()。其中跟宏块类型的不同，会调用几个不同的函数，最常见的就是调用hl_decode_mb_simple_8()。 hl_decode_mb_simple_8() 的定义是无法在源代码中直接找到的，这是因为它实际代码的函数名称是使用宏的方式写的（以后再具体分析）。hl_decode_mb_simple_8()的源代码实际上就是 FUNC(hl_decode_mb)() 函数的源代码。 FUNC(hl_decode_mb)()根据宏块类型的不同作不同的处理：如果宏块类型是INTRA，就会调用hl_decode_mb_predict_luma() 进行帧内预测；如果宏块类型不是INTRA，就会调用FUNC(hl_motion_422)() 或者 FUNC(hl_motion_420)() 进行四分之一像素运动补偿。 随后 FUNC(hl_decode_mb)() 会调用 hl_decode_mb_idct_luma() 等几个函数对数据进行DCT反变换工作。 环路滤波函数（Loop Filter）环路滤波函数（Loop Filter）对解码后的数据进行滤波，去除方块效应。环路滤波函数是loop_filter()。其中调用了ff_h264_filter_mb()和ff_h264_filter_mb_fast()。ff_h264_filter_mb_fast()中又调用了h264_filter_mb_fast_internal()。而h264_filter_mb_fast_internal()中又调用了下面几个函数进行滤波： filter_mb_edgeh()：亮度水平滤波 filter_mb_edgev()：亮度垂直滤波 filter_mb_edgech()：色度水平滤波 filter_mb_edgecv()：色度垂直滤波 汇编函数（Assembly）汇编函数（Assembly）是做过汇编优化的函数。为了提高效率，整个H.264解码器中（主要在解码部分和环路滤波部分）包含了大量的汇编函数。实际解码的过程中，FFmpeg会根据系统的特性调用相应的汇编函数（而不是C语言函数）以提高解码的效率。如果系统不支持汇编优化的话，FFmpeg才会调用C语言版本的函数。例如在帧内预测的时候，对于16x16亮度DC模式，有以下几个版本的函数： C语言版本的pred16x16_dc_8_c() NEON版本的ff_pred16x16_dc_neon() MMXEXT版本的ff_pred16x16_dc_8_mmxext() SSE2版本的ff_pred16x16_dc_8_sse2() 附录在网上找到一张图（出处不详），分析了FFmpeg的H.264解码器每个函数运行的耗时情况，比较有参考意义，在这里附上。 从图中可以看出，熵解码、宏块解码、环路滤波耗时比例分别为：23.64%、51.85%、22.22%。 解析器（Parser）部分本文继续分析FFmpeg中libavcodec的H.264解码器（H.264 Decoder）。上篇文章概述了FFmpeg中H.264解码器的结构；从这篇文章开始，具体研究H.264解码器的源代码。本文分析H.264解码器中解析器（Parser）部分的源代码。这部分的代码用于分割H.264的NALU，并且解析SPS、PPS、SEI等信息。解析H.264码流（对应AVCodecParser结构体中的函数）和解码H.264码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。 函数调用关系图 从图中可以看出，H.264的解析器（Parser）在解析数据的时候调用 h264_parse()，h264_parse() 调用了parse_nal_units()，parse_nal_units() 则调用了一系列解析特定 NALU 的函数。H.264 的解码器（Decoder）在解码数据的时候调用 h264_decode_frame()，h264_decode_frame() 调用了decode_nal_units()，decode_nal_units() 也同样调用了一系列解析不同 NALU 的函数。 图中简单列举了几个解析特定 NALU 的函数： 1234ff_h264_decode_nal() // 解析 NALU Headerff_h264_decode_seq_parameter_set() // 解析 SPSff_h264_decode_picture_parameter_set() // 解析 PPSff_h264_decode_sei() // 解析 SEI H.264 解码器与 H.264 解析器最主要的不同的地方在于它调用了 ff_h264_execute_decode_slices() 函数进行了解码工作。这篇文章只分析 H.264 解析器的源代码，至于 H.264 解码器的源代码，则在后面几篇文章中再进行分析。 h264_find_frame_end()h264_find_frame_end() 用于查找 H.264 码流中的 “起始码”（start code）。在 H.264 码流中有两种起始码： 0x000001 和 0x00000001。其中 4Byte 的长度的起始码最为常见。只有当一个完整的帧被编为多个 slice 的时候，包含这些 slice 的 NALU 才会使用 3Byte 的起始码。h264_find_frame_end() 的定义位于libavcodec\h264_parser.c 从源代码可以看出，h264_find_frame_end() 使用了一种类似于状态机的方式查找起始码。函数中的 for() 循环每执行一遍，状态机的状态就会改变一次。该状态机主要包含以下几种状态： 12345677 - 初始化状态2 - 找到1个01 - 找到2个00 - 找到大于等于3个04 - 找到2个0和1个1，即001（即找到了起始码）5 - 找到至少3个0和1个1，即0001等等（即找到了起始码）&gt;=8 - 找到2个Slice Header 这些状态之间的状态转移图如下所示。图中粉红色代表初始状态，绿色代表找到“起始码”的状态。 如图所示，h264_find_frame_end() 初始化时候位于状态 “7”；当找到 1 个 “0” 之后，状态从 “7” 变为 “2”；在状态 “2” 下，如果再次找到 1 个 “0”，则状态变为 “1”；在状态 “1” 下，如果找到 “1”，则状态变换为 “4”，表明找到了 “0x000001” 起始码；在状态 “1” 下，如果找到 “0”，则状态变换为 “0”；在状态 “0” 下，如果找到 “1”，则状态变换为 “5” ，表明找到了 “0x000001” 起始码。 parse_nal_units() 主要做了以下几步处理： （1）对于所有的 NALU，都调用 ff_h264_decode_nal 解析 NALU 的 Header，得到 nal_unit_type 等信息 （2）根据 nal_unit_type 的不同，调用不同的解析函数进行处理。例如： a)解析 SPS 的时候调用 ff_h264_decode_seq_parameter_set() b)解析 PPS 的时候调用 ff_h264_decode_picture_parameter_set() c)解析 SEI 的时候调用 ff_h264_decode_sei() d)解析 IDR Slice / Slice 的时候，获取 slice_type 等一些信息。 解码器主干部分本文分析FFmpeg的H.264解码器的主干部分。“主干部分” 是相对于 “熵解码”、“宏块解码”、“环路滤波” 这些细节部分而言的。它包含了 H.264 解码器直到 decode_slice() 前面的函数调用关系（decode_slice() 后面就是H.264解码器的细节部分，主要包含了 “熵解码”、“宏块解码”、“环路滤波” 3个部分）。 函数调用关系图 从图中可以看出，H.264解码器（Decoder）在初始化的时候调用了 ff_h264_decode_init()，ff_h264_decode_init() 又调用了下面几个函数进行解码器汇编函数的初始化工作（仅举了几个例子）： 123ff_h264dsp_init() // 初始化DSP相关的汇编函数。包含了IDCT、环路滤波函数等。ff_h264qpel_init() // 初始化四分之一像素运动补偿相关的汇编函数。ff_h264_pred_init() // 初始化帧内预测相关的汇编函数。 H.264 解码器在关闭的时候调用了 h264_decode_end()，h264_decode_end() 又调用了ff_h264_remove_all_refs()，ff_h264_free_context() 等几个函数进行清理工作。H.264 解码器在解码图像帧的时候调用了 h264_decode_frame()，h264_decode_frame() 调用了 decode_nal_units()，decode_nal_units() 调用了两类函数——解析函数和解码函数，如下所示。 （1）解析函数（获取信息）： 12345ff_h264_decode_nal() // 解析NALU Header。ff_h264_decode_seq_parameter_set() // 解析SPS。ff_h264_decode_picture_parameter_set() // 解析PPS。ff_h264_decode_sei() // 解析SEI。ff_h264_decode_slice_header() // 解析Slice Header。 （2）解码函数（解码获得图像）： 1ff_h264_execute_decode_slices() // 解码Slice。 其中 ff_h264_execute_decode_slices() 调用了 decode_slice()，而 decode_slice() 中调用了解码器中细节处理的函数（暂不详细分析）： 1234ff_h264_decode_mb_cabac() // CABAC熵解码函数。ff_h264_decode_mb_cavlc() // CAVLC熵解码函数。ff_h264_hl_decode_mb() // 宏块解码函数。loop_filter() // 环路滤波函数。 h264_decode_frame() 根据输入的 AVPacket 的 data 是否为空作不同的处理： （1）若果输入的 AVPacket 的 data 为空，则调用 output_frame() 输出 delayed_pic[] 数组中的H264Picture，即输出解码器中缓存的帧（对应的是通常称为 “Flush Decoder” 的功能）。 （2）若果输入的 AVPacket 的 data 不为空，则首先调用 decode_nal_units() 解码 AVPacket 的 data，然后再调用 output_frame() 输出解码后的视频帧（有一点需要注意：由于帧重排等因素，输出的 AVFrame 并非对应于输入的 AVPacket）。 decode_nal_units() 首先调用 ff_h264_decode_nal() 判断 NALU 的类型，然后根据 NALU 类型的不同调用了不同的处理函数。这些处理函数可以分为两类——解析函数和解码函数，如下所示。 （1）解析函数（获取信息）： 1234ff_h264_decode_seq_parameter_set() // 解析SPS。ff_h264_decode_picture_parameter_set() // 解析PPS。ff_h264_decode_sei() // 解析SEI。ff_h264_decode_slice_header() // 解析Slice Header。 （2）解码函数（解码得到图像）： 1ff_h264_execute_decode_slices() // 解码Slice。 decode_slice() 按照宏块（16x16）的方式处理输入的视频流。每个宏块的压缩数据经过以下 3 个基本步骤的处理，得到解码后的数据： （1）熵解码。如果熵编码为 CABAC，则调用 ff_h264_decode_mb_cabac()；如果熵编码为 CAVLC，则调用 ff_h264_decode_mb_cavlc() （2）宏块解码。这一步骤调用 ff_h264_hl_decode_mb() （3）环路滤波。这一步骤调用 loop_filter() 此外，还有可能调用错误隐藏函数 er_add_slice()。 至此，decode_nal_units() 函数的调用流程就基本分析完毕了。h264_decode_frame() 在调用完 decode_nal_units() 之后，还需要把解码后得到的 H264Picture 转换为 AVFrame 输出出来，这时候会调用一个相对比较简单的函数 output_frame()。 熵解码（Entropy Decoding）部分FFmpeg的H.264解码器调用 decode_slice() 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第1个步骤。 函数调用关系图 从图中可以看出，FFmpeg的熵解码方面的函数有两个：ff_h264_decode_mb_cabac() 和 ff_h264_decode_mb_cavlc()。 ff_h264_decode_mb_cabac() 用于解码 CABAC 编码方式的 H.264 数据， ff_h264_decode_mb_cavlc()用于解码 CAVLC 编码方式的 H.264 数据。 本文挑选了ff_h264_decode_mb_cavlc() 函数进行分析。 ff_h264_decode_mb_cavlc() 调用了很多的读取指数哥伦布编码数据的函数，例如 get_ue_golomb_long()，get_ue_golomb()，get_se_golomb()，get_ue_golomb_31() 等。此外在解码残差数据的时候，调用了 decode_residual()函数，而 decode_residual() 会调用 get_vlc2() 函数读取 CAVLC 编码数据。 总而言之，“熵解码” 部分的作用就是按照 H.264 语法和语义的规定，读取数据（宏块类型、运动矢量、参考帧、残差等）并且赋值到 FFmpeg H.264 解码器中相应的变量上。需要注意的是，“熵解码” 部分并不使用这些变量还原视频数据。还原视频数据的功能在下一步 “宏块解码” 步骤中完成。 在开始看 ff_h264_decode_mb_cavlc() 之前先回顾一下 decode_slice() 函数。 decode_slice() 的的流程如下： （1）判断 H.264 码流是 CABAC 编码还是 CAVLC 编码，进入不同的处理循环。 （2）如果是 CABAC 编码，首先调用 ff_init_cabac_decoder() 初始化 CABAC 解码器。然后进入一个循环，依次对每个宏块进行以下处理： a)调用 ff_h264_decode_mb_cabac()进行 CABAC 熵解码 b)调用 ff_h264_hl_decode_mb() 进行宏块解码 c)解码一行宏块之后调用 loop_filter() 进行环路滤波 d)此外还有可能调用 er_add_slice() 进行错误隐藏处理 （3）如果是 CABAC 编码，直接进入一个循环，依次对每个宏块进行以下处理： a)调用 ff_h264_decode_mb_cavlc() 进行 CAVLC 熵解码 b)调用 ff_h264_hl_decode_mb() 进行宏块解码 c)解码一行宏块之后调用 loop_filter() 进行环路滤波 d)此外还有可能调用 er_add_slice() 进行错误隐藏处理 可以看出，出了熵解码以外，宏块解码和环路滤波的函数是一样的。 ff_h264_decode_mb_cavlc() 的定义有将近 1000 行代码，算是一个比较复杂的函数了。我在其中写了不少注释，因此不再对源代码进行详细的分析。下面先简单梳理一下它的流程： （1）解析 Skip 类型宏块 （2）获取 mb_type （3）填充当前宏块左边和上边宏块的信息（后面的预测中会用到） （4）根据 mb_type 的不同，分成三种情况进行预测工作： a)宏块是帧内预测 i.如果宏块是 Intra4x4 类型，则需要单独解析帧内预测模式。 ii.如果宏块是 Intra16x16 类型，则不再做过多处理。 b)宏块划分为 4 个块（此时每个 8x8 的块可以再次划分为 4 种类型） 这个时候每个 8x8 的块可以再次划分为 8x8、8x4、4x8、4x4 几种子块。需要分别处理这些小的子块： i.解析子块的参考帧序号 ii.解析子块的运动矢量 c)其它类型（包括 16x16，16x8，8x16 几种划分，这些划分不可再次划分） 这个时候需要判断宏块的类型为 16x16，16x8 还是 8x16，然后作如下处理： i.解析子宏块的参考帧序号 ii.解析子宏块的运动矢量 （5）解码残差信息 （6）将宏块的各种信息输出到整个图片相应的变量中 各种 Cache（缓存）在 H.264 解码器中包含了各种各样的 Cache（缓存）。例如： 1234intra4x4_pred_mode_cache // Intra4x4帧内预测模式的缓存non_zero_count_cache // 每个4x4块的非0系数个数的缓存mv_cache // 运动矢量缓存ref_cache // 运动矢量参考帧的缓存 其他知识查看 宏块解码（Decode）部分-帧内宏块（Intra）FFmpeg的H.264解码器调用 decode_slice() 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤。由于宏块解码部分的内容比较多，因此将本部分内容拆分成两篇文章：一篇文章记录帧内预测宏块（Intra）的宏块解码，另一篇文章记录帧间预测宏块（Inter）的宏块解码。 函数调用关系图 宏块解码函数（Decode）通过帧内预测、帧间预测、DCT 反变换等方法解码压缩数据。解码函数是 ff_h264_hl_decode_mb()。其中跟宏块类型的不同，会调用几个不同的函数，最常见的就是调用 hl_decode_mb_simple_8()。 hl_decode_mb_simple_8() 的定义是无法在源代码中直接找到的，这是因为它实际代码的函数名称是使用宏的方式写的。hl_decode_mb_simple_8() 的源代码实际上就是 FUNC(hl_decode_mb)() 函数的源代码。 从函数调用图中可以看出，FUNC(hl_decode_mb)() 根据宏块类型的不同作不同的处理： 如果帧内预测宏块（INTRA），就会调用 hl_decode_mb_predict_luma() 进行帧内预测； 如果是帧间预测宏块（INTER），就会调用 FUNC(hl_motion_422)() 或者 FUNC(hl_motion_420)() 进行四分之一像素运动补偿。 经过帧内预测或者帧间预测步骤之后，就得到了预测数据。随后 FUNC(hl_decode_mb)() 会调用 hl_decode_mb_idct_luma() 等几个函数对残差数据进行 DCT 反变换工作，并将变换后的数据叠加到预测数据上，形成解码后的图像数据。 由于帧内预测宏块和帧间预测宏块的解码工作都比较复杂，因此分成两篇文章记录这两部分的源代码。本文记录帧内预测宏块解码时候的源代码。 下面简单梳理一下 FUNC(hl_decode_mb) 的流程（在这里只考虑亮度分量的解码，色度分量的解码过程是类似的）： （1）预测 a)如果是帧内预测宏块（Intra），调用 hl_decode_mb_predict_luma() 进行帧内预测，得到预测数据。 b)如果不是帧内预测宏块（Inter），调用 FUNC(hl_motion_420)() 或者 FUNC(hl_motion_422)() 进行帧间预测（即运动补偿），得到预测数据。 （2）残差叠加 a)调用 hl_decode_mb_idct_luma() 对 DCT 残差数据进行 DCT 反变换，获得残差像素数据并且叠加到之前得到的预测数据上，得到最后的图像数据。 PS：该流程中有一个重要的贯穿始终的内存指针 dest_y，其指向的内存中存储了解码后的亮度数据。 根据原代码梳理一下 hl_decode_mb_predict_luma() 的主干： （1）如果宏块是4x4帧内预测类型（Intra4x4），作如下处理： a)循环遍历 16 个 4x4 的块，并作如下处理： i.从 intra4x4_pred_mode_cache 中读取 4x4 帧内预测方法 ii.根据帧内预测方法调用 H264PredContext 中的汇编函数 pred4x4() 进行帧内预测 iii.调用 H264DSPContext 中的汇编函数 h264_idct_add() 对 DCT 残差数据进行 4x4DCT 反变换；如果DCT 系数中不包含 AC 系数的话，则调用汇编函数 h264_idct_dc_add() 对残差数据进行 4x4DCT 反变换（速度更快）。 （2）如果宏块是 16x16 帧内预测类型（Intra4x4），作如下处理： a)通过 intra16x16_pred_mode 获得 16x16 帧内预测方法 b)根据帧内预测方法调用 H264PredContext 中的汇编函数 pred16x16 () 进行帧内预测 c)调用 H264DSPContext 中的汇编函数 h264_luma_dc_dequant_idct () 对 16 个小块的 DC 系数进行Hadamard 反变换 在这里需要注意，帧内 4x4 的宏块在执行完 hl_decode_mb_predict_luma() 之后实际上已经完成了 “帧内预测+DCT反变换” 的流程（解码完成）；而帧内 16x16 的宏块在执行完 hl_decode_mb_predict_luma() 之后仅仅完成了 “帧内预测+Hadamard反变换 ”的流程，而并未进行 “DCT反变换” 的步骤，这一步骤需要在后续步骤中完成。 下文记录上述流程中涉及到的汇编函数（此处暂不记录DCT反变换的函数，在后文中再进行叙述）： 4x4帧内预测汇编函数：H264PredContext -&gt; pred4x4[dir]() 16x16 帧内预测汇编函数：H264PredContext -&gt; pred16x16[dir]() Hadamard反变换汇编函数：H264DSPContext-&gt;h264_luma_dc_dequant_idct() 下面根据源代码简单梳理一下 hl_decode_mb_idct_luma() 的流程： （1）判断宏块是否属于 Intra4x4 类型，如果是，函数直接返回（Intra4x4 比较特殊，它的 DCT 反变换已经前文所述的 “帧内预测” 部分完成）。 （2）根据不同的宏块类型作不同的处理： a) Intra16x16：调用 H264DSPContext 的汇编函数 h264_idct_add16intra() 进行 DCT 反变换 b) Inter类型：调用 H264DSPContext 的汇编函数 h264_idct_add16() 进行 DCT 反变换 PS：需要注意的是 h264_idct_add16intra() 和 h264_idct_add16() 只有微小的区别，它们的基本逻辑都是把 16x16 的块划分为 16 个 4x4 的块再进行 DCT 反变换。此外还有一点需要注意：函数名中的 “add” 的含义是将 DCT 反变换之后的残差像素数据直接叠加到已有数据之上。 宏块解码（Decode）部分-帧间宏块（Inter）本文分析FFmpeg的H.264解码器的宏块解码（Decode）部分。FFmpeg的H.264解码器调用 decode_slice() 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤：宏块解码。上一篇文章已经记录了帧内预测宏块（Intra）的宏块解码，本文继续上一篇文章的内容，记录帧间预测宏块（Inter）的宏块解码。 函数调用关系图参考宏块解码（Decode）部分的源代码的调用关系图 MCFUNC(hl_motion) 根据子宏块的划分类型的不同，传递不同的参数调用 mc_part() 函数。 （1）如果子宏块划分为 16x16（等同于没有划分），直接调用 mc_part() 并且传递如下参数： a)单向预测汇编函数集：qpix_put[0] （qpix_put[0]中的函数进行 16x16 块的四分之一像素运动补偿）。 b)双向预测汇编函数集：qpix_avg[0]。 c) square 设置为 1，delta 设置为 0。 d) x_offset 和 y_offset 都设置为 0。 （2）如果子宏块划分为 16x8，分两次调用 mc_part() 并且传递如下参数： a)单向预测汇编函数集：qpix_put[1] （qpix_put[1] 中的函数进行 8x8 块的四分之一像素运动补偿）。 b)双向预测汇编函数集：qpix_avg[1]。 c) square 设置为 0，delta 设置为 8。 其中第 1 次调用 mc_part() 的时候 x_offset 和 y_offset 都设置为 0，第 2 次调用 mc_part() 的时候 x_offset 设置为 0，y_offset 设置为 4。 （3）如果子宏块划分为 8x16，分两次调用 mc_part() 并且传递如下参数： a)单向预测汇编函数集：qpix_put[1] （qpix_put[1] 中的函数进行 8x8 块的四分之一像素运动补偿）。 b)双向预测汇编函数集：qpix_avg[1]。 c) square设置为 0，delta 设置为 8 * h-&gt;mb_linesize。 其中第 1 次调用 mc_part() 的时候 x_offset 和 y_offset 都设置为 0，第 2 次调用 mc_part() 的时候 x_offset 设置为 4，y_offset 设置为 0。 （4）如果子宏块划分为 8x8，说明此时每个 8x8 子宏块还可以继续划分为 8x8，8x8，4x8，4x4 几种类型，此时根据上述的规则，分成 4 次分别对这些小块做类似的处理。 qpix_put[4][16] 实际上指向了 H264QpelContex 的 put_h264_qpel_pixels_tab[4][16] ，其中存储了所有单向预测方块的四分之一像素运动补偿函数。其中： 1234qpix_put[0]存储的是16x16方块的运动补偿函数；qpix_put[1]存储的是8x8方块的运动补偿函数；qpix_put[2]存储的是4x4方块的运动补偿函数；qpix_put[3]存储的是2x2方块的运动补偿函数； 从源代码可以看出，mc_part_std() 首先计算了几个关键的用于确定子宏块位置的参数，然后根据预测类型的不同（单向预测或者双向预测），把不同的函数指针传递给 mc_dir_part()：如果仅仅使用了 list0（单向预测），则只传递 qpix_put()；如果使用了 list0 和 list1（双向预测），则调用两次 mc_dir_part()，第一次传递 qpix_put()，第二次传递 qpix_avg()。 mc_part_std() 中赋值了 3 个重要的变量（只考虑亮度）： （1）dest_y：指向子宏块亮度数据指针。这个值是通过 x_offset 和 y_offset 计算得来的。在这里需要注意一点：x_offset 和 y_offset 是以色度为基本单位的，所以在计算亮度相关的变量的时候需要乘以 2。 （2）x_offset：传入的 x_offset 本来是子宏块相对于整个宏块位置的横坐标，在这里加上 8 * h-&gt;mb_x 之后，变成了子宏块相对于整个图像的位置的横坐标（以色度为基本单位）。 （3）y_offset：传入的 y_offset 本来是子宏块相对于整个宏块位置的纵坐标，在这里加上 8 * h-&gt;mb_y 之后，变成了子宏块相对于整个图像的位置的纵坐标（以色度为基本单位）。 通过源代码，简单梳理一下 mc_dir_part() 的流程（只考虑亮度，色度的流程类似）： （1）计算 mx 和 my。mx 和 my 是当前宏块的匹配块的位置坐标。需要注意的是该坐标是以 1/4 像素（而不是整像素）为基本单位的。 （2）计算 offset。offset 是当前宏块的匹配块相对于图像的整像素偏移量，由 mx、my 计算而来。 （3）计算 luma_xy。luma_xy 决定了当前宏块的匹配块采用的四分之一像素运动补偿的方式，由 mx、my 计算而来。 （4）调用运动补偿汇编函数 qpix_op[luma_xy]() 完成运动补偿。在这里需要注意，如果子宏块不是正方形的（square 取 0），则还会调用 1 次 qpix_op[luma_xy]() 完成另外一个方块的运动补偿。 总而言之，首先找到当前宏块的匹配块的整像素位置，然后在该位置的基础上进行四分之一像素的内插，并将结果输出出来。 前文中曾经提过，由于 H.264 解码器中只提供了正方形块的四分之一像素运动补偿函数，所以如果子宏块不是正方形的（例如 16x8，8x16），就需要先将子宏块划分为正方形的方块，然后再进行两次运动补偿（两个正方形方块之间的位置关系用 delta 变量记录）。例如 16x8 的宏块，就会划分成两个 8x8 的方块，调用两次相同的运动补偿函数 下面可以看一下 C 语言版本的四分之一像素运动补偿函数的源代码。由于 1/4 像素内插比较复杂，其中还用到了整像素赋值函数以及 1/2 像素线性内插函数，所以需要从简到难一步一步的看这些源代码。打算按照顺序一步一步分析这些源代码： （1）pel_template.c（展开“ DEF_PEL(put, op_put) ”宏）：整像素赋值（用于整像素的单向预测） （2）pel_template.c（展开“ DEF_PEL(avg, op_avg) ”宏）：整像素求平均（写这个为了举一个双向预测的例子） （3）hpel_template.c(（展开“DEF_HPEL(put, op_put)”宏）：1/2 像素线性内插 （4）h264qpel_template.c（展开“ H264_LOWPASS(put_, op_put, op2_put)”宏）：半像素内插（注意不是1/2像素线性内插，而是需要滤波的） （5）h264qpel_template.c（展开“H264_MC(put_, 8)”宏）：1/4像素运动补偿 环路滤波（Loop Filter）部分本文分析FFmpeg的H.264解码器的环路滤波（Loop Filter）部分。FFmpeg的H.264解码器调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第3个步骤。 函数调用关系图 环路滤波主要用于滤除方块效应。decode_slice() 在解码完一行宏块之后，会调用 loop_filter() 函数完成环路滤波功能。loop_filter() 函数会遍历该行宏块中的每一个宏块，并且针对每一个宏块调用 ff_h264_filter_mb_fast()。ff_h264_filter_mb_fast() 又会调用 h264_filter_mb_fast_internal()。 h264_filter_mb_fast_internal() 完成了一个宏块的环路滤波工作。该函数调用 filter_mb_edgev() 和 filter_mb_edgeh() 对亮度垂直边界和水平边界进行滤波，或者调用 filter_mb_edgecv() 和 filter_mb_edgech() 对色度的的垂直边界和水平边界进行滤波。 通过源代码整理出来 h264_filter_mb_fast_internal() 的流程如下： （1）读取 QP 等几个参数，用于推导滤波门限值 alpha，beta。 （2）如果是帧内宏块（Intra），作如下处理： a)对于水平的边界，调用 filter_mb_edgeh() 进行滤波。 b)对于垂直的边界，调用 filter_mb_edgev() 进行滤波。 帧内宏块滤波过程中，对于在宏块边界上的边界（最左边的垂直边界和最上边的水平边界），采用滤波强度 Bs 为 4 的滤波；对于其它边界则采用滤波强度 Bs 为 3 的滤波。 （3）如果是其他宏块，作如下处理： a)对于水平的边界，调用 filter_mb_edgeh() 进行滤波。 b)对于垂直的边界，调用 filter_mb_edgev() 进行滤波。 此类宏块的滤波强度需要另作判断。 总体说来，一个宏块内部的滤波顺序如下图所示。图中的 “0”、“1”、“2”、“3” 为滤波的顺序。可以看出首先对垂直边界进行滤波，然后对水平边界进行滤波。垂直边界滤波按照从左到右的顺序进行，而水平边界的滤波按照从上到下的顺序进行。 H.264 中的 NAL 技术NAL 技术NAL 概述NAL 全称 Network Abstract Layer，即网络抽象层。在 H.264/AVC 视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。 现实中的传输系统是多样化的，其可靠性，服务质量，封装方式等特征各不相同，NAL 这一概念的提出提供了一个视频编码器和传输系统的友好接口，使得编码后的视频数据能够有效地在各种不同的网络环境中传输。 NAL 单元NAL 单元是 NAL 的基本语法结构，它包含一个字节的头信息和一系列来自 VCL 的称为原始字节序列载荷（RBSP）的字节流。头信息中包含着一个可否丢弃的指示标记，标识着该 NAL 单元的丢弃能否引起错误扩散，一般，如果 NAL 单元中的信息不用于构建参考图像，则认为可以将其丢弃；最后包含的是NAL 单元的类型信息，暗示着其内含有效载荷的内容。 送到解码器端的 NAL 单元必须遵守严格的顺序，如果应用程序接收到的 NAL 单元处于乱序，则必须提供一种恢复其正确顺序的方法。 NAL 实现编解码器与传输网络的结合NAL 提供了一个编解码器与传输网络的通用接口，而对于不同的网络环境，具体的实现方案是不同的。对于基于流的传输系统如 H.320、MPEG 等，需要按照解码顺序组织 NAL 单元，并为每个 NAL 单元增加若干比特字节对齐的前缀以形成字节流；对于 RTP/UDP/IP 系统，则可以直接将编码器输出的 NAL 单元作为 RTP 的有效载荷；而对于同时提供多个逻辑信道的传输系统，甚至可以根据重要性将不同类型的NAL 单元在不同服务质量的信道中传输。 结论为了实现编解码器良好的网络适应性，需要做两方面的工作： 第一、在 Codec 中将 NAL 这一技术完整而有效的实现； 第二、在遵循 H.264/AVC NAL 规范的前提下设计针对不同网络的最佳传输方案。 如果实现了以上两个目标，所实现的就不仅仅是一种视频编解码技术，而是一套适用范围很广的多媒体传输方案，该方案适用于如视频会议，数据存储，电视广播，流媒体，无线通信，远程监控等多种领域。 NALU 类型标识 NAL 单元中的 RBSP 数据类型，其中，nal_unit_type 为 1， 2， 3， 4， 5 的 NAL 单元称为 VCL 的 NAL单元，其他类型的 NAL 单元为非 VCL 的 NAL 单元。 0：未规定 1：非 IDR 图像中不采用数据划分的片段 2：非 IDR 图像中 A 类数据划分片段 3：非 IDR 图像中 B 类数据划分片段 4：非 IDR 图像中 C 类数据划分片段 5：IDR 图像的片段 6：补充增强信息（SEI） 7：序列参数集（SPS） 8：图像参数集（PPS） 9：分割符 10：序列结束符 11：流结束符 12：填充数据 13：序列参数集扩展 14：带前缀的 NAL 单元 15：子序列参数集 16 – 18：保留 19：不采用数据划分的辅助编码图像片段 20：编码片段扩展 21 – 23：保留 24 – 31：未规定 SPS 详析TODO PPS 详析TODO SEI 详析TODO NAL 在多媒体传输、存储系统中的应用NAL 的头占用了一个字节，按照比特自高至低排列可以表示如下： 10AABBBBB 其中，AA 用于表示该 NAL 是否可以丢弃（有无被其后的 NAL 参考），00b 表示没有参考作用，可丢弃，如 B slice、SEI 等，非零——包括 01b、10b、11b——表示该 NAL 不可丢弃，如 SPS、PPS、I Slice、P Slice 等。 常用的 NAL 头的取值如： 12345670x67: SPS0x68: PPS0x65: IDR0x61: non-IDR Slice0x01: B Slice0x06: SEI0x09: AU Delimiter 由于 NAL 的语法中没有给出长度信息，实际的传输、存储系统需要增加额外的头实现各个 NAL 单元的定界。其中，AVI 文件和 MPEG TS 广播流采取的是字节流的语法格式，即在 NAL 单元之前增加 0x00000001 的同步码，则从 AVI 文件或 MPEG TS PES 包中读出的一个 H.264 视频帧以下面的形式存在： 1200 00 00 01 06 ... 00 00 00 01 67 ... 00 00 00 01 68 ... 00 00 00 01 65 ...SEI 信息 SPS PPS IDR Slice 而对于 MP4 文件，NAL 单元之前没有同步码，却有若干字节的长度码，来表示 NAL 单元的长度，这个长度码所占用的字节数由 MP4 文件头给出；此外，从 MP4 读出来的视频帧不包含 PPS 和 SPS，这些信息位于 MP4的文件头中，解析器必须在打开文件的时候就获取它们。从 MP4 文件读出的一个 H.264 帧往往是下面的形式（假设长度码为 2 字节）： 1200 19 06 [... 25 字节...] 24 aa 65 [... 9386 字节...]SEI 信息 IDR Slice]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC开源src]]></title>
    <url>%2F2019%2F05%2F27%2FWebRTC%2Fwebrtc-opensrc%2F</url>
    <content type="text"><![CDATA[web端用webRTC实现的一对一视频，互动直播和会议。https://github.com/starrtc/android-demo ios源码https://github.com/starrtc/ios-demo web端源码 https://github.com/starrtc/webrtc-demo]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg框架详解]]></title>
    <url>%2F2019%2F05%2F27%2FFFmpeg%2FFFmpeg%E6%A1%86%E6%9E%B6%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[总结]FFMPEG视音频编解码零基础学习方法 架构图FFMPEG+SDL的视频播放器 最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0） FFmpeg 解码一个视频流程： SDL2.0 显示 YUV 的流程： FFMPEG的视频编码器（YUV编码为H.264） 最简单的基于FFMPEG的视频编码器（YUV编码为H.264） 最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)） 最简单的基于FFmpeg的编码器-纯净版（不包含libavformat） FFmpeg编码视频的流程图通过该流程，不仅可以编码H.264/H.265的码流，而且可以编码MPEG4/MPEG2/VP9/VP8等多种码流。实际上使用FFmpeg编码视频的方式都是一样的。图中蓝色背景的函数是实际输出数据的函数。浅绿色的函数是视频编码的函数。 简单介绍一下流程中各个函数的意义： 1234567891011av_register_all() // 注册FFmpeg所有编解码器。avformat_alloc_output_context2() // 初始化输出码流的AVFormatContext。avio_open() // 打开输出文件。av_new_stream() // 创建输出码流的AVStream。avcodec_find_encoder() // 查找编码器。avcodec_open2() // 打开编码器。avformat_write_header() // 写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。avcodec_encode_video2() // 编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。av_write_frame() // 将编码后的视频码流写入文件。flush_encoder() // 输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。av_write_trailer() // 写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。 “纯净”的基于FFmpeg的视频编码器以下记录一个更加 “纯净” 的基于 FFmpeg 的视频编码器。此前记录过一个基于 FFmpeg 的视频编码器： 《最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）》 这个视频编码器调用了 FFmpeg 中的 libavformat 和 libavcodec 两个库完成了视频编码工作。但是这不是一个 “纯净” 的编码器。 上述两个库中 libavformat 完成封装格式处理，而 libavcodec 完成编码工作。 一个 “纯净” 的编码器，理论上说只需要使用 libavcodec 就足够了，并不需要使用 libavformat。一下记录的编码器就是这样的一个 “纯净” 的编码器，它仅仅通过调用 libavcodec 将 YUV 数据编码为 H.264/HEVC 等格式的压缩视频码流。 仅使用libavcodec（不使用libavformat）编码视频的流程： 流程图中关键函数的作用如下所列： 12345avcodec_register_all() // 注册所有的编解码器。avcodec_find_encoder() // 查找编码器。avcodec_alloc_context3() // 为AVCodecContext分配内存。avcodec_open2() // 打开编码器。avcodec_encode_video2() // 编码一帧数据。 两个存储数据的结构体如下所列： 12AVFrame // 存储一帧未编码的像素数据。AVPacket // 存储一帧压缩编码数据。 对比： 简单记录一下这个只使用 libavcodec 的 “纯净版” 视频编码器和使用 libavcodec+libavformat 的视频编码器的不同。 （1） 下列与libavformat相关的函数在“纯净版”视频编码器中都不存在。 12345678910av_register_all注册所有的编解码器，复用/解复用器等等组件。其中调用了avcodec_register_all() // 注册所有编解码器相关的组件。avformat_alloc_context() // 创建AVFormatContext结构体。avformat_alloc_output_context2() // 初始化一个输出流。avio_open() // 打开输出文件。avformat_new_stream() // 创建AVStream结构体。avformat_new_stream()中会调用avcodec_alloc_context3() // 创建AVCodecContext结构体。avformat_write_header() // 写文件头。av_write_frame() // 写编码后的文件帧。av_write_trailer() // 写文件尾。 （2） 新增了如下几个函数 12avcodec_register_all() // 只注册编解码器有关的组件。avcodec_alloc_context3() // 创建AVCodecContext结构体。 可以看出，相比于“完整”的编码器，这个纯净的编码器函数调用更加简单，功能相对少一些，相对来说更加的“轻量”。 解码框架图 编码框架图 通用函数解析 函数解析 av_register_all()ffmpeg 注册复用器，编码器等的函数 av_register_all()。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。 函数调用关系图如下图所示。av_register_all() 调用了 avcodec_register_all()。avcodec_register_all() 注册了和编解码器有关的组件：硬件加速器，解码器，编码器，Parser，Bitstream Filter。av_register_all() 除了调用 avcodec_register_all() 之外，还注册了复用器，解复用器，协议处理器。 内存的分配和释放（av_malloc()、av_free()等）内存操作的常见函数位于 libavutil\mem.c 中。本文记录FFmpeg开发中最常使用的几个函数：av_malloc()，av_realloc()，av_mallocz()，av_calloc()，av_free()，av_freep()。 av_malloc() 就是简单的封装了系统函数malloc()，并做了一些错误检查工作。 关于size_tsize _t 这个类型在 FFmpeg 中多次出现，简单解释一下其作用。size _t 是为了增强程序的可移植性而定义的。不同系统上，定义 size_t 可能不一样。它实际上就是 unsigned int。 为什么要内存对齐？FFmpeg 内存分配方面多次涉及到 “内存对齐”（memory alignment）的概念。 这方面内容在 IBM 的网站上有一篇文章，讲的挺通俗易懂的，在此简单转述一下。 程序员通常认为内存就是一个字节数组，每次可以一个一个字节存取内存。例如在 C 语言中使用 char * 指代 “一块内存”，Java 中使用 byte[] 指代一块内存。如下所示。 但那实际上计算机处理器却不是这样认为的。处理器相对比较 “懒惰”，它会以 2 字节，4 字节，8 字节，16 字节甚至 32 字节来存取内存。例如下图显示了以 4 字节为单位读写内存的处理器 “看待” 上述内存的方式。 上述的存取单位的大小称之为内存存取粒度。 下面看一个实例，分别从地址0，和地址 1 读取 4 个字节到寄存器。 从程序员的角度来看，读取方式如下图所示。 而 2 字节存取粒度的处理器的读取方式如下图所示。 可以看出 2 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 2 次；从地址 1 读取 4 个字节一共读取了 3 次。由于每次读取的开销是固定的，因此从地址 1 读取 4 字节的效率有所下降。 4 字节存取粒度的处理器的读取方式如下图所示。 可以看出 4 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 1 次；从地址 1 读取 4 个字节一共读取了 2 次。从地址 1 读取的开销比从地址 0 读取多了一倍。由此可见内存不对齐对 CPU 的性能是有影响的。 123456av_malloc() // 是FFmpeg中最常见的内存分配函数, av_malloc()就是简单的封装了系统函数malloc()av_realloc() // 用于对申请的内存的大小进行调整。av_mallocz() // 可以理解为av_malloc()+zeromemoryav_calloc() // 则是简单封装了av_mallocz()av_free() // 用于释放申请的内存av_freep() // 简单封装了av_free()。并且在释放内存之后将目标指针设置为NULL 常见结构体的初始化和销毁（AVFormatContext，AVFrame等） FFMPEG中最关键的结构体之间的关系 常见的结构体如下： 1234567891011121314// 统领全局的基本结构体。主要用于处理封装格式（FLV/MKV/RMVB 等）AVFormatContext// 输入输出对应的结构体，用于输入输出（读写文件，RTMP 协议等）AVIOContext// 视音频流对应的结构体，用于视音频编解码AVStream，AVCodecContext// 存储非压缩的数据（视频对应 RGB/YUV 像素数据，音频对应 PCM 采样数据）AVFrame// 存储压缩数据（视频对应 H.264 等码流数据，音频对应 AAC/MP3 等码流数据）AVPacket 他们之间的关系如下图所示： 简单分析一下上述几个结构体的初始化和销毁函数。这些函数列表如下。 结构体 初始化 销毁 AVFormatContext avformat_alloc_context() avformat_free_context() AVIOContext avio_alloc_context() AVStream avformat_new_stream() AVCodecContext avcodec_alloc_context3() AVFrame av_frame_alloc();av_image_fill_arrays() av_frame_free() AVPacket av_init_packet();av_new_packet() av_free_packet() avformat_alloc_context()avformat_alloc_context() 的定义位于 libavformat\options.c。 avformat_alloc_context() 调用 av_malloc() 为 AVFormatContext 结构体分配了内存，而且同时也给 AVFormatContext 中的 internal 字段分配内存（这个字段是 FFmpeg 内部使用的，先不分析）。此外调用了一个 avformat_get_context_defaults() 函数。该函数用于设置 AVFormatContext 的字段的默认值。它的定义也位于 libavformat\options.c，确切的说就位于 avformat_alloc_context()上面 avformat_get_context_defaults() 首先调用 memset() 将 AVFormatContext 的所有字段置 0。而后调用了一个函数 av_opt_set_defaults() 。av_opt_set_defaults() 用于给字段设置默认值。 avformat_alloc_context() 代码的函数调用关系如下图所示。 avformat_free_context() 的声明位于 libavformat\avformat.h avformat_free_context() 的定义位于 libavformat\options.c avformat_free_context() 调用了各式各样的销毁函数：av_opt_free()，av_freep()，av_dict_free()。这些函数分别用于释放不同种类的变量，在这里不再详细讨论。 在这里看一个释放 AVStream 的函数 ff_free_stream()。该函数的定义位于 libavformat\options.c（其实就在 avformat_free_context() 上方）, 与释放 AVFormatContext 类似，释放 AVStream 的时候，也是调用了 av_freep()，av_dict_free() 这些函数释放有关的字段。如果使用了 parser 的话，会调用 av_parser_close() 关闭该 parser。 avio_alloc_context()AVIOContext 的初始化函数是 avio_alloc_context()，销毁的时候使用 av_free() 释放掉其中的缓存即可。它的声明位于 libavformat\avio.h 中 avio_alloc_context() 定义位于 libavformat\aviobuf.c 中 avio_alloc_context() 首先调用 av_mallocz() 为 AVIOContext 分配内存。而后调用了一个函数 ffio_init_context() 。该函数完成了真正的初始化工作 avformat_new_stream()avformat_new_stream() 的声明位于 libavformat\avformat.h 中 AVStream 的初始化函数是 avformat_new_stream()，销毁函数使用销毁 AVFormatContext 的 avformat_free_context() 就可以了。 avformat_new_stream() 的定义位于 libavformat\utils.c 中 avformat_new_stream() 首先调用 av_mallocz() 为 AVStream 分配内存。接着给新分配的AVStream 的各个字段赋上默认值。然后调用了另一个函数 avcodec_alloc_context3() 初始化 AVStream 中的 AVCodecContext。 avcodec_alloc_context3()avcodec_alloc_context3() 的声明位于 libavcodec\avcodec.h 中 avcodec_alloc_context3() 的定义位于 libavcodec\options.c 中 avcodec_alloc_context3() 首先调用 av_malloc() 为 AVCodecContext 分配存储空间，然后调用了一个函数 avcodec_get_context_defaults3() 用于设置该 AVCodecContext 的默认值 avformat_new_stream() 函数的调用结构如下所示： av_frame_alloc()AVFrame 的初始化函数是 av_frame_alloc()，销毁函数是 av_frame_free()。在这里有一点需要注意，旧版的 FFmpeg 都是使用 avcodec_alloc_frame() 初始化 AVFrame 的，但是我在写这篇文章的时候，avcodec_alloc_frame() 已经被标记为 “过时的” 了，为了保证与时俱进，决定分析新的API——av_frame_alloc()。 av_frame_alloc() 的声明位于 libavutil\frame.h av_frame_alloc() 的定义位于 libavutil\frame.c av_frame_alloc() 首先调用 av_mallocz() 为 AVFrame 结构体分配内存。而后调用了一个函数get_frame_defaults() 用于设置一些默认参数 从 av_frame_alloc() 的代码我们可以看出，该函数并没有为 AVFrame 的像素数据分配空间。因此AVFrame 中的像素数据的空间需要自行分配空间，例如使用 avpicture_fill()， av_image_fill_arrays() 等函数。 av_frame_alloc() 函数的调用结构如下所示： avpicture_fill()avpicture_fill() 的声明位于 libavcodec\avcodec.h avpicture_fill() 的定义位于 libavcodec\avpicture.c avpicture_fill() 仅仅是简单调用了一下 av_image_fill_arrays()。也就是说这两个函数实际上是等同的 av_image_fill_arrays()av_image_fill_arrays() 的声明位于 libavutil\imgutils.h 中 av_image_fill_arrays() 的定义位于 libavutil\imgutils.c 中 av_image_fill_arrays() 函数中包含 3 个函数：av_image_check_size()，av_image_fill_linesizes()，av_image_fill_pointers()。av_image_check_size() 用于检查输入的宽高参数是否合理，即不能太大或者为负数。av_image_fill_linesizes() 用于填充dst_linesize。av_image_fill_pointers() 则用于填充 dst_data。它们的定义相对比较简单，不再详细分析。 avpicture_fill() 函数调用关系如下图所示： av_init_packet()av_init_packet() 的声明位于 libavcodec\avcodec.h av_init_packet() 的定义位于 libavcodec\avpacket.c av_new_packet()av_new_packet() 的声明位于 libavcodec\avcodec.h av_new_packet() 的定义位于 libavcodec\avpacket.c av_new_packet() 调用了 av_init_packet(pkt)。此外还调用了一个函数 packet_alloc() packet_alloc() 中调用 av_buffer_realloc() 为 AVPacket 分配内存。然后调用 memset() 将分配的内存置 0。 PS：发现 AVPacket 的结构随着 FFmpeg 的发展越发复杂了。原先 AVPacket 中的数据仅仅存在一个 uint8_t 类型的数组里，而现在已经使用一个专门的结构体 AVBufferRef 存储数据。 av_new_packet() 代码的函数调用关系如下图所示： av_free_packet() 的声明位于 libavcodec\avcodec.h av_free_packet() 的定义位于 libavcodec\avpacket.c av_free_packet() 调用 av_buffer_unref() 释放 AVPacket 中的数据，而后还调用了av_packet_free_side_data() 释放了 side_data（存储封装格式可以提供的额外的数据）。 avio_open2()该函数用于打开 FFmpeg 的输入输出文件。avio_open2() 的声明位于 libavformat\avio.h 文件中 12int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options); avio_open2() 函数参数的含义如下： 12345678s：函数调用成功之后创建的AVIOContext结构体。url：输入输出协议的地址（文件也是一种“广义”的协议，对于文件来说就是文件的路径）。flags：打开地址的方式。可以选择只读，只写，或者读写。取值如下。AVIO_FLAG_READ：只读。AVIO_FLAG_WRITE：只写。AVIO_FLAG_READ_WRITE：读写。int_cb：目前还没有用过。options：目前还没有用过。 函数调用结构图： av_find_decoder() 和 av_find_encoder()avcodec_find_encoder() 用于查找 FFmpeg 的编码器， avcodec_find_decoder() 用于查找 FFmpeg 的解码器。 avcodec_find_encoder() 的声明位于 libavcodec\avcodec.h 1AVCodec *avcodec_find_encoder(enum AVCodecID id); 函数的参数是一个编码器的 ID，返回查找到的编码器（没有找到就返回NULL）。 avcodec_find_decoder() 的声明也位于 libavcodec\avcodec.h 1AVCodec *avcodec_find_decoder(enum AVCodecID id); 函数的参数是一个解码器的 ID，返回查找到的解码器（没有找到就返回NULL）。 avcodec_find_encoder() 和 avcodec_find_decoder() 的函数调用关系图如下所示： avcodec_find_encoder() 的源代码位于 libavcodec\utils.c avcodec_find_encoder() 调用了一个 find_encdec()，注意它的第二个参数是 1。 find_encdec() 的源代码位于 libavcodec\utils.c find_encdec() 中有一个循环，该循环会遍历 AVCodec 结构的链表，逐一比较输入的 ID 和每一个编码器的 ID，直到找到 ID 取值相等的编码器。 在这里有几点需要注意： （1）first_avcodec 是一个全局变量，存储 AVCodec 链表的第一个元素。 （2）remap_deprecated_codec_id() 用于将一些过时的编码器 ID 映射到新的编码器 ID。 （3）函数的第二个参数 encoder 用于确定查找编码器还是解码器。当该值为 1 的时候，用于查找编码器，此时会调用 av_codec_is_encoder() 判断 AVCodec 是否为编码器；当该值为 0 的时候，用于查找解码器，此时会调用 av_codec_is_decoder() 判断 AVCodec 是否为解码器。 avcodec_find_decoder() 的源代码位于 libavcodec\utils.c avcodec_find_decoder() 同样调用了 find_encdec()，只是第 2 个参数设置为 0。 avcodec_open2()该函数用于初始化一个视音频编解码器的 AVCodecContext。 avcodec_open2() 的声明位于 libavcodec\avcodec.h 1int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options); 用中文简单转述一下avcodec_open2()各个参数的含义： 123avctx：需要初始化的 AVCodecContext。codec：输入的 AVCodecoptions：一些选项。例如使用 libx264 编码的时候，“preset”，“tune”等都可以通过该参数设置。 avcodec_open2() 函数调用关系非常简单，如下图所示： avcodec_open2() 的定义位于 libavcodec\utils.c avcodec_open2() 的源代码量是非常长的，但是它的调用关系非常简单——它只调用了一个关键的函数，即 AVCodec 的 init()，后文将会对这个函数进行分析。 我们可以简单梳理一下 avcodec_open2() 所做的工作，如下所列： （1）为各种结构体分配内存（通过各种 av_malloc() 实现）。 （2）将输入的 AVDictionary 形式的选项设置到 AVCodecContext。 （3）其他一些零零碎碎的检查，比如说检查编解码器是否处于 “实验” 阶段。 （4）如果是编码器，检查输入参数是否符合编码器的要求 （5）调用 AVCodec 的 init() 初始化具体的解码器。 前几步比较简单，不再分析。在这里我们分析一下第4步和第5步。 检查输入参数是否符合编码器要求在这里简单分析一下第 4 步，即 “检查输入参数是否符合编码器的要求”。这一步中检查了很多的参数，在这里我们随便选一个参数 pix_fmts（像素格式）看一下，如下所示。 代码： 12345678910111213141516171819202122//检查像素格式 if (avctx-&gt;codec-&gt;pix_fmts) &#123; for (i = 0; avctx-&gt;codec-&gt;pix_fmts[i] != AV_PIX_FMT_NONE; i++) if (avctx-&gt;pix_fmt == avctx-&gt;codec-&gt;pix_fmts[i]) break; if (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_NONE &amp;&amp; !((avctx-&gt;codec_id == AV_CODEC_ID_MJPEG || avctx-&gt;codec_id == AV_CODEC_ID_LJPEG) &amp;&amp; avctx-&gt;strict_std_compliance &lt;= FF_COMPLIANCE_UNOFFICIAL)) &#123; char buf[128]; snprintf(buf, sizeof(buf), "%d", avctx-&gt;pix_fmt); av_log(avctx, AV_LOG_ERROR, "Specified pixel format %s is invalid or not supported\n", (char *)av_x_if_null(av_get_pix_fmt_name(avctx-&gt;pix_fmt), buf)); ret = AVERROR(EINVAL); goto free_and_end; &#125; if (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ420P || avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ411P || avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ422P || avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ440P || avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ444P) avctx-&gt;color_range = AVCOL_RANGE_JPEG; &#125; 可以看出，该代码首先进入了一个 for() 循环，将 AVCodecContext 中设定的 pix_fmt 与编码器AVCodec 中的 pix_fmts 数组中的元素逐一比较。 先简单介绍一下 AVCodec 中的 pix_fmts 数组。AVCodec 中的 pix_fmts 数组存储了该种编码器支持的像素格式，并且规定以 AV_PIX_FMT_NONE（AV_PIX_FMT_NONE 取值为 -1）为结尾。例如，libx264 的 pix_fmts 数组的定义位于 libavcodec\libx264.c，如下所示。 代码： 1234567891011static const enum AVPixelFormat pix_fmts_8bit[] = &#123; AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_NV12, AV_PIX_FMT_NV16, AV_PIX_FMT_NONE&#125;; 从 pix_fmts_8bit 的定义可以看出 libx264 主要支持的是以 YUV 为主的像素格式。 现在回到 “检查输入 pix_fmt 是否符合编码器的要求” 的那段代码。如果 for() 循环从 AVCodec-&gt;pix_fmts 数组中找到了符合 AVCodecContext-&gt;pix_fmt 的像素格式，或者完成了 AVCodec-&gt;pix_fmts 数组的遍历，都会跳出循环。如果发现 AVCodec-&gt;pix_fmts 数组中索引为 i 的元素是 AV_PIX_FMT_NONE（即最后一个元素，取值为 -1）的时候，就认为没有找到合适的像素格式，并且最终提示错误信息。 AVCodec-&gt;init()avcodec_open2() 中最关键的一步就是调用 AVCodec 的 init() 方法初始化具体的编码器。AVCodec 的 init() 是一个函数指针，指向具体编解码器中的初始化函数。这里我们以 libx264 为例，看一下它对应的 AVCodec 的定义。 libx264 对应的 AVCodec 的定义位于 libavcodec\libx264.c 代码： 1234567891011121314AVCodec ff_libx264_encoder = &#123; .name = "libx264", .long_name = NULL_IF_CONFIG_SMALL("libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H264, .priv_data_size = sizeof(X264Context), .init = X264_init, .encode2 = X264_frame, .close = X264_close, .capabilities = CODEC_CAP_DELAY | CODEC_CAP_AUTO_THREADS, .priv_class = &amp;x264_class, .defaults = x264_defaults, .init_static_data = X264_init_static,&#125;; 可以看出在 ff_libx264_encoder 中 init() 指向 X264_init() 。X264_init() 的定义同样位于libavcodec\libx264.c X264_init() 的代码以后研究 X264 的时候再进行细节的分析，在这里简单记录一下它做的两项工作： （1）设置 X264Context 的参数。X264Context 主要完成了 libx264 和 FFmpeg 对接的功能。可以看出代码主要在设置一个 params 结构体变量，该变量的类型即是 x264 中存储参数的结构体 x264_param_t。 （2）调用 libx264 的 API 进行编码器的初始化工作。例如调用 x264_param_default() 设置默认参数，调用 x264_param_apply_profile() 设置 profile，调用 x264_encoder_open() 打开编码器等等。 最后附上 X264Context 的定义，位于 libavcodec\libx264.c avcodec_close()该函数用于关闭编码器。avcodec_close() 函数的声明位于 libavcodec\avcodec.h 1int avcodec_close(AVCodecContext *avctx); 该函数只有一个参数，就是需要关闭的编码器的 AVCodecContext。 函数的调用关系图如下所示： avcodec_close() 的定义位于 libavcodec\utils.c 从 avcodec_close() 的定义可以看出，该函数释放 AVCodecContext 中有关的变量，并且调用了 AVCodec 的 close() 关闭了解码器。 解码图解 FFMPEG 打开媒体的函数 avformat_open_inputFFMPEG打开媒体的的过程开始于avformat_open_input，因此该函数的重要性不可忽视。 在该函数中，FFMPEG完成了： 输入输出结构体 AVIOContext 的初始化； 输入数据的协议（例如 RTMP，或者 file）的识别（通过一套评分机制）: 判断文件名的后缀 读取文件头的数据进行比对； 使用获得最高分的文件协议对应的 URLProtocol，通过函数指针的方式，与 FFMPEG 连接（非专业用词）； 剩下的就是调用该 URLProtocol 的函数进行 open, read 等操作了 以下是通过 eclipse+MinGW 调试 FFMPEG 源代码获得的函数调用关系图： 可见最终都调用了 URLProtocol 结构体中的函数指针。 URLProtocol 结构如下，是一大堆函数指针的集合（avio.h文件） 代码 1234567891011121314151617typedef struct URLProtocol &#123; const char *name; int (*url_open)(URLContext *h, const char *url, int flags); int (*url_read)(URLContext *h, unsigned char *buf, int size); int (*url_write)(URLContext *h, const unsigned char *buf, int size); int64_t (*url_seek)(URLContext *h, int64_t pos, int whence); int (*url_close)(URLContext *h); struct URLProtocol *next; int (*url_read_pause)(URLContext *h, int pause); int64_t (*url_read_seek)(URLContext *h, int stream_index, int64_t timestamp, int flags); int (*url_get_file_handle)(URLContext *h); int priv_data_size; const AVClass *priv_data_class; int flags; int (*url_check)(URLContext *h, int mask);&#125; URLProtocol; URLProtocol 功能就是完成各种输入协议的读写等操作 但输入协议种类繁多，它是怎样做到 “大一统” 的呢？ 原来，每个具体的输入协议都有自己对应的 URLProtocol。 比如 file 协议（FFMPEG 把文件也当做一种特殊的协议）（*file.c 文件） 代码： 12345678URLProtocol ff_pipe_protocol = &#123; .name = "pipe", .url_open = pipe_open, .url_read = file_read, .url_write = file_write, .url_get_file_handle = file_get_handle, .url_check = file_check,&#125;; 或者rtmp协议（此处使用了librtmp）（librtmp.c文件） 代码： 123456789101112URLProtocol ff_rtmp_protocol = &#123; .name = "rtmp", .url_open = rtmp_open, .url_read = rtmp_read, .url_write = rtmp_write, .url_close = rtmp_close, .url_read_pause = rtmp_read_pause, .url_read_seek = rtmp_read_seek, .url_get_file_handle = rtmp_get_file_handle, .priv_data_size = sizeof(RTMP), .flags = URL_PROTOCOL_FLAG_NETWORK,&#125;; 可见它们把各自的函数指针都赋值给了 URLProtocol 结构体的函数指针 因此 avformat_open_input 只需调用 url_open, url_read 这些函数就可以完成各种具体输入协议的 open, read 等操作了 avformat_open_input() FFMPEG源码分析：avformat_open_input()（媒体打开函数） avformat_open_input() 个人感觉这个函数确实太重要了，可以算作 FFmpeg 的 “灵魂” 函数用于打开多媒体数据并且获得一些相关的信息。它的声明位于 libavformat\avformat.h 1int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options); 参数说明： 1234ps：函数调用成功之后处理过的 AVFormatContext 结构体。file：打开的视音频流的 URL。fmt：强制指定 AVFormatContext 中 AVInputFormat 的。这个参数一般情况下可以设置为 NULL，这样 FFmpeg 可以自动检测 AVInputFormat。dictionay：附加的一些选项，一般情况下可以设置为 NULL。 函数执行成功的话，其返回值大于等于 0。 函数调用结构图如下所示： avformat_open_input() 定义位于 libavformat\utils.c 中 avformat_open_input() 源代码比较长，一部分是一些容错代码，比如说如果发现传入的 AVFormatContext 指针没有初始化过，就调用 avformat_alloc_context() 初始化该结构体；还有一部分是针对一些格式做的特殊处理，比如 id3v2 信息的处理等等。有关上述两种信息不再详细分析，在这里只选择它关键的两个函数进行分析： init_input()：绝大部分初始化工作都是在这里做的。 s-&gt;iformat-&gt;read_header()：读取多媒体数据文件头，根据视音频流创建相应的 AVStream。 init_input()init_input() 作为一个内部函数，竟然包含了一行注释（一般内部函数都没有注释），足可以看出它的重要性。它的主要工作就是打开输入的视频数据并且探测视频的格式。该函数的定义位于 libavformat\utils.c 代码： 12345678910111213141516171819202122232425262728293031/* Open input file and probe the format if necessary. */static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)&#123; int ret; AVProbeData pd = &#123; filename, NULL, 0 &#125;; int score = AVPROBE_SCORE_RETRY; if (s-&gt;pb) &#123; s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO; if (!s-&gt;iformat) return av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename, s, 0, s-&gt;format_probesize); else if (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) av_log(s, AV_LOG_WARNING, "Custom AVIOContext makes no sense and " "will be ignored with AVFMT_NOFILE format.\n"); return 0; &#125; if ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) || (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, 0, &amp;score)))) return score; if ((ret = avio_open2(&amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, &amp;s-&gt;interrupt_callback, options)) &lt; 0) return ret; if (s-&gt;iformat) return 0; return av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename, s, 0, s-&gt;format_probesize);&#125; 这个函数在短短的几行代码中包含了好几个 return，因此逻辑还是有点复杂的，我们可以梳理一下： 在函数的开头的 score 变量是一个判决 AVInputFormat 的分数的门限值，如果最后得到的 AVInputFormat 的分数低于该门限值，就认为没有找到合适的 AVInputFormat 。 FFmpeg 内部判断封装格式的原理实际上是对每种 AVInputFormat 给出一个分数，满分是 100 分，越有可能正确的 AVInputFormat 给出的分数就越高。最后选择分数最高的 AVInputFormat 作为推测结果。score 的值是一个宏定义 AVPROBE_SCORE_RETRY，我们可以看一下它的定义： 1#define AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4) 其中 AVPROBE_SCORE_MAX 是 score 的最大值，取值是 100： 1#define AVPROBE_SCORE_MAX 100 ///&lt; maximum score 由此我们可以得出 score 取值是 25，即如果推测后得到的最佳 AVInputFormat 的分值低于 25，就认为没有找到合适的 AVInputFormat。 整个函数的逻辑大体如下： （1）当使用了自定义的 AVIOContext 的时候（AVFormatContext 中的 AVIOContext 不为空，即 s-&gt;pb!=NULL），如果指定了 AVInputFormat 就直接返回，如果没有指定就调用 av_probe_input_buffer2() 推测 AVInputFormat。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 AVIOContext），就会执行这一步骤。 （2）在更一般的情况下，如果已经指定了 AVInputFormat，就直接返回；如果没有指定 AVInputFormat，就调用 av_probe_input_format(NULL,…) 根据文件路径判断文件格式。这里特意把 av_probe_input_format() 的第 1 个参数写成 “NULL”，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 AVInputFormat。 （3）如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 avio_open2() 打开文件，然后调用 av_probe_input_buffer2() 推测 AVInputFormat。 avformat_find_stream_info()该函数可以读取一部分视音频数据并且获得一些相关的信息。 avformat_find_stream_info() 的声明位于 libavformat\avformat.h 1int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options); 简单解释一下它的参数的含义： 12ic：输入的 AVFormatContext。options：额外的选项，目前没有深入研究过。 函数正常执行后返回值大于等于 0。 PS：由于该函数比较复杂，所以只看了一部分代码，以后有时间再进一步分析。 函数的调用关系如下图所示： avformat_find_stream_info() 的定义位于 libavformat\utils.c 由于avformat_find_stream_info() 代码比较长，难以全部分析，在这里只能简单记录一下它的要点。该函数主要用于给每个媒体流（音频/视频）的 AVStream 结构体赋值。我们大致浏览一下这个函数的代码，会发现它其实已经实现了解码器的查找，解码器的打开，视音频帧的读取，视音频帧的解码等工作。换句话说，该函数实际上已经“走通”的解码的整个流程。下面看一下除了成员变量赋值之外，该函数的几个关键流程。 查找解码器：find_decoder() 打开解码器：avcodec_open2() 读取完整的一帧压缩编码的数据：read_frame_internal() 注：av_read_frame() 内部实际上就是调用的 read_frame_internal()。 解码一些压缩编码数据：try_decode_frame() av_read_frame()ffmpeg 中的 av_read_frame() 的作用是读取码流中的音频若干帧或者视频一帧。例如，解码视频的时候，每解码一个视频帧，需要先调用 av_read_frame() 获得一帧视频的压缩数据，然后才能对该数据进行解码（例如 H.264 中一帧压缩数据通常对应一个 NAL）。 上代码之前，先参考了其他人对 av_read_frame() 的解释，在此做一个参考： 通过 av_read_packet()，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况，以 ts 流为例，是读取一个完整的 PES 包（一个完整 pes 包包含若干视频或音频 es 包），读取完毕后，通过 av_parser_parse2() 分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则 st = s-&gt;cur_st ; 不会是 NULL，即再此进入 av_parser_parse2() 流程，而不是下面的 av_read_packet（） 流程，这样就保证了，如果读取一次包含了 N 帧视频数据（以视频为例），则调用 av_read_frame（） N 次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。 av_read_frame() 的声明位于 libavformat\avformat.h 1int av_read_frame(AVFormatContext *s, AVPacket *pkt); av_read_frame() 使用方法在注释中写得很详细，用中文简单描述一下它的两个参数： 12s：输入的AVFormatContextpkt：输出的AVPacket 如果返回 0 则说明读取正常。 函数调用结构图如下所示： av_read_frame() 的定义位于 libavformat\utils.c read_frame_internal() 代码比较长，这里只简单看一下它前面的部分。它前面部分有 2 步是十分关键的： （1）调用了 ff_read_packet() 从相应的 AVInputFormat 读取数据。 （2）如果媒体频流需要使用 AVCodecParser，则调用 parse_packet() 解析相应的 AVPacket。 ff_read_packet() 中最关键的地方就是调用了 AVInputFormat 的 read_packet() 方法。 AVInputFormat 的 read_packet() 是一个函数指针，指向当前的 AVInputFormat 的读取数据的函数。在这里我们以 FLV 封装格式对应的 AVInputFormat 为例，看看 read_packet() 的实现函数是什么样子的。 FLV 封装格式对应的 AVInputFormat 的定义位于 libavformat\flvdec.c 代码： 123456789101112AVInputFormat ff_flv_demuxer = &#123; .name = "flv", .long_name = NULL_IF_CONFIG_SMALL("FLV (Flash Video)"), .priv_data_size = sizeof(FLVContext), .read_probe = flv_probe, .read_header = flv_read_header, .read_packet = flv_read_packet, .read_seek = flv_read_seek, .read_close = flv_read_close, .extensions = "flv", .priv_class = &amp;flv_class,&#125;; 从 ff_flv_demuxer 的定义可以看出，read_packet() 对应的是 flv_read_packet() 函数。在看 flv_read_packet() 函数之前，我们先回顾一下 FLV 封装格式的结构，如下图所示。 PS：原图是网上找的，感觉画的很清晰，比官方的 Video File Format Specification 更加通俗易懂。但是图中有一个错误，就是 TagHeader 中的 StreamID 字段的长度写错了（查看了一下官方标准，应该是 3 字节，现在已经改过来了）。 从图中可以看出，FLV 文件体部分是由一个一个的 Tag 连接起来的（中间间隔着 Previous Tag Size）。每个 Tag 包含了 Tag Header 和 Tag Data 两个部分。 Tag Data 根据 Tag 的 Type 不同而不同：可以分为音频 Tag Data，视频 Tag Data 以及 Script Tag Data。下面简述一下音频 Tag Data 和视频 Tag Data。 Audio Tag DataAudio Tag在官方标准中定义如下。 Audio Tag 开始的第 1 个字节包含了音频数据的参数信息，从第 2 个字节开始为音频流数据。第 1 个字节的前 4 位的数值表示了音频数据格式： 123456789101112130 = Linear PCM, platform endian1 = ADPCM2 = MP33 = Linear PCM, little endian4 = Nellymoser 16-kHz mono5 = Nellymoser 8-kHz mono6 = Nellymoser7 = G.711 A-law logarithmic PCM8 = G.711 mu-law logarithmic PCM9 = reserved10 = AAC14 = MP3 8-Khz15 = Device-specific sound 第 1 个字节的第 5-6 位的数值表示采样率：0 = 5.5kHz，1 = 11KHz，2 = 22 kHz，3 = 44 kHz。 第 1 个字节的第7位表示采样精度：0 = 8bits，1 = 16bits。 第 1 个字节的第8位表示音频类型：0 = sndMono，1 = sndStereo。 其中，当音频编码为 AAC 的时候，第一个字节后面存储的是 AACAUDIODATA，格式如下所示。 Video Tag DataVideo Tag在官方标准中的定义如下： Video Tag 也用开始的第 1 个字节包含视频数据的参数信息，从第 2 个字节为视频流数据。 第 1 个字节的前 4 位的数值表示帧类型（FrameType）： 123451: keyframe (for AVC, a seekableframe)（关键帧）2: inter frame (for AVC, a nonseekableframe)3: disposable inter frame (H.263only)4: generated keyframe (reservedfor server use only)5: video info/command frame 第 1 个字节的后 4 位的数值表示视频编码 ID（CodecID）： 12345671: JPEG (currently unused)2: Sorenson H.2633: Screen video4: On2 VP65: On2 VP6 with alpha channel6: Screen video version 27: AVC 其中，当音频编码为 AVC（H.264）的时候，第一个字节后面存储的是 AVCVIDEOPACKET，格式如下所示。 了解了 FLV 的基本格式之后，就可以看一下 FLV 解析 Tag 的函数 flv_read_packet()了。 flv_read_packet() 的定义位于 libavformat\flvdec.c flv_read_packet() 的代码比较长，但是逻辑比较简单。它的主要功能就是根据 FLV 文件格式的规范，逐层解析 Tag 以及 TagData，获取 Tag 以及 TagData 中的信息。比较关键的地方已经写上了注释，不再详细叙述。 parse_packet() 给需要 AVCodecParser 的媒体流提供解析 AVPacket 的功能。 从代码中可以看出，最终调用了相应 AVCodecParser 的 av_parser_parse2() 函数，解析出来 AVPacket。此后根据解析的信息还进行了一系列的赋值工作，不再详细叙述。 avcodec_decode_video2()ffmpeg 中的 avcodec_decode_video2() 的作用是解码一帧视频数据。输入一个压缩编码的结构体 AVPacket，输出一个解码后的结构体 AVFrame。该函数的声明位于 libavcodec\avcodec.h 123int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, const AVPacket *avpkt); 查看源代码之后发现，这个函数竟然十分的简单，源代码位于 libavcodec\utils.c 从代码中可以看出，avcodec_decode_video2() 主要做了以下几个方面的工作： （1）对输入的字段进行了一系列的检查工作：例如宽高是否正确，输入是否为视频等等。 （2）通过 ret = avctx-&gt;codec-&gt;decode(avctx, picture, got_picture_ptr,&amp;tmp) 这句代码，调用了相应 AVCodec 的 decode() 函数，完成了解码操作。 （3）对得到的 AVFrame 的一些字段进行了赋值，例如宽高、像素格式等等。 其中第二部是关键的一步，它调用了 AVCodec 的 decode() 方法完成了解码。AVCodec 的 decode() 方法是一个函数指针，指向了具体解码器的解码函数。在这里我们以 H.264 解码器为例，看一下解码的实现过程。H.264 解码器对应的 AVCodec 的定义位于 libavcodec\h264.c，如下所示。 代码： 123456789101112131415161718AVCodec ff_h264_decoder = &#123; .name = "h264", .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H264, .priv_data_size = sizeof(H264Context), .init = ff_h264_decode_init, .close = h264_decode_end, .decode = h264_decode_frame, .capabilities = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS, .flush = flush_dpb, .init_thread_copy = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy), .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context), .profiles = NULL_IF_CONFIG_SMALL(profiles), .priv_class = &amp;h264_class,&#125;; 从 ff_h264_decoder 的定义可以看出，decode() 指向了 h264_decode_frame() 函数。 从 h264_decode_frame() 的定义可以看出，它调用了 decode_nal_units() 完成了具体的 H.264 解码工作。 avformat_close_input()该函数用于关闭一个 AVFormatContext，一般情况下是和 avformat_open_input() 成对使用的。 函数的调用关系如下图所示： avformat_close_input() 的源代码位于 libavformat\utils.c 从源代码中可以看出，avformat_close_input() 主要做了以下几步工作： （1）调用 AVInputFormat 的 read_close() 方法关闭输入流 （2）调用 avformat_free_context() 释放 AVFormatContext （3）调用 avio_close() 关闭并且释放 AVIOContext 编码avformat_alloc_output_context2()在基于 FFmpeg 的视音频编码器程序中，该函数通常是第一个调用的函数（除了组件注册函数 av_register_all()）。 avformat_alloc_output_context2() 函数可以初始化一个用于输出的 AVFormatContext 结构体。它的声明位于 libavformat\avformat.h 12int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename); 代码中的英文注释写的已经比较详细了，在这里拿中文简单叙述一下。 12345ctx：函数调用成功之后创建的AVFormatContext结构体。oformat：指定AVFormatContext中的AVOutputFormat，用于确定输出格式。如果指定为NULL，可以设定后两个参数（format_name或者filename）由FFmpeg猜测输出格式。PS：使用该参数需要自己手动获取AVOutputFormat，相对于使用后两个参数来说要麻烦一些。format_name：指定输出格式的名称。根据格式名称，FFmpeg会推测输出格式。输出格式可以是“flv”，“mkv”等等。filename：指定输出文件的名称。根据文件名称，FFmpeg会推测输出格式。文件名称可以是“xx.flv”，“yy.mkv”等等。 函数执行成功的话，其返回值大于等于0。 首先贴出来最终分析得出的函数调用结构图，如下所示： avformat_alloc_output_context2() 的函数定义位于 libavformat\mux.c 从代码中可以看出，avformat_alloc_output_context2() 的流程如要包含以下 2 步： 1) 调用 avformat_alloc_context() 初始化一个默认的 AVFormatContext。 2) 如果指定了输入的 AVOutputFormat，则直接将输入的 AVOutputFormat 赋值给AVOutputFormat 的 oformat。如果没有指定输入的 AVOutputFormat，就需要根据文件格式名称或者文件名推测输出的 AVOutputFormat。无论是通过文件格式名称还是文件名推测输出格式，都会调用一个函数 av_guess_format()。 avformat_alloc_context() 首先调用 av_malloc() 为 AVFormatContext 分配一块内存。然后调用了一个函数 avformat_get_context_defaults() 用于给 AVFormatContext 设置默认值 avformat_alloc_context() 首先调用 memset() 将 AVFormatContext 的内存置零；然后指定它的AVClass（指定了 AVClass 之后，该结构体就支持和 AVOption 相关的功能）；最后调用 av_opt_set_defaults() 给 AVFormatContext 的成员变量设置默认值（av_opt_set_defaults() 就是和 AVOption 有关的一个函数，专门用于给指定的结构体设定默认值，此处暂不分析）。 av_guess_format() 中使用一个整型变量 score 记录每种输出格式的匹配程度。函数中包含了一个 while() 循环，该循环利用函数 av_oformat_next() 遍历 FFmpeg 中所有的 AVOutputFormat，并逐一计算每个输出格式的 score。具体的计算过程分成如下几步： 1) 如果封装格式名称匹配，score 增加 100。匹配中使用了函数 av_match_name()。 2) 如果 mime 类型匹配，score 增加 10。匹配直接使用字符串比较函数 strcmp()。 3) 如果文件名称的后缀匹配，score 增加 5。匹配中使用了函数 av_match_ext()。 while() 循环结束后，得到得分最高的格式，就是最匹配的格式。 下面看一下一个 AVOutputFormat 的实例，就可以理解 “封装格式名称”，“mine类型”，“文件名称后缀” 这些概念了。下面是 flv 格式的视音频复用器（Muxer）对应的 AVOutputFormat 格式的变量 ff_flv_muxer。 代码： 1234567891011121314151617AVOutputFormat ff_flv_muxer = &#123; .name = "flv", .long_name = NULL_IF_CONFIG_SMALL("FLV (Flash Video)"), .mime_type = "video/x-flv", .extensions = "flv", .priv_data_size = sizeof(FLVContext), .audio_codec = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF, .video_codec = AV_CODEC_ID_FLV1, .write_header = flv_write_header, .write_packet = flv_write_packet, .write_trailer = flv_write_trailer, .codec_tag = (const AVCodecTag* const []) &#123; flv_video_codec_ids, flv_audio_codec_ids, 0 &#125;, .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS | AVFMT_TS_NONSTRICT,&#125;; avformat_write_header()FFmpeg 的写文件用到的 3 个函数： avformat_write_header() av_write_frame() av_write_trailer() 其中 av_write_frame() 用于写视频数据，avformat_write_header() 用于写视频文件头，而 av_write_trailer() 用于写视频文件尾。 本文首先分析avformat_write_header()。 PS：需要注意的是，尽管这 3 个函数功能是配套的，但是它们的前缀却不一样，写文件头 Header 的函数前缀是“avformat_”，其他两个函数前缀是“av_”（不太明白其中的原因）。 avformat_write_header() 的声明位于 libavformat\avformat.h 1int avformat_write_header(AVFormatContext *s, AVDictionary **options); 简单解释一下它的参数的含义： 12s：用于输出的AVFormatContext。options：额外的选项，目前没有深入研究过，一般为NULL。 函数正常执行后返回值等于 0。 avformat_write_header() 的调用关系如下图所示： avformat_write_header() 的定义位于 libavformat\mux.c 从源代码可以看出，avformat_write_header() 完成了以下工作： （1）调用 init_muxer() 初始化复用器 （2）调用 AVOutputFormat 的 write_header() init_muxer() 代码很长，但是它所做的工作比较简单，可以概括成两个字：检查。函数的流程可以概括成以下几步： （1）将传入的 AVDictionary 形式的选项设置到 AVFormatContext （2）遍历 AVFormatContext 中的每个 AVStream，并作如下检查： a) AVStream 的 time_base 是否正确设置。如果发现 AVStream 的 time_base 没有设置，则会调用 avpriv_set_pts_info() 进行设置。 b) 对于音频，检查采样率设置是否正确；对于视频，检查宽、高、宽高比。 c) 其他一些检查，不再详述。 AVOutputFormat-&gt;write_header() avformat_write_header() 中最关键的地方就是调用了 AVOutputFormat 的 write_header()。 write_header() 是 AVOutputFormat 中的一个函数指针，指向写文件头的函数。不同的AVOutputFormat 有不同的 write_header() 的实现方法。在这里我们举例子看一下 FLV 封装格式对应的 AVOutputFormat，它的定义位于 libavformat\flvenc.c 从 ff_flv_muxer 的定义中可以看出，write_header() 指向的函数为 flv_write_header()。我们继续看一下 flv_write_header() 函数。flv_write_header() 的定义同样位于 libavformat\flvenc.c 从源代码可以看出，flv_write_header() 完成了FLV文件头的写入工作。该函数的工作可以大体分为以下两部分： （1）给 FLVContext 设置参数 （2）写文件头，以及相关的 Tag 可以参考下图中 FLV 文件头的定义比对一下上面的代码。 avcodec_encode_video()该函数用于编码一帧视频数据。avcodec_encode_video2() 函数的声明位于 libavcodec\avcodec.h 12int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr); 该函数每个参数的含义在注释里面已经写的很清楚了，在这里用中文简述一下： 1234avctx：编码器的AVCodecContext。avpkt：编码输出的AVPacket。frame：编码输入的AVFrame。got_packet_ptr：成功编码一个AVPacket的时候设置为1。 函数返回0代表编码成功。 函数的调用关系如下图所示： avcodec_encode_video2() 的定义位于 libavcodec\utils.c 从函数的定义可以看出，avcodec_encode_video2() 首先调用了 av_image_check_size() 检查设置的宽高参数是否合理，然后调用了 AVCodec 的 encode2() 调用具体的解码器。 av_image_check_size() 主要是要求图像宽高必须为正数，而且取值不能太大。 AVCodec 的 encode2() 是一个函数指针，指向特定编码器的编码函数 从 ff_libx264_encoder 的定义可以看出，encode2() 函数指向的是 X264_frame() 函数。 X264_frame() 函数的定义位于 libavcodec\libx264.c av_write_frame()av_write_frame() 用于输出一帧视音频数据，它的声明位于 libavformat\avformat.h 1int av_write_frame(AVFormatContext *s, AVPacket *pkt); 简单解释一下它的参数的含义： 12s：用于输出的AVFormatContext。pkt：等待输出的AVPacket。 函数正常执行后返回值等于 0。 av_write_frame() 的调用关系如下图所示： av_write_frame() 的定义位于 libavformat\mux.c 从源代码可以看出，av_write_frame() 主要完成了以下几步工作： （1）调用 check_packet() 做一些简单的检测 （2）调用 compute_pkt_fields2() 设置 AVPacket 的一些属性值 （3）调用 write_packet() 写入数据 check_packet() 的功能比较简单：首先检查一下输入的 AVPacket 是否为空，如果为空，则是直接返回；然后检查一下 AVPacket 的 stream_index（标记了该 AVPacket 所属的 AVStream）设置是否正常，如果为负数或者大于 AVStream 的个数，则返回错误信息；最后检查 AVPacket 所属的 AVStream 是否属于 attachment stream，这个地方没见过，目前还没有研究。 compute_pkt_fields2() 函数的定义位于 libavformat\mux.c compute_pkt_fields2() 主要有两方面的功能： 一方面用于计算 AVPacket 的 duration， dts 等信息； 另一方面用于检查 pts、dts 这些参数的合理性（例如 PTS 是否一定大于 DTS）。具体的代码还没有细看，以后有时间再进行分析。 write_packet() 函数的定义位于 libavformat\mux.c write_packet() 函数最关键的地方就是调用了 AVOutputFormat 中写入数据的方法。如果 AVPacket 中的 flag 标记中包含 AV_PKT_FLAG_UNCODED_FRAME，就会调用 AVOutputFormat 的 write_uncoded_frame() 函数；如果不包含那个标记，就会调用 write_packet() 函数。 write_packet() 实际上是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。例如，我们看一下 FLV 对应的 AVOutputFormat，位于 libavformat\flvenc.c 从 ff_flv_muxer 的定义可以看出，write_packet() 指向的是 flv_write_packet() 函数。在看 flv_write_packet() 函数的定义之前，先回顾一下 FLV 封装格式的结构。 av_write_trailer()av_write_trailer() 用于输出文件尾，它的声明位于 libavformat\avformat.h 1int av_write_trailer(AVFormatContext *s); 它只需要指定一个参数，即用于输出的 AVFormatContext。 函数正常执行后返回值等于 0。 av_write_trailer() 的调用关系如下图所示： av_write_trailer() 的定义位于 libavformat\mux.c 从源代码可以看出 av_write_trailer() 主要完成了以下两步工作： （1）循环调用 interleave_packet() 以及 write_packet()，将还未输出的 AVPacket 输出出来。 （2）调用 AVOutputFormat 的 write_trailer()，输出文件尾。 其中第一步和 av_write_frame() 中的步骤大致是一样的（interleave_packet() 这一部分在并不包含在 av_write_frame() 中，而是包含在 av_interleaved_write_frame() 中，这一部分源代码还没有分析） AVOutputFormat 的 write_trailer() 是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。我们以 FLV 对应的 AVOutputFormat 为例，看一下它的定义 从 FLV 对应的 AVOutputFormat 结构体的定义我们可以看出，write_trailer() 指向了flv_write_trailer() 函数。 flv_write_trailer() 函数的定义位于 libavformat\flvenc.c 从 flv_write_trailer() 的源代码可以看出该函数做了以下两步工作： （1）如果视频流是 H.264，则添加包含 EOS（End Of Stream） NALU 的 Tag。 （2）更新 FLV 的时长信息，以及文件大小信息。 其中，put_avc_eos_tag() 函数用于添加包含 EOS NALU 的 Tag（包含结尾的一个PreviousTagSize） 可以参考 FLV 封装格式理解上述函数。由于前面的文章中已经描述过 FLV 封装格式，在这里不再重复叙述，在这里仅在此记录一下 AVCVIDEOPACKET 的格式，如下所示。 可以看出包含 EOS NALU 的 AVCVIDEOPACKET 的 AVCPacketType 为 2。在这种情况下， AVCVIDEOPACKET 的 CompositionTime 字段取 0，并且无需包含 Data 字段。 日志输出系统 日志输出系统 av_log()本文分析一下 FFmpeg 的日志（Log）输出系统的源代码。日志输出部分的核心函数只有一个： av_log()。使用 av_log() 在控制台输出日志的效果如下图所示。 FFmpeg 日志输出系统的函数调用结构图如图所示： av_log() 是 FFmpeg 中输出日志的函数。随便打开一个 FFmpeg 的源代码文件，就会发现其中遍布着 av_log() 函数。一般情况下 FFmpeg 类库的源代码中是不允许使用 printf() 这种的函数的，所有的输出一律使用 av_log()。 av_log()的声明位于libavutil\log.h 1void av_log(void *avcl, int level, const char *fmt, ...) av_printf_format(3, 4); 这个函数的声明有两个地方比较特殊： （1）函数最后一个参数是 “…”。 在 C 语言中，在函数参数数量不确定的情况下使用 “…” 来代表参数。例如 printf() 的原型定义如下 1int printf (const char*, ...); （2）它的声明后面有一个 av_printf_format(3, 4)。有关这个地方的左右还没有深入研究，网上资料中说它的作用是按照 printf() 的格式检查 av_log() 的格式。 av_log()每个字段的含义如下： avcl：指定一个包含 AVClass 的结构体。 level：log 的级别 fmt：和 printf() 一样。 由此可见，av_log() 和 printf() 的不同主要在于前面多了两个参数。其中第一个参数指定该 log 所属的结构体，例如 AVFormatContext、AVCodecContext 等等。第二个参数指定 log 的级别，源代码中定义了如下几个级别。 12345678#define AV_LOG_QUIET -8#define AV_LOG_PANIC 0#define AV_LOG_FATAL 8#define AV_LOG_ERROR 16#define AV_LOG_WARNING 24#define AV_LOG_INFO 32#define AV_LOG_VERBOSE 40#define AV_LOG_DEBUG 48 从定义中可以看出来，随着严重程度逐渐下降，一共包含如下级别： AV_LOG_PANIC， AV_LOG_FATAL， AV_LOG_ERROR， AV_LOG_WARNING， AV_LOG_INFO， AV_LOG_VERBOSE， AV_LOG_DEBUG。 每个级别定义的数值代表了严重程度，数值越小代表越严重。默认的级别是 AV_LOG_INFO。此外，还有一个级别不输出任何信息，即 AV_LOG_QUIET。 当前系统存在着一个 “Log级别”。所有严重程度高于该级别的 Log 信息都会输出出来。例如当前的 Log 级别是 AV_LOG_WARNING，则会输出 AV_LOG_PANIC，AV_LOG_FATAL，AV_LOG_ERROR，AV_LOG_WARNING 级别的信息，而不会输出 AV_LOG_INFO 级别的信息。可以通过 av_log_get_level() 获得当前 Log 的级别，通过另一个函数 av_log_set_level() 设置当前的 Log 级别。 可以通过 av_log_set_level() 设置当前 Log 的级别。 接头体成员管理系统AVClass FFmpeg源代码简单分析：结构体成员管理系统-AVClass TODO AVOption FFmpeg源代码简单分析：结构体成员管理系统-AVOption TODO libswscalesws_getContext() FFmpeg源代码简单分析：libswscale的sws_getContext() TODO sws_scale() FFmpeg源代码简单分析：libswscale的sws_scale() TODO libavdeviceavdevice_register_all() FFmpeg源代码简单分析：libavdevice的avdevice_register_all() gdigrab FFmpeg源代码简单分析：libavdevice的gdigrab]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg 源代码结构（编解码解析）]]></title>
    <url>%2F2019%2F05%2F25%2FFFmpeg%2FFFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84note%2F</url>
    <content type="text"><![CDATA[特别说明，此文参考至雷神笔记，做一个备忘录。 FFmpeg源代码结构图 - 解码下图表明了 FFmpeg 在解码一个视频的时候的函数调用流程。为了保证结构清晰，其中仅列出了最关键的函数，剔除了其它不是特别重要的函数。 下面解释一下图中关键标记的含义。 函数背景色函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用： 粉红色背景函数：FFmpeg 的 API函数。 白色背景的函数：FFmpeg 的内部函数。 黄色背景的函数：URLProtocol 结构体中的函数，包含处理协议（Protocol）的功能。 绿色背景的函数：AVInputFormat 结构体中的函数，包含处理封装格式（Format）的功能。 蓝色背景的函数：AVCodec 结构体中的函数，包含了编解码器（Codec）的功能。 PS：URLProtocol，AVInputFormat，AVCodec在FFmpeg开始运行并且注册完组件之后，都会分别被连接成一个个的链表。因此实际上是有很多的URLProtocol，AVInputFormat，AVCodec的。图中画出了解码一个输入协议是“文件”（其实就是打开一个文件。“文件”也被当做是一种广义的协议），封装格式为FLV，视频编码格式是H.264的数据的函数调用关系。 区域整个架构图可以分为以下几个区域： 左边区域——架构函数区域：这些函数并不针对某一特定的视频格式。 右上方黄色区域——协议处理函数区域：不同的协议（RTP，RTMP，FILE）会调用不同的协议处理函数。 右边中间绿色区域——封装格式处理函数区域：不同的封装格式（MKV，FLV，MPEGTS，AVI）会调用不同的封装格式处理函数。 右边下方蓝色区域——编解码函数区域：不同的编码标准（HEVC，H.264，MPEG2）会调用不同的编解码函数。 箭头线为了把调用关系表示的更明显，图中的箭头线也使用了不同的颜色： 黑色箭头线：标志了函数之间的调用关系。 红色的箭头线：标志了解码的流程。 其他颜色的箭头线：标志了函数之间的调用关系。其中： 调用 URLProtocol 结构体中的函数用黄色箭头线标识； 调用 AVInputFormat 结构体中的函数用绿色箭头线标识； 调用 AVCodec 结构体中的函数用蓝色箭头线标识。 函数所在的文件每个函数旁边标识了它所在的文件的路径。 此外，还有一点需要注意的是，一些 API 函数内部也调用了另一些API函数。也就是说，API函数并不一定全部都调用FFmpeg的内部函数，他也有可能调用其他的API函数。例如从图中可以看出来， avformat_close_input() 调用了 avformat_free_context() 和 avio_close()。这些在内部代码中被调用的API函数也标记为粉红色。 函数调用关系下面简单列出几个区域中函数之间的调用关系（函数之间的调用关系使用缩进的方式表现出来）。详细的函数分析可以参考相关的《FFmpeg源代码分析》系列文章。 左边区域（FFmpeg架构函数）1. av_register_all()【函数简单分析】&gt; 1) avcodec_register_all() (a) REGISTER_HWACCEL() (b) REGISTER_ENCODER() (c) REGISTER_DECODER() (d) REGISTER_PARSER() (e) REGISTER_BSF() 2) REGISTER_MUXER() 3) REGISTER_DEMUXER() 4) REGISTER_PROTOCOL() 2. avformat_alloc_context()【函数简单分析】 1) av_malloc(sizeof(AVFormatContext)) 2) avformat_get_context_defaults() (a) av_opt_set_defaults() 3. avformat_open_input()【函数简单分析】 1) init_input() (a) avio_open2()【函数简单分析】 a) ffurl_open() i. ffurl_alloc() url_find_protocol() url_alloc_for_protocol() ii. ffurl_connect() URLProtocol-&gt;url_open() b) ffio_fdopen() i. av_malloc(buffer_size) ii. avio_alloc_context() av_mallocz(sizeof(AVIOContext)) ffio_init_context() (b) av_probe_input_buffer2() a) avio_read() i. AVInputFormat-&gt;read_packet() b) av_probe_input_format2() c) av_probe_input_format3() i. av_iformat_next() ii. av_match_name() iii. av_match_ext() iv. AVInputFormat-&gt;read_probe() 2) AVInputFormat-&gt;read_header() 4. avformat_find_stream_info()【函数简单分析】 1) find_decoder() (a) avcodec_find_decoder() 2) avcodec_open2() 3) read_frame_internal() 4) try_decode_frame() (a) avcodec_decode_video2() 5) avcodec_close() 6) estimate_timings() (a) estimate_timings_from_pts() (b) estimate_timings_from_bit_rate() (c) update_stream_timings() 5. avcodec_find_decoder()【函数简单分析】 1) find_encdec() 6. avcodec_open2()【函数简单分析】 1) AVCodec-&gt;init() 7. av_read_frame()【函数简单分析】 1) read_from_packet_buffer() 2) read_frame_internal() (a) ff_read_packet() a) AVInputFormat-&gt;read_packet() (b) parse_packet() a) av_parser_parse2() 8. avcodec_decode_video2()【函数简单分析】 1) av_packet_split_side_data() 2) AVCodec-&gt; decode() 3) av_frame_set_pkt_pos() 4) av_frame_set_best_effort_timestamp() 9. avcodec_close()【函数简单分析】 1) AVCodec-&gt;close() 10. avformat_close_input()【函数简单分析】 1) AVInputFormat-&gt;read_close() 2) avformat_free_context() (a) ff_free_stream() 3) avio_close() (a) avio_flush() a) flush_buffer() (b) ffurl_close() a) ffurl_closep() URLProtocol-&gt;url_close() 右上区域（URLProtocol协议处理函数）URLProtocol结构体包含如下协议处理函数指针： url_open()：打开 url_read()：读取 url_write()：写入 url_seek()：调整进度 url_close()：关闭 【例子】不同的协议对应着上述接口有不同的实现函数，举几个例子： File协议（即文件）对应的URLProtocol结构体 ff_file_protocol： 12345url_open() -&gt; file_open() -&gt; open()url_read() -&gt; file_read() -&gt; read()url_write() -&gt; file_write() -&gt; write()url_seek() -&gt; file_seek() -&gt; lseek()url_close() -&gt; file_close() -&gt; close() RTMP协议（libRTMP）对应的URLProtocol结构体 ff_librtmp_protocol： 12345url_open() -&gt; rtmp_open() -&gt; RTMP_Init(), RTMP_SetupURL(), RTMP_Connect(), RTMP_ConnectStream()url_read() -&gt; rtmp_read() -&gt; RTMP_Read()url_write() -&gt; rtmp_write() -&gt; RTMP_Write()url_seek() -&gt; rtmp_read_seek() -&gt; RTMP_SendSeek()url_close() -&gt; rtmp_close() -&gt; RTMP_Close() UDP协议对应的URLProtocol结构体 ff_udp_protocol： 12345url_open() -&gt; udp_open()url_read() -&gt; udp_read()url_write() -&gt; udp_write()url_seek() -&gt; udp_close()url_close() -&gt; udp_close() 右中区域（AVInputFormat封装格式处理函数）AVInputFormat包含如下封装格式处理函数指针： read_probe()：检查格式 read_header()：读取文件头 read_packet()：读取一帧数据 read_seek()：调整进度 read_close()：关闭 【例子】不同的封装格式对应着上述接口有不同的实现函数，举几个例子： FLV封装格式对应的AVInputFormat结构体 ff_flv_demuxer： 12345read_probe() -&gt; flv_probe() –&gt; probe()read_header() -&gt; flv_read_header() -&gt; create_stream() -&gt; avformat_new_stream()read_packet() -&gt; flv_read_packet()read_seek() -&gt; flv_read_seek()read_close() -&gt; flv_read_close() MKV封装格式对应的AVInputFormat结构体 ff_matroska_demuxer： 12345read_probe() -&gt; matroska_probe()read_header() -&gt; matroska_read_header()read_packet() -&gt; matroska_read_packet()read_seek() -&gt; matroska_read_seek()read_close() -&gt; matroska_read_close() MPEG2TS封装格式对应的AVInputFormat结构体 ff_mpegts_demuxer： 1234read_probe() -&gt; mpegts_probe()read_header() -&gt; mpegts_read_header()read_packet() -&gt; mpegts_read_packet() read_close() -&gt; mpegts_read_close() AVI封装格式对应的AVInputFormat结构体 ff_avi_demuxer： 12345read_probe() -&gt; avi_probe()read_header() -&gt; avi_read_header()read_packet() -&gt; avi_read_packet()read_seek() -&gt; avi_read_seek()read_close() -&gt; avi_read_close() 右下区域（AVCodec编解码函数）AVCodec包含如下编解码函数指针： init()：初始化 decode()：解码一帧数据 close()：关闭 【例子】不同的编解码器对应着上述接口有不同的实现函数，举几个例子： HEVC解码对应的AVCodec结构体 ff_hevc_decoder： 123init() -&gt; hevc_decode_init()decode() -&gt; hevc_decode_frame() -&gt; decode_nal_units()close() -&gt; hevc_decode_free() H.264解码对应的AVCodec结构体 ff_h264_decoder： 123init() -&gt; ff_h264_decode_init()decode() -&gt; h264_decode_frame() -&gt; decode_nal_units()close() -&gt; h264_decode_end() VP8解码（libVPX）对应的AVCodec结构体 ff_libvpx_vp8_decoder： 123init() -&gt; vpx_init() -&gt; vpx_codec_dec_init()decode() -&gt; vp8_decode() -&gt; vpx_codec_decode(), vpx_codec_get_frame()close() -&gt; vp8_free() -&gt; vpx_codec_destroy() MPEG2解码对应的AVCodec结构体 ff_mpeg2video_decoder： 123init() -&gt; mpeg_decode_init()decode() -&gt; mpeg_decode_frame()close() -&gt; mpeg_decode_end() avformat_open_input() 函数 FFmpeg源代码结构图 - 编码函数调用关系图下图表明了FFmpeg在编码一个视频的时候的函数调用流程。为了保证结构清晰，其中仅列出了最关键的函数，剔除了其它不是特别重要的函数。 下面解释一下图中关键标记的含义。 函数背景色函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用： 粉红色背景函数：FFmpeg 的 API 函数。 白色背景的函数：FFmpeg 的内部函数。 黄色背景的函数：URLProtocol 结构体中的函数，包含了读写各种协议的功能。 绿色背景的函数：AVOutputFormat 结构体中的函数，包含了读写各种封装格式的功能。 蓝色背景的函数：AVCodec 结构体中的函数，包含了编解码的功能。 区域整个关系图可以分为以下几个区域： 左边区域——架构函数区域：这些函数并不针对某一特定的视频格式。 右上方黄色区域——协议处理函数区域：不同的协议（RTP，RTMP，FILE）会调用不同的协议处理函数。 右边中间绿色区域——封装格式处理函数区域：不同的封装格式（MKV，FLV，MPEG2TS，AVI）会调用不同的封装格式处理函数。 右边下方蓝色区域——编解码函数区域：不同的编码标准（HEVC，H.264，MPEG2）会调用不同的编解码函数。 箭头线为了把调用关系表示的更明显，图中的箭头线也使用了不同的颜色： 红色的箭头线：标志了编码的流程。 其他颜色的箭头线：标志了函数之间的调用关系。其中： 调用 URLProtocol 结构体中的函数用黄色箭头线标识； 调用 AVOutputFormat 结构体中的函数用绿色箭头线标识； 调用 AVCodec 结构体中的函数用蓝色箭头线标识。 函数所在的文件每个函数标识了它所在的文件路径。 函数功能简述下面简单列出几个区域中函数之间的调用关系（函数之间的调用关系使用缩进的方式表现出来）。详细的函数分析可以参考相关的《FFmpeg源代码分析》系列文章。 左边区域（架构函数）1. av_register_all()【函数简单分析】 1) avcodec_register_all() (a) REGISTER_HWACCEL() (b) REGISTER_ENCODER() (c) REGISTER_DECODER() (d) REGISTER_PARSER() (e) REGISTER_BSF() 2) REGISTER_MUXER() 3) REGISTER_DEMUXER() 4) REGISTER_PROTOCOL() 2. avformat_alloc_output_context2()【函数简单分析】 1) avformat_alloc_context() (a) av_malloc(sizeof(AVFormatContext)) (b) avformat_get_context_defaults() a) av_opt_set_defaults() 2) av_guess_format() (a) av_oformat_next() (b) av_match_name() (c) av_match_ext() 3. avio_open2()【函数简单分析】 1) ffurl_open() (a) ffurl_alloc() a) url_find_protocol() b) url_alloc_for_protocol() (b) ffurl_connect() a) URLProtocol-&gt;url_open() 2) ffio_fdopen() (a) av_malloc(buffer_size) (b) avio_alloc_context() a) av_mallocz(sizeof(AVIOContext)) b) ffio_init_context() 4. avformat_new_stream()【函数简单分析】 1) av_mallocz(sizeof(AVStream)) 2) avcodec_alloc_context3() (a) av_malloc(sizeof(AVCodecContext)) (b) avcodec_get_context_defaults3() 5. avcodec_find_encoder()【函数简单分析】 1) find_encdec() 6. avcodec_open2()【函数简单分析】 1) AVCodec-&gt;init() 7. avformat_write_header()【函数简单分析】 1) init_muxer() 2) AVOutputFormat-&gt;write_header() 3) init_pts() 8. avcodec_encode_video2()【函数简单分析】 1) AVCodec-&gt;encode2() 9. av_write_frame()【函数简单分析】 1) check_packet() 2) compute_pkt_fields2() 3) write_packet() (a) AVOutputFormat-&gt;write_packet() 10. av_write_trailer()【函数简单分析】 1) write_packet() 2) AVOutputFormat-&gt;write_trailer() 11. avcodec_close()【函数简单分析】 1) AVCodec-&gt;close() 12. avformat_free_context()【函数简单分析】 1) ff_free_stream() 13. avio_close()【函数简单分析】 1) avio_flush() (a) flush_buffer() 2) ffurl_close() (a) ffurl_closep() a) URLProtocol-&gt;url_close() 右上区域（URLProtocol协议处理函数）URLProtocol结构体包含如下协议处理函数指针： url_open()：打开 url_read()：读取 url_write()：写入 url_seek()：调整进度 url_close()：关闭 【例子】不同的协议对应着上述接口有不同的实现函数，举几个例子： File协议（即文件）对应的URLProtocol结构体 ff_file_protocol： 12345url_open() -&gt; file_open() -&gt; open()url_read() -&gt; file_read() -&gt; read()url_write() -&gt; file_write() -&gt; write()url_seek() -&gt; file_seek() -&gt; lseek()url_close() -&gt; file_close() -&gt; close() RTMP协议（libRTMP）对应的URLProtocol结构体 ff_librtmp_protocol： 12345url_open() -&gt; rtmp_open() -&gt; RTMP_Init(), RTMP_SetupURL(), RTMP_Connect(), RTMP_ConnectStream()url_read() -&gt; rtmp_read() -&gt; RTMP_Read()url_write() -&gt; rtmp_write() -&gt; RTMP_Write()url_seek() -&gt; rtmp_read_seek() -&gt; RTMP_SendSeek()url_close() -&gt; rtmp_close() -&gt; RTMP_Close() UDP协议对应的URLProtocol结构体 ff_udp_protocol： 12345url_open() -&gt; udp_open()url_read() -&gt; udp_read()url_write() -&gt; udp_write()url_seek() -&gt; udp_close()url_close() -&gt; udp_close() 右中区域（AVOutputFormat封装格式处理函数）AVOutputFormat包含如下封装格式处理函数指针： write_header()：写文件头 write_packet()：写一帧数据 write_trailer()：写文件尾 【例子】不同的封装格式对应着上述接口有不同的实现函数，举几个例子： FLV封装格式对应的AVOutputFormat结构体 ff_flv_muxer： 123write_header() -&gt; flv_write_header()write_packet() –&gt; flv_write_packet()write_trailer() -&gt; flv_write_trailer() MKV封装格式对应的AVOutputFormat结构体 ff_matroska_muxer： 123write_header() -&gt; mkv_write_header()write_packet() –&gt; mkv_write_flush_packet()write_trailer() -&gt; mkv_write_trailer() MPEG2TS封装格式对应的AVOutputFormat结构体 ff_mpegts_muxer： 123write_header() -&gt; mpegts_write_header()write_packet() –&gt; mpegts_write_packet()write_trailer() -&gt; mpegts_write_end() AVI封装格式对应的AVOutputFormat结构体 ff_avi_muxer： 123write_header() -&gt; avi_write_header()write_packet() –&gt; avi_write_packet()write_trailer() -&gt; avi_write_trailer() 右下区域（AVCodec编解码函数）AVCodec包含如下编解码函数指针： init()：初始化 encode2()：编码一帧数据 close()：关闭 【例子】不同的编解码器对应着上述接口有不同的实现函数，举几个例子： HEVC编码器对应的AVCodec结构体 ff_libx265_encoder： 123init() -&gt; libx265_encode_init() -&gt; x265_param_alloc(), x265_param_default_preset(), x265_encoder_open()encode2() -&gt; libx265_encode_frame() -&gt; x265_encoder_encode()close() -&gt; libx265_encode_close() -&gt; x265_param_free(), x265_encoder_close() H.264编码器对应的AVCodec结构体 ff_libx264_encoder： 123init() -&gt; X264_init() -&gt; x264_param_default(), x264_encoder_open(), x264_encoder_headers()encode2() -&gt; X264_frame() -&gt; x264_encoder_encode()close() -&gt; X264_close() -&gt; x264_encoder_close() VP8编码器（libVPX）对应的AVCodec结构体 ff_libvpx_vp8_encoder： 123init() -&gt; vpx_init() -&gt; vpx_codec_enc_config_default()encode2() -&gt; vp8_encode() -&gt; vpx_codec_enc_init(), vpx_codec_encode()close() -&gt; vp8_free() -&gt; vpx_codec_destroy() MPEG2编码器对应的AVCodec结构体 ff_mpeg2video_encoder： 123init() -&gt; encode_init()encode2() -&gt; ff_mpv_encode_picture()close() -&gt; ff_mpv_encode_end()]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFMpeg实时美颜直播推流]]></title>
    <url>%2F2019%2F05%2F19%2FFFmpeg%2Fffmpeg%E5%AE%9E%E6%97%B6%E7%BE%8E%E9%A2%9C%E6%8E%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[基于FFmpeg进行RTMP推流（二） 实战 - 基于ffmpeg，qt5，opencv视频课程 1. 基础知识1.1 直播推流流程分析 rtmp 延时一般 1-3 秒 1.2 直播 rtmp 协议分析 2. 直播服务器讲解和配置 2.1 直播服务器介绍 crtmpserver 编译运行1234567891011121314$ apt-get install wget cmake$ apt-get install libssl-dev$ wget https://codeload.github.com/j0sh/crtmpserver/zip/centosinit --no-check-certificate$ unzip centosinit$ cd builders/cmake$ cmake . $ make$ ./crtmpserver/crtmpserver ./crtmpserver/crtmpserver.lua#$ ffmpeg -i test.flv -f flv rtmp://192.168.1.44/live#ʹc rtmp://192.168.1.44/live#ʹplay ffplay rtmp://192.168.1.44/live -fflags nobuffer 123456# errorCMake Error at cmake_find_modules/Find_openssl.cmake:99 (MESSAGE): Looking for openssl headers - not foundCall Stack (most recent call first): CMakeLists.txt:46 (INCLUDE)$ cmake -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl -DOPENSSL_LIBRARIES=/usr/local/opt/openssl/lib 2.2 下载 ffmpeg 工具推流并使用功能 vlc 拉流播放测试12345$ wget https://nginx.org/download/nginx-1.16.0.tar.gz --no-check-certificate$ git clone https://github.com/arut/nginx-rtmp-module.git$ ./configure --add-module=/home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module $ make$ make install 12345678910# nginx.conf 配置rtmp &#123; server &#123; listen 1935; chunk_size 4096; application live &#123; live on; &#125; &#125;&#125; 12# 推流命令$ ffmpeg -i test.mp4 -c copy -f flv rtmp://192.168.2.76/live 1234567891011# 网页查看推流的状态server &#123; listen 8080; location /stat&#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl&#123; root /home/miaopei/workdir/test/ffmpet-test/nginx/nginx-rtmp-module; &#125;&#125; 12345678Reload config: $ nginx -s reloadReopen Logfile: $ nginx -s reopenStop process: $ nginx -s stopWaiting on exit process $ nginx -s quit 3. FFMpeg SDK 解封和推流3.1 ffmpeg SDK开发环境准备 4. OpencvSDK 基础 Mac源码安装使用OpenCV 在MacOS 10.13.2 下编译 OpenCV3.4.0 + OpenCV Contrib 3.4.0 成 Java 库 在MacOS上安装OpenCV 3.4(c++) OpenCV 源码编译： 12345678910111213141516171819202122232425262728# 下载 OpenCV 3.4.0$ # 解压，进入到 opencv-3.4.0 目录下$ mkdir -p build/install$ cd build$ cmake -G "Unix Makefiles" -j8 -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_OSX_ARCHITECTURES=x86_64 -D CMAKE_INSTALL_PREFIX=/Users/miaopei/install/opencv/opencv-3.4.0/build/install ../$ make -j8$ make install# 配置环境变量PKG_CONFIG_PATH=$PKG_CONFIG_PATH:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib/pkgconfigexport PKG_CONFIG_PATHexport LD_LIBRARY_PATH=Users/miaopei/install/opencv/opencv-3.4.0/build/install/bin:SLD_LIBRARY_PATHexport PATH=$&#123;PATH&#125;:Users/miaopei/install/opencv/opencv-3.4.0/build/install/lib# 测试demo,打印当前版本号#include &lt;opencv2/core/utility.hpp&gt;#include &lt;iostream&gt;int main(int argc, const char* argv[])&#123; std::cout &lt;&lt; "Welcome to OpenCV " &lt;&lt; CV_VERSION &lt;&lt; std::endl; return 0;&#125;# MakefileCXX ?= g++CXXFLAGS += -c -Wall $(shell pkg-config --cflags opencv)LDFLAGS += $(shell pkg-config --libs --static opencv)all: test_versionopencv_example: test_version.o; $(CXX) $&lt; -o $@ $(LDFLAGS)%.o: %.cpp; $(CXX) $&lt; -o $@ $(CXXFLAGS)clean: ; rm -f test_version.o test_version 4.1 VideoCapture打开摄像头接口讲解和源码分析 5. 视频采集编码推流和类封装 6. 音频录制编码推流和类封装 QT音频录制接口： 7. 音视频同步编码推流处理 8. XRtmpStreamer 项目完成（界面和美颜）直播推流要求实时性，一秒钟25帧，做美颜的总耗时一定要低于40ms（每帧消耗40ms） 现在视频推流一般都是1280 X 720 手机端是基于GPU 第三方库做的计算 美颜算法一般都是基于GPU做的 头文件尽量不用引用命名空间，因为不知道谁来调用，可能会出现问题。 头文件中尽量不要引用第三方库文件，应为涉及到第三方库版本升级之类的，第三方头文件的引用应该在代码中引用。 9. 补充9.0 流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）1. RTP： 参考文档 RFC3550/RFC3551 (Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输层协议。RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP协议），视频会议和一键通（Push to Talk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。RTP 协议和 RTP 控制协议 RTCP 一起使用，而且它是建立在 UDP 协议上的。 RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于低层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。 RTP 由两个紧密链接部分组成： RTP ― 传送具有实时属性的数据； RTP 控制协议（RTCP） ― 监控服务质量并传送正在进行的会话参与者的相关信息。 2. RTCP 实时传输控制协议（Real-time Transport Control Protocol 或 RTP Control Protocol 或简写 RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP 为 RTP 媒体流提供信道外（out-of-band）控制。RTCP 本身并不传输数据，但和 RTP 一起协作将多媒体数据打包和发送。RTCP 定期在流多媒体会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量（Quality of Service）提供反馈。 RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证。SRTCP 可以用于此类用途。 3. SRTP &amp; SRTCP 参考文档 RFC3711 安全实时传输协议（Secure Real-time Transport Protocol 或 SRTP）是在实时传输协议（Real-time Transport Protocol 或 RTP）基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004年3月作为 RFC3711 发布。 由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol 或 RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP 或 SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。 在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。 4. RTSP 参考文档 RFC2326 是由 Real Networks 和 Netscape 共同提出的。该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 提供了一个可扩展框架，使实时数据，如音频与视频的受控、点播成为可能。数据源包括现场数据与存储在剪辑中的数据。该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法。 RTSP（Real Time Streaming Protocol）是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用 TCP 或 UDP来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，但并不特别强调时间同步，所以比较能容忍网络延迟。而前面提到的允许同时多个串流需求控制（Multicast），除了可以降低服务器端的网络用量，更进而支持多方视讯会议（Video Conference）。 因为与 HTTP1.1 的运作方式相似，所以代理服务器《Proxy》的快取功能《Cache》也同样适用于 RTSP，并因 RTSP 具有重新导向功能，可视实际负载情况来转换提供服务的服务器，以避免过大的负载集中于同一服务器而造成延迟。 5. RTSP 和 RTP 的关系 RTP 不象 http 和 ftp 可完整的下载整个影视文件，它是以固定的数据率在网络上发送数据，客户端也是按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端要求数据。 RTSP 与 RTP 最大的区别在于：RTSP 是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。当然，RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性。它是一种类似与 http 协议的网络应用层协议。目前碰到的一个应用：服务器端实时采集、编码并发送两路视频，客户端接收并显示两路视频。由于客户端不必对视频数据做任何回放、倒退等操作，可直接采用 UDP + RTP + 组播实现。 RTP：实时传输协议（Real-time Transport Protocol） RTP/RTCP 是实际传输数据的协议 RTP 传输音频/视频数据，如果是 PLAY，Server 发送到 Client 端，如果是 RECORD，可以由Client 发送到 Server 整个 RTP 协议由两个密切相关的部分组成： RTP数据协议 RTP控制协议（即RTCP） RTSP：实时流协议（Real Time Streaming Protocol，RTSP） RTSP 的请求主要有 DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN, OPTIONS 等，顾名思义可以知道起对话和控制作用 RTSP 的对话过程中 SETUP 可以确定 RTP/RTCP 使用的端口，PLAY/PAUSE/TEARDOWN 可以开始或者停止 RTP 的发送，等等 RTCP： RTCP 包括 Sender Report 和 Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议 6. SDP 会话描述协议（SDP）为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。 会话目录用于协助多媒体会议的通告，并为会话参与者传送相关设置信息。SDP 即用于将这种信息传输到接收端。SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）。 SDP 的设计宗旨是通用性，它可以应用于大范围的网络环境和应用程序，而不仅仅局限于组播会话目录，但 SDP 不支持会话内容或媒体编码的协商。 在因特网组播骨干网（Mbone）中，会话目录工具被用于通告多媒体会议，并为参与者传送会议地址和参与者所需的会议特定工具信息，这由 SDP 完成。SDP 连接好会话后，传送足够的信息给会话参与者。SDP 信息发送利用了会话通知协议（SAP），它周期性地组播通知数据包到已知组播地址和端口处。这些信息是 UDP 数据包，其中包含 SAP 协议头和文本有效载荷（text payload）。这里文本有效载荷指的是 SDP 会话描述。此外信息也可以通过电子邮件或 WWW （World Wide Web） 进行发送。 SDP 文本信息包括： 会话名称和意图； 会话持续时间； 构成会话的媒体； 有关接收媒体的信息（地址等）。 协议结构 SDP 信息是文本信息，采用 UTF-8 编 码中的 ISO 10646 字符集。SDP 会话描述如下：（标注 * 符号的表示可选字段）： 123456789v = （协议版本）o = （所有者/创建者和会话标识符）s = （会话名称）i = * （会话信息）u = * （URI 描述）e = * （Email 地址）p = * （电话号码）c = * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）b = * （带宽信息） 一个或更多时间描述（如下所示）： 123z = * （时间区域调整）k = * （加密密钥）a = * （0 个或多个会话属性行） 0个或多个媒体描述（如下所示） 时间描述 12t = （会话活动时间）r = * （0或多次重复次数） 媒体描述 123456m = （媒体名称和传输地址）i = * （媒体标题）c = * （连接信息 — 如果包含在会话层则该字段可选）b = * （带宽信息）k = * （加密密钥）a = * （0 个或多个会话属性行） 7. RTMP/RTMPS RTMP(Real Time Messaging Protocol) 实时消息传送协议是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输 开发的开放协议。 它有三种变种： 1) 工作在 TCP 之上的明文协议，使用端口1935； 2) RTMPT 封装在 HTTP 请求之中，可穿越防火墙； 3) RTMPS 类似 RTMPT，但使用的是 HTTPS 连接； RTMP 协议(Real Time Messaging Protocol)是被 Flash 用于对象, 视频, 音频的传输. 这个协议建立在 TCP 协议或者轮询 HTTP 协议之上. RTMP 协议就像一个用来装数据包的容器, 这些数据既可以是 AMF 格式的数据,也可以是 FLV 中的视/音频数据. 一个单一的连接可以通过不同的通道传输多路网络流. 这些通道中的包都是按照固定大小的包传输的. 8. mms MMS (Microsoft Media Server Protocol)，中文“微软媒体服务器协议”，用来访问并流式接收 Windows Media 服务器中 .asf 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。MMS 是连接 Windows Media 单播服务的默认方法。若观众在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超级链接访问内容，则他们必须使用MMS 协议引用该流。MMS的预设埠（端口）是1755 当使用 MMS 协议连接到发布点时，使用协议翻转以获得最佳连接。“协议翻转”始于试图通过 MMSU 连接客户端。 MMSU 是 MMS 协议结合 UDP 数据传送。如果 MMSU 连接不成功，则服务器试图使用 MMST。MMST 是 MMS 协议结合 TCP 数据传送。 如果连接到编入索引的 .asf 文件，想要快进、后退、暂停、开始和停止流，则必须使用 MMS。不能用 UNC 路径快进或后退。若您从独立的 Windows Media Player 连接到发布点，则必须指定单播内容的 URL。若内容在主发布点点播发布，则 URL 由服务器名和 .asf 文件名组成。例如：mms://windows_media_server/sample.asf。其中 windows_media_server 是 Windows Media 服务器名，sample.asf 是您想要使之转化为流的 .asf 文件名。 若您有实时内容要通过广播单播发布，则该 URL 由服务器名和发布点别名组成。例如：mms://windows_media_server/LiveEvents。这里 windows_media_server 是 Windows Media 服务器名，而 LiveEvents 是发布点名 9. HLS HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在 iOS 系统，为 iOS 设备（如iPhone、iPad）提供音视频直播和点播方案。HLS 点播，基本上就是常见的分段 HTTP 点播，不同在于，它的分段非常小。 相对于常见的流媒体直播协议，例如 RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS 协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS 是以点播的技术方式来实现直播。由于数据通过 HTTP 协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过 HLS 的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。 根据以上的了解要实现 HTTP Live Streaming 直播，需要研究并实现以下技术关键点： 采集视频源和音频源的数据 对原始数据进行H264编码和AAC编码 视频和音频数据封装为MPEG-TS包 HLS分段生成策略及m3u8索引文件 HTTP传输协议 9.1 HLS，RTSP，RTMP的区别 HLS （ HTTP Live Streaming）苹果公司提出的流媒体协议，直接把流媒体切片成一段段，信息保存到m3u列表文件中，可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据，可以在不同速率的版本间自由切换，实现无缝播放；省去使用其他协议的烦恼。缺点是延迟大小受切片大小影响，不适合直播，适合视频点播。 RTSP （Real-Time Stream Protocol）由Real Networks 和 Netscape共同提出的，基于文本的多媒体播放控制协议。RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。 RTMP（Real Time Message Protocol） 有 Adobe 公司提出，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题，优势在于低延迟，稳定性高，支持所有摄像头格式，浏览器加载 flash插件就可以直接播放。 总结：HLS 延迟大，适合视频点播；RTSP虽然实时性最好，但是实现复杂，适合视频聊天和视频监控；RTMP强在浏览器支持好，加载flash插件后就能直接播放，所以非常火，相反在浏览器里播放rtsp就很困难了。 9.2 RTSP、RTCP、RTP区别1：RTSP实时流协议 作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示 协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂 停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。 2：RTCP控制协议 RTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并 不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的 所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进 行控制或者对网络状况进行诊断。 RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型： SR：发送端报告，所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。(SERVER定时间发送给CLIENT)。 RR：接收端报告，所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。(SERVER接收CLIENT端发送过来的响应)。 SDES：源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。 BYE：通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。 APP：由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。 3：RTP数据协议 RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。 RTP用到的地方就是 PLAY ，服务器往客户端传输数据用UDP协议，RTP是在传输数据的前面加了个12字节的头(描述信息)。 RTP载荷封装设计本文的网络传输是基于IP协议，所以最大传输单元(MTU)最大为1500字节，在使用IP／UDP／RTP的协议层次结构的时候，这 其中包括至少20字节的IP头，8字节的UDP头，以及12字节的RTP头。这样，头信息至少要占用40个字节，那么RTP载荷的最大尺寸为1460字 节。以H264 为例，如果一帧数据大于1460，则需要分片打包，然后到接收端再拆包，组合成一帧数据，进行解码播放。 9.3 RTSP、 RTMP、HTTP的共同点、区别共同点： RTSP RTMP HTTP都是在应用应用层。 理论上RTSP RTMPHTTP都可以做直播和点播，但一般做直播用RTSP RTMP，做点播用HTTP。做视频会议的时候原来用SIP协议，现在基本上被RTMP协议取代了。 区别： HTTP: 即超文本传送协议(ftp即文件传输协议)。 HTTP:（Real Time Streaming Protocol），实时流传输协议。 HTTP全称Routing Table Maintenance Protocol（路由选择表维护协议）。 HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。 RTMP 和 RTSP协议是流媒体协议。 RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。 RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts,mp4格式的流。HTTP没有特定的流。 RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。 10. 代码FFmpeg SDK解封和推流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;iostream&gt;using namespace std;//引入头文件extern "C"&#123; #include "libavformat/avformat.h" //引入时间 #include "libavutil/time.h"&#125;//引入库#pragma comment(lib,"avformat.lib")//工具库，包括获取错误信息等#pragma comment(lib,"avutil.lib")//编解码的库#pragma comment(lib,"avcodec.lib")int avError(int errNum);static double r2d(AVRational r)&#123; return r.num == 0 || r.den == 0 ? 0. : (double)r.num / (double)r.den;&#125;int main() &#123; int videoindex = -1; //所有代码执行之前要调用av_register_all和avformat_network_init //初始化所有的封装和解封装 flv mp4 mp3 mov。不包含编码和解码 av_register_all(); //初始化网络库 avformat_network_init(); //使用的相对路径，执行文件在bin目录下。test.mp4放到bin目录下即可 const char *inUrl = "hs.mp4"; //输出的地址 const char *outUrl = "rtmp://192.166.11.13/live"; ////////////////////////////////////////////////////////////////// // 输入流处理部分 ///////////////////////////////////////////////////////////////// //打开文件，解封装 avformat_open_input //AVFormatContext **ps 输入封装的上下文。包含所有的格式内容和所有的IO。如果是文件就是文件IO，网络就对应网络IO //const char *url 路径 //AVInputFormt * fmt 封装器 //AVDictionary ** options 参数设置 AVFormatContext *ictx = NULL; AVOutputFormat *ofmt = NULL; //打开文件，解封文件头 int ret = avformat_open_input(&amp;ictx, inUrl, 0, NULL); if (ret &lt; 0) &#123; return avError(ret); &#125; cout &lt;&lt; "avformat_open_input success!" &lt;&lt; endl; //获取音频视频的信息 .h264 flv 没有头信息 ret = avformat_find_stream_info(ictx, 0); if (ret != 0) &#123; return avError(ret); &#125; //打印视频视频信息 //0打印所有 inUrl 打印时候显示， av_dump_format(ictx, 0, inUrl, 0); ////////////////////////////////////////////////////////////////// // 输出流处理部分 ///////////////////////////////////////////////////////////////// AVFormatContext * octx = NULL; //如果是输入文件 flv可以不传，可以从文件中判断。如果是流则必须传 //创建输出上下文 ret = avformat_alloc_output_context2(&amp;octx, NULL, "flv", outUrl); if (ret &lt; 0) &#123; return avError(ret); &#125; cout &lt;&lt; "avformat_alloc_output_context2 success!" &lt;&lt; endl; ofmt = octx-&gt;oformat; cout &lt;&lt; "nb_streams " &lt;&lt; ictx-&gt;nb_streams &lt;&lt; endl; int i; for (i = 0; i &lt; ictx-&gt;nb_streams; i++) &#123; //获取输入视频流 AVStream *in_stream = ictx-&gt;streams[i]; //为输出上下文添加音视频流（初始化一个音视频流容器） AVStream *out_stream = avformat_new_stream(octx, in_stream-&gt;codec-&gt;codec); if (!out_stream) &#123; printf("未能成功添加音视频流\n"); ret = AVERROR_UNKNOWN; &#125; //将输入编解码器上下文信息 copy 给输出编解码器上下文 //ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec); ret = avcodec_parameters_copy(out_stream-&gt;codecpar, in_stream-&gt;codecpar); //ret = avcodec_parameters_from_context(out_stream-&gt;codecpar, in_stream-&gt;codec); //ret = avcodec_parameters_to_context(out_stream-&gt;codec, in_stream-&gt;codecpar); if (ret &lt; 0) &#123; printf("copy 编解码器上下文失败\n"); &#125; out_stream-&gt;codecpar-&gt;codec_tag = 0; out_stream-&gt;codec-&gt;codec_tag = 0; if (octx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) &#123; out_stream-&gt;codec-&gt;flags = out_stream-&gt;codec-&gt;flags | CODEC_FLAG_GLOBAL_HEADER; &#125; &#125; //输入流数据的数量循环 for (i = 0; i &lt; ictx-&gt;nb_streams; i++) &#123; if (ictx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; videoindex = i; break; &#125; &#125; av_dump_format(octx, 0, outUrl, 1); ////////////////////////////////////////////////////////////////// // 准备推流 ///////////////////////////////////////////////////////////////// //打开IO ret = avio_open(&amp;octx-&gt;pb, outUrl, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; avError(ret); &#125; //写入头部信息 ret = avformat_write_header(octx, 0); if (ret &lt; 0) &#123; avError(ret); &#125; cout &lt;&lt; "avformat_write_header Success!" &lt;&lt; endl; //推流每一帧数据 //int64_t pts [ pts*(num/den) 第几秒显示] //int64_t dts 解码时间 [P帧(相对于上一帧的变化) I帧(关键帧，完整的数据) B帧(上一帧和下一帧的变化)] 有了B帧压缩率更高。 //uint8_t *data //int size //int stream_index //int flag AVPacket pkt; //获取当前的时间戳 微妙 long long start_time = av_gettime(); long long frame_index = 0; while (1) &#123; //输入输出视频流 AVStream *in_stream, *out_stream; //获取解码前数据 ret = av_read_frame(ictx, &amp;pkt); if (ret &lt; 0) &#123; break; &#125; /* PTS（Presentation Time Stamp）显示播放时间 DTS（Decoding Time Stamp）解码时间 */ //没有显示时间（比如未解码的 H.264 ） if (pkt.pts == AV_NOPTS_VALUE) &#123; //AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。 AVRational time_base1 = ictx-&gt;streams[videoindex]-&gt;time_base; //计算两帧之间的时间 /* r_frame_rate 基流帧速率 （不是太懂） av_q2d 转化为double类型 */ int64_t calc_duration = (double)AV_TIME_BASE / av_q2d(ictx-&gt;streams[videoindex]-&gt;r_frame_rate); //配置参数 pkt.pts = (double)(frame_index*calc_duration) / (double)(av_q2d(time_base1)*AV_TIME_BASE); pkt.dts = pkt.pts; pkt.duration = (double)calc_duration / (double)(av_q2d(time_base1)*AV_TIME_BASE); &#125; //延时 if (pkt.stream_index == videoindex) &#123; AVRational time_base = ictx-&gt;streams[videoindex]-&gt;time_base; AVRational time_base_q = &#123; 1,AV_TIME_BASE &#125;; //计算视频播放时间 int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q); //计算实际视频的播放时间 int64_t now_time = av_gettime() - start_time; AVRational avr = ictx-&gt;streams[videoindex]-&gt;time_base; cout &lt;&lt; avr.num &lt;&lt; " " &lt;&lt; avr.den &lt;&lt; " "&lt;&lt;pkt.dts &lt;&lt;" "&lt;&lt;pkt.pts&lt;&lt;" "&lt;&lt; pts_time &lt;&lt;endl; if (pts_time &gt; now_time) &#123; //睡眠一段时间（目的是让当前视频记录的播放时间与实际时间同步） av_usleep((unsigned int)(pts_time - now_time)); &#125; &#125; in_stream = ictx-&gt;streams[pkt.stream_index]; out_stream = octx-&gt;streams[pkt.stream_index]; //计算延时后，重新指定时间戳 pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base,(AVRounding) (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX)); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX)); //到这一帧时候经历了多长时间 pkt.duration = (int)av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); //字节流的位置，-1 表示不知道字节流位置 pkt.pos = -1; if (pkt.stream_index == videoindex) &#123; printf("Send %8d video frames to output URL\n", frame_index); frame_index++; &#125; //向输出上下文发送（向地址推送） ret = av_interleaved_write_frame(octx, &amp;pkt); if (ret &lt; 0) &#123; printf("发送数据包出错\n"); break; &#125; //释放 av_free_packet(&amp;pkt); &#125; return 0;&#125;int avError(int errNum) &#123; char buf[1024]; //获取错误信息 av_strerror(errNum, buf, sizeof(buf)); cout &lt;&lt; " failed! " &lt;&lt; buf &lt;&lt; endl; return -1;&#125; rtsp数据源rtmp推流 openCV磨皮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;extern "C"&#123; #include &lt;libswscale/swscale.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavformat/avformat.h&gt;&#125;#pragma comment(lib, "swscale.lib")#pragma comment(lib, "avcodec.lib")#pragma comment(lib, "avutil.lib")#pragma comment(lib, "avformat.lib")#pragma comment(lib,"opencv_world320.lib")using namespace std;using namespace cv;int main(int argc, char *argv[])&#123; //海康相机的rtsp url char *inUrl = "rtsp://test:test123456@192.168.1.64"; //nginx-rtmp rtmp 直播服务器rtmp推流URL char *outUrl = "rtmp://192.168.1.44/live"; //注册所有的编解码器 avcodec_register_all(); //注册所有的封装器 av_register_all(); //注册所有网络协议 avformat_network_init(); // opencv 接口 VideoCapture cam; Mat frame; namedWindow("video"); //像素格式转换上下文 SwsContext *vsc = NULL; //输出的数据结构 AVFrame *yuv = NULL; //编码器上下文 AVCodecContext *vc = NULL; //rtmp flv 封装器 AVFormatContext *ic = NULL; try&#123; /// 1 使用opencv打开rtsp相机 cam.open(inUrl); if (!cam.isOpened())&#123; throw exception("cam open failed!"); &#125; cout &lt;&lt; inUrl &lt;&lt; " cam open success" &lt;&lt; endl; int inWidth = cam.get(CAP_PROP_FRAME_WIDTH); int inHeight = cam.get(CAP_PROP_FRAME_HEIGHT); int fps = cam.get(CAP_PROP_FPS); /// 2 初始化格式转换上下文 vsc = sws_getCachedContext(vsc, inWidth, inHeight, AV_PIX_FMT_BGR24, // 源宽、高、像素格式 inWidth, inHeight, AV_PIX_FMT_YUV420P, // 目标宽、高、像素格式 SWS_BICUBIC, // 尺寸变化使用算法 0, 0, 0 ); if (!vsc)&#123; throw exception("sws_getCachedContext failed!"); &#125; /// 3 初始化输出的数据结构 yuv = av_frame_alloc(); yuv-&gt;format = AV_PIX_FMT_YUV420P; yuv-&gt;width = inWidth; yuv-&gt;height = inHeight; yuv-&gt;pts = 0; // 配yuv空间 int ret = av_frame_get_buffer(yuv, 32); if (ret != 0)&#123; char buf[1024] = &#123; 0 &#125;; av_strerror(ret, buf, sizeof(buf) - 1); throw exception(buf); &#125; /// 4 初始化编码上下文 // a 找到编码器 AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_H264); if (!codec)&#123; throw exception("Can`t find h264 encoder!"); &#125; // b 创建编码器上下文 vc = avcodec_alloc_context3(codec); if (!vc)&#123; throw exception("avcodec_alloc_context3 failed!"); &#125; // c 配置编码器参数 vc-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER; // 全局参数 vc-&gt;codec_id = codec-&gt;id; vc-&gt;thread_count = 8; vc-&gt;bit_rate = 50 * 1024 * 8; // 压缩后每秒视频的bit位大小 50kB vc-&gt;width = inWidth; vc-&gt;height = inHeight; vc-&gt;time_base = &#123; 1,fps &#125;; vc-&gt;framerate = &#123; fps,1 &#125;; // 画面组的大小，多少帧一个关键帧 vc-&gt;gop_size = 50; vc-&gt;max_b_frames = 0; vc-&gt;pix_fmt = AV_PIX_FMT_YUV420P; // d 打开编码器上下文 ret = avcodec_open2(vc, 0, 0); if (ret != 0)&#123; char buf[1024] = &#123; 0 &#125;; av_strerror(ret, buf, sizeof(buf) - 1); throw exception(buf); &#125; cout &lt;&lt; "avcodec_open2 success!" &lt;&lt; endl; /// 5 输出封装器和视频流配置 // a 创建输出封装器上下文 ret = avformat_alloc_output_context2(&amp;ic, 0, "flv", outUrl); if (ret != 0)&#123; char buf[1024] = &#123; 0 &#125;; av_strerror(ret, buf, sizeof(buf) - 1); throw exception(buf); &#125; // b 添加视频流 AVStream *vs = avformat_new_stream(ic, NULL); if (!vs)&#123; throw exception("avformat_new_stream failed"); &#125; vs-&gt;codecpar-&gt;codec_tag = 0; // 从编码器复制参数 avcodec_parameters_from_context(vs-&gt;codecpar, vc); av_dump_format(ic, 0, outUrl, 1); /// 6 打开rtmp 的网络输出IO ret = avio_open(&amp;ic-&gt;pb, outUrl, AVIO_FLAG_WRITE); if (ret != 0)&#123; char buf[1024] = &#123; 0 &#125;; av_strerror(ret, buf, sizeof(buf) - 1); throw exception(buf); &#125; // 写入封装头 ret = avformat_write_header(ic, NULL); if (ret != 0)&#123; char buf[1024] = &#123; 0 &#125;; av_strerror(ret, buf, sizeof(buf) - 1); throw exception(buf); &#125; AVPacket pack; memset(&amp;pack, 0, sizeof(pack)); int vpts = 0; for (;;)&#123; /// 取rtsp视频帧，解码视频帧 if (!cam.grab())&#123; continue; &#125; /// yuv转换为rgb if (!cam.retrieve(frame))&#123; continue; &#125; //imshow("video", frame); //waitKey(1); /// rgb to yuv // 输入的数据结构 uint8_t *indata[AV_NUM_DATA_POINTERS] = &#123; 0 &#125;; //indata[0] bgrbgrbgr //plane indata[0] bbbbb indata[1]ggggg indata[2]rrrrr indata[0] = frame.data; int insize[AV_NUM_DATA_POINTERS] = &#123; 0 &#125;; // 一行（宽）数据的字节数 insize[0] = frame.cols * frame.elemSize(); int h = sws_scale(vsc, indata, insize, 0, frame.rows, // 源数据 yuv-&gt;data, yuv-&gt;linesize); if (h &lt;= 0)&#123; continue; &#125; //cout &lt;&lt; h &lt;&lt; " " &lt;&lt; flush; /// h264 yuv-&gt;pts = vpts; vpts++; ret = avcodec_send_frame(vc, yuv); if (ret != 0) continue; ret = avcodec_receive_packet(vc, &amp;pack); if (ret != 0 || pack.size &gt; 0)&#123; //cout &lt;&lt; "*" &lt;&lt; pack.size &lt;&lt; flush; &#125; else&#123; continue; &#125; // 推流 pack.pts = av_rescale_q(pack.pts, vc-&gt;time_base, vs-&gt;time_base); pack.dts = av_rescale_q(pack.dts, vc-&gt;time_base, vs-&gt;time_base); pack.duration = av_rescale_q(pack.duration, vc-&gt;time_base, vs-&gt;time_base); ret = av_interleaved_write_frame(ic, &amp;pack); if (ret == 0)&#123; cout &lt;&lt; "#" &lt;&lt; flush; &#125; &#125; &#125; catch (exception &amp;ex)&#123; if (cam.isOpened()) cam.release(); if (vsc)&#123; sws_freeContext(vsc); vsc = NULL; &#125; if (vc)&#123; avio_closep(&amp;ic-&gt;pb); avcodec_free_context(&amp;vc); &#125; cerr &lt;&lt; ex.what() &lt;&lt; endl; &#125; getchar(); return 0;&#125;]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFMPEG+SDL视频播放器]]></title>
    <url>%2F2019%2F05%2F18%2FFFmpeg%2FFFmpeg%2BSDL%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[GitHub FFmpeg ffmpeg 源代码简单分析 100行代码实现最简单的基于FFMPEG+SDL的视频播放器 simplest_ffmpeg_player 该播放器虽然简单，但是几乎包含了使用FFMPEG播放一个视频所有必备的API，并且使用SDL显示解码出来的视频。 并且支持流媒体等多种视频输入，处于简单考虑，没有音频部分，同时视频播放采用直接延时40ms的方式 对比SDL1.2的流程图，发现变化还是很大的。几乎所有的API都发生了变化。但是函数和变量有一定的对应关系： SDL_SetVideoMode()————SDL_CreateWindow() SDL_Surface————SDL_Window SDL_CreateYUVOverlay()————SDL_CreateTexture() SDL_Overlay————SDL_Texture 简单解释各个变量的作用： SDL_Window就是使用SDL的时候弹出的那个窗口。在SDL1.x版本中，只可以创建一个一个窗口。在SDL2.0版本中，可以创建多个窗口。 SDL_Texture用于显示YUV数据。一个SDL_Texture对应一帧YUV数据。 SDL_Renderer用于渲染SDL_Texture至SDL_Window。 SDL_Rect用于确定SDL_Texture显示的位置。注意：一个SDL_Texture可以指定多个不同的 SDL_Rect，这样就可以在SDL_Window不同位置显示相同的内容（使用SDL_RenderCopy()函数）。 它们的关系如下图所示： 下图举了个例子，指定了4个SDL_Rect，可以实现4分屏的显示。 simplest_ffmpeg_player（标准版）代码最基础的版本，学习的开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/** * 最简单的基于FFmpeg的视频播放器 2 * Simplest FFmpeg Player 2 * * 本程序实现了视频文件的解码和显示(支持HEVC，H.264，MPEG2等)。 * 是最简单的FFmpeg视频解码方面的教程。 * 通过学习本例子可以了解FFmpeg的解码流程。 * This software is a simplest video player based on FFmpeg. * Suitable for beginner of FFmpeg. * */#include &lt;stdio.h&gt; #define __STDC_CONSTANT_MACROS #ifdef _WIN32//Windowsextern "C"&#123;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libswscale/swscale.h"#include "libavutil/imgutils.h"#include "SDL2/SDL.h"&#125;;#else//Linux...#ifdef __cplusplusextern "C"&#123;#endif #include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;SDL2/SDL.h&gt;#include &lt;libavutil/imgutils.h&gt;#ifdef __cplusplus&#125;;#endif#endif //Output YUV420P data as a file #define OUTPUT_YUV420P 0 int main(int argc, char* argv[])&#123; AVFormatContext *pFormatCtx; // 音视频格式化上下文 int i, videoindex; AVCodecContext *pCodecCtx; // 音视频编解码器上下文 AVCodec *pCodec; // 音视频编解码器 AVFrame *pFrame, *pFrameYUV; // 音视频数据帧 unsigned char *out_buffer; AVPacket *packet; // 音视频数据包 int y_size; int ret, got_picture; struct SwsContext *img_convert_ctx; // 视频图像转换上下文 char filepath[]="bigbuckbunny_480x272.h265"; //SDL--------------------------- int screen_w=0, screen_h=0; SDL_Window *screen; SDL_Renderer *sdlRenderer; // SDL渲染器 SDL_Texture *sdlTexture; // SDL纹理 SDL_Rect sdlRect; // 确定SDL_Texture显示的位置 FILE *fp_yuv; av_register_all(); // 注册所有的编解码器 avformat_network_init(); pFormatCtx = avformat_alloc_context(); if(avformat_open_input(&amp;pFormatCtx, filepath, NULL, NULL) != 0)&#123; printf("Couldn't open input stream.\n"); return -1; &#125; if(avformat_find_stream_info(pFormatCtx,NULL) &lt; 0)&#123; printf("Couldn't find stream information.\n"); return -1; &#125; videoindex = -1; for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; videoindex = i; break; &#125; if(videoindex == -1)&#123; printf("Didn't find a video stream.\n"); return -1; &#125; pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec; pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if(pCodec == NULL)&#123; printf("Codec not found.\n"); return -1; &#125; if(avcodec_open2(pCodecCtx, pCodec,NULL) &lt; 0)&#123; printf("Could not open codec.\n"); return -1; &#125; pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1)); av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize,out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); packet = (AVPacket *)av_malloc(sizeof(AVPacket)); //Output Info----------------------------- printf("--------------- File Information ----------------\n"); av_dump_format(pFormatCtx, 0, filepath, 0); printf("-------------------------------------------------\n"); img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); #if OUTPUT_YUV420P fp_yuv=fopen("output.yuv", "wb+"); #endif if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; printf( "Could not initialize SDL - %s\n", SDL_GetError()); return -1; &#125; screen_w = pCodecCtx-&gt;width; screen_h = pCodecCtx-&gt;height; //SDL 2.0 Support for multiple windows screen = SDL_CreateWindow("Simplest ffmpeg player's Window", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL); if(!screen) &#123; printf("SDL: could not create window - exiting:%s\n",SDL_GetError()); return -1; &#125; sdlRenderer = SDL_CreateRenderer(screen, -1, 0); //IYUV: Y + U + V (3 planes) //YV12: Y + V + U (3 planes) sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-&gt;width, pCodecCtx-&gt;height); sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; //SDL End---------------------- while(av_read_frame(pFormatCtx, packet)&gt;=0)&#123; if(packet-&gt;stream_index == videoindex)&#123; ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if(ret &lt; 0)&#123; printf("Decode Error.\n"); return -1; &#125; if(got_picture)&#123; sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); #if OUTPUT_YUV420P y_size = pCodecCtx-&gt;width*pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0], 1, y_size, fp_yuv); //Y fwrite(pFrameYUV-&gt;data[1], 1, y_size/4, fp_yuv); //U fwrite(pFrameYUV-&gt;data[2], 1, y_size/4, fp_yuv); //V#endif //SDL---------------------------#if 0 SDL_UpdateTexture(sdlTexture, NULL, pFrameYUV-&gt;data[0], pFrameYUV-&gt;linesize[0]); #else SDL_UpdateYUVTexture(sdlTexture, &amp;sdlRect, pFrameYUV-&gt;data[0], pFrameYUV-&gt;linesize[0], pFrameYUV-&gt;data[1], pFrameYUV-&gt;linesize[1], pFrameYUV-&gt;data[2], pFrameYUV-&gt;linesize[2]);#endif SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, &amp;sdlRect); SDL_RenderPresent(sdlRenderer); //SDL End----------------------- //Delay 40ms SDL_Delay(40); &#125; &#125; av_free_packet(packet); &#125; //flush decoder //FIX: Flush Frames remained in Codec while (1) &#123; ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if (ret &lt; 0) break; if (!got_picture) break; sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);#if OUTPUT_YUV420P int y_size = pCodecCtx-&gt;width*pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0], 1, y_size, fp_yuv); //Y fwrite(pFrameYUV-&gt;data[1], 1, y_size/4, fp_yuv); //U fwrite(pFrameYUV-&gt;data[2], 1, y_size/4, fp_yuv); //V#endif //SDL--------------------------- SDL_UpdateTexture(sdlTexture, &amp;sdlRect, pFrameYUV-&gt;data[0], pFrameYUV-&gt;linesize[0]); SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, &amp;sdlRect); SDL_RenderPresent(sdlRenderer); //SDL End----------------------- //Delay 40ms SDL_Delay(40); &#125; sws_freeContext(img_convert_ctx); #if OUTPUT_YUV420P fclose(fp_yuv);#endif SDL_Quit(); av_frame_free(&amp;pFrameYUV); av_frame_free(&amp;pFrame); avcodec_close(pCodecCtx); avformat_close_input(&amp;pFormatCtx); return 0;&#125; simplest_ffmpeg_player_su（SU版）代码标准版的基础之上引入了 SDL 的 Event。 效果如下： SDL弹出的窗口可以移动了 画面显示是严格的40ms一帧 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/** * 最简单的基于FFmpeg的视频播放器2(SDL升级版) * Simplest FFmpeg Player 2(SDL Update) * * 本程序实现了视频文件的解码和显示(支持HEVC，H.264，MPEG2等)。 * 是最简单的FFmpeg视频解码方面的教程。 * 通过学习本例子可以了解FFmpeg的解码流程。 * 本版本中使用SDL消息机制刷新视频画面。 * This software is a simplest video player based on FFmpeg. * Suitable for beginner of FFmpeg. * * 备注: * 标准版在播放视频的时候，画面显示使用延时40ms的方式。这么做有两个后果： * （1）SDL弹出的窗口无法移动，一直显示是忙碌状态 * （2）画面显示并不是严格的40ms一帧，因为还没有考虑解码的时间。 * SU（SDL Update）版在视频解码的过程中，不再使用延时40ms的方式，而是创建了 * 一个线程，每隔40ms发送一个自定义的消息，告知主函数进行解码显示。这样做之后： * （1）SDL弹出的窗口可以移动了 * （2）画面显示是严格的40ms一帧 */#include &lt;stdio.h&gt; #define __STDC_CONSTANT_MACROS #ifdef _WIN32//Windowsextern "C"&#123;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libswscale/swscale.h"#include "libavutil/imgutils.h"#include "SDL2/SDL.h"&#125;;#else//Linux...#ifdef __cplusplusextern "C"&#123;#endif #include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libavutil/imgutils.h&gt;#include &lt;SDL2/SDL.h&gt; #ifdef __cplusplus&#125;;#endif#endif //Refresh Event#define SFM_REFRESH_EVENT (SDL_USEREVENT + 1)#define SFM_BREAK_EVENT (SDL_USEREVENT + 2) int thread_exit = 0;int thread_pause = 0; int sfp_refresh_thread(void *opaque)&#123; thread_exit = 0; thread_pause = 0; while (!thread_exit) &#123; if(!thread_pause)&#123; SDL_Event event; event.type = SFM_REFRESH_EVENT; SDL_PushEvent(&amp;event); &#125; SDL_Delay(40); &#125; thread_exit = 0; thread_pause = 0; //Break SDL_Event event; event.type = SFM_BREAK_EVENT; SDL_PushEvent(&amp;event); return 0;&#125; int main(int argc, char* argv[])&#123; AVFormatContext *pFormatCtx; int i, videoindex; AVCodecContext *pCodecCtx; // 音视频编解码器上下文 AVCodec *pCodec; AVFrame *pFrame, *pFrameYUV; unsigned char *out_buffer; AVPacket *packet; int ret, got_picture; //------------SDL---------------- int screen_w, screen_h; SDL_Window *screen; SDL_Renderer *sdlRenderer; SDL_Texture *sdlTexture; SDL_Rect sdlRect; SDL_Thread *video_tid; SDL_Event event; struct SwsContext *img_convert_ctx; //char filepath[]="bigbuckbunny_480x272.h265"; char filepath[]="Titanic.ts"; av_register_all(); // 注册所有的编解码器 avformat_network_init(); pFormatCtx = avformat_alloc_context(); // 分配内存并设置默认值 // 该函数用于打开多媒体数据并且获得一些相关的信息,AVInputFormat的read_header()完成了视音频流对应的AVStream的创建 if(avformat_open_input(&amp;pFormatCtx, filepath, NULL, NULL) != 0)&#123; printf("Couldn't open input stream.\n"); return -1; &#125; // 该函数可以读取一部分视音频数据并且获得一些相关的信息,该函数主要用于给每个媒体流（音频/视频）的AVStream结构体赋值 if(avformat_find_stream_info(pFormatCtx, NULL) &lt; 0)&#123; printf("Couldn't find stream information.\n"); return -1; &#125; videoindex = -1; for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; videoindex = i; break; &#125; if(videoindex == -1)&#123; printf("Didn't find a video stream.\n"); return -1; &#125; pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec; // 找到视频流编解码器 pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if(pCodec == NULL)&#123; printf("Codec not found.\n"); return -1; &#125; // 该函数用于初始化一个视音频编解码器的AVCodecContext //（1）为各种结构体分配内存（通过各种av_malloc()实现）。 //（2）将输入的AVDictionary形式的选项设置到AVCodecContext。 //（3）其他一些零零碎碎的检查，比如说检查编解码器是否处于“实验”阶段。 //（4）如果是编码器，检查输入参数是否符合编码器的要求 //（5）调用AVCodec的init()初始化具体的解码器。 if(avcodec_open2(pCodecCtx, pCodec,NULL) &lt; 0)&#123; printf("Could not open codec.\n"); return -1; &#125; pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1)); av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, out_buffer,AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); //Output Info----------------------------- printf("---------------- File Information ---------------\n"); av_dump_format(pFormatCtx, 0, filepath, 0); printf("-------------------------------------------------\n"); // 初始化一个SwsContext // 参数说明： // 源图像的宽, 源图像的高, 源图像的像素格式, // 目标图像的宽, 目标图像的高, 目标图像的像素格式, 设定图像拉伸使用的算法 img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; printf( "Could not initialize SDL - %s\n", SDL_GetError()); return -1; &#125; //SDL 2.0 Support for multiple windows screen_w = pCodecCtx-&gt;width; screen_h = pCodecCtx-&gt;height; screen = SDL_CreateWindow("Simplest ffmpeg player's Window", SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL); if(!screen) &#123; printf("SDL: could not create window - exiting:%s\n",SDL_GetError()); return -1; &#125; sdlRenderer = SDL_CreateRenderer(screen, -1, 0); //IYUV: Y + U + V (3 planes) //YV12: Y + V + U (3 planes) sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-&gt;width, pCodecCtx-&gt;height); sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; packet = (AVPacket *)av_malloc(sizeof(AVPacket)); video_tid = SDL_CreateThread(sfp_refresh_thread, NULL, NULL); //------------SDL End------------ //Event Loop for (;;) &#123; //Wait SDL_WaitEvent(&amp;event); if(event.type == SFM_REFRESH_EVENT)&#123; while(1)&#123; // av_read_frame()的作用是读取码流中的音频若干帧或者视频一帧 // 例如，解码视频的时候，每解码一个视频帧，需要先调用 av_read_frame()获得一帧视频的压缩数据，然后才能对该数据进行解码（例如H.264中一帧压缩数据通常对应一个NAL） // 参数说明：输入的AVFormatContext, 输出的AVPacket if(av_read_frame(pFormatCtx, packet)&lt;0) thread_exit = 1; if(packet-&gt;stream_index == videoindex) break; &#125; // 作用是解码一帧视频数据,输入一个压缩编码的结构体AVPacket，输出一个解码后的结构体AVFrame // avcodec_decode_video2()主要做了以下几个方面的工作： //（1）对输入的字段进行了一系列的检查工作：例如宽高是否正确，输入是否为视频等等。 //（2）通过ret = avctx-&gt;codec-&gt;decode(avctx, picture, got_picture_ptr,&amp;tmp)这句代码，调用了相应AVCodec的decode()函数，完成了解码操作。 //（3）对得到的AVFrame的一些字段进行了赋值，例如宽高、像素格式等等。 ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if(ret &lt; 0)&#123; printf("Decode Error.\n"); return -1; &#125; if(got_picture)&#123; // sws_scale()是用于转换像素的函数 // 参数说明： // 1）转换格式的上下文。也就是 sws_getContext 函数返回的结果。 // 2）输入图像的每个颜色通道的数据指针 // 3）输入图像的每个颜色通道的跨度 // 4）参数int srcSliceY, int srcSliceH,定义在输入图像上处理区域，srcSliceY是起始位置，srcSliceH是处理多少行。 // 如果srcSliceY=0，srcSliceH=height，表示一次性处理完整个图像。 // 这种设置是为了多线程并行，例如可以创建两个线程，第一个线程处理 [0, h/2-1]行，第二个线程处理 [h/2, h-1]行。并行处理加快速度。 // 5）参数uint8_t *const dst[], const int dstStride[]定义输出图像信息（输出的每个颜色通道数据指针，每个颜色通道行字节数） sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); //SDL--------------------------- SDL_UpdateTexture( sdlTexture, NULL, pFrameYUV-&gt;data[0], pFrameYUV-&gt;linesize[0] ); SDL_RenderClear( sdlRenderer ); //SDL_RenderCopy( sdlRenderer, sdlTexture, &amp;sdlRect, &amp;sdlRect ); SDL_RenderCopy( sdlRenderer, sdlTexture, NULL, NULL); SDL_RenderPresent( sdlRenderer ); //SDL End----------------------- &#125; av_free_packet(packet); &#125;else if(event.type == SDL_KEYDOWN)&#123; //Pause if(event.key.keysym.sym == SDLK_SPACE) thread_pause =! thread_pause; &#125;else if(event.type == SDL_QUIT)&#123; thread_exit = 1; &#125;else if(event.type == SFM_BREAK_EVENT)&#123; break; &#125; &#125; sws_freeContext(img_convert_ctx); SDL_Quit(); //-------------- av_frame_free(&amp;pFrameYUV); av_frame_free(&amp;pFrame); avcodec_close(pCodecCtx); avformat_close_input(&amp;pFormatCtx); return 0;&#125; av_read_packet()通过 av_read_packet()，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况。 以 ts 流为例，是读取一个完整的 PES 包（一个完整 pes 包包含若干视频或音频 es 包），读取完毕后，通过 av_parser_parse2() 分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则 st = s-&gt;cur_st ; 不会是NULL，即再此进入 av_parser_parse2() 流程，而不是下面的 av_read_packet（） 流程. 这样就保证了，如果读取一次包含了 N 帧视频数据（以视频为例），则调用 av_read_frame（） N 次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。 函数调用结构图： FFmpeg 源码分析av_register_all() av_register_all() - ffmpeg注册复用器，编码器 该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。 1234567891011121314// 可见解复用器注册都是用REGISTER_DEMUXER (X,x)// 例如：REGISTER_DEMUXER (AAC, aac)// 可见复用器注册都是用REGISTER_MUXER (X,x))// 例如：REGISTER_MUXER (ADTS, adts)// 既有解复用器又有复用器的话，可以用REGISTER_MUXDEMUX (X,x));// 例如：REGISTER_MUXDEMUX (AC3, ac3); 看一下宏的定义，这里以解复用器为例： 12345678910#define REGISTER_DEMUXER(X,x) &#123; \ extern AVInputFormat ff_##x##_demuxer; \ if(CONFIG_##X##_DEMUXER) av_register_input_format(&amp;ff_##x##_demuxer); &#125;/* * 注意：define 里面的##可能不太常见，它的含义就是拼接两个字符串，比如 * #define Conn(x,y) x##y * 那么 * int n = Conn(123,456); 结果就是 n = 123456; */ 我们以 REGISTER_DEMUXER (AAC, aac) 为例，则它等效于 12extern AVInputFormat ff_aac_demuxer; if(CONFIG_AAC_DEMUXER) av_register_input_format(&amp;ff_aac_demuxer); 从上面这段代码我们可以看出，真正注册的函数是 av_register_input_format(&amp;ff_aac_demuxer)，那我就看看这个和函数的作用，查看一下 av_register_input_format() 的代码： 12345678void av_register_input_format(AVInputFormat *format)&#123; AVInputFormat **p; p = &amp;first_iformat; while (*p != NULL) p = &amp;(*p)-&gt;next; *p = format; format-&gt;next = NULL;&#125; 这段代码是比较容易理解的，首先先提一点，first_iformat 是个什么东东呢？其实它是 Input Format 链表的头部地址，是一个全局静态变量，定义如下： 12/** head of registered input format linked list */static AVInputFormat *first_iformat = NULL; 由此我们可以分析出 av_register_input_format() 的含义，一句话概括就是： 遍历链表并把当前的 Input Format 加到链表的尾部。 至此 REGISTER_DEMUXER (X, x) 分析完毕。 同理，复用器道理是一样的，只是注册函数改为 av_register_output_format()； 既有解复用器又有复用器的话，有一个宏定义： 1#define REGISTER_MUXDEMUX(X,x) REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x) 可见是分别注册了复用器和解复用器。 此外还有网络协议的注册，注册函数为 ffurl_register_protocol()，在此不再详述。 下面贴出它的源代码（allformats.c） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#include "avformat.h"#include "rtp.h"#include "rdt.h"#include "url.h"// 定义的宏？宏的速度会快一点？注册 AVOutputFormat// define中，#用来把参数转换成字符串，##则用来连接前后两个参数，把它们变成一个字符串。// 感觉有点像JAva中的EL，可以随意拼接字符串#define REGISTER_MUXER(X,x) &#123; \ extern AVOutputFormat ff_##x##_muxer; \ if(CONFIG_##X##_MUXER) av_register_output_format(&amp;ff_##x##_muxer); &#125;// 定义的宏？宏的速度会快一点？注册AVInputFormat#define REGISTER_DEMUXER(X,x) &#123; \ extern AVInputFormat ff_##x##_demuxer; \ if(CONFIG_##X##_DEMUXER) av_register_input_format(&amp;ff_##x##_demuxer); &#125;// 注册函数 av_register_input_format // 定义的宏？宏的速度会快一点？两个一起注册！#define REGISTER_MUXDEMUX(X,x) REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)// 定义的宏？宏的速度会快一点？注册URLProtocol// extern URLProtocol ff_##x##_protocol;// 在 librtmp 中，对应的就是 ff_rtmp_protocol// 这样就把 librtmp 整合起来了// 由此可见 URLProtocol 的名字是固定的#define REGISTER_PROTOCOL(X,x) &#123; \ extern URLProtocol ff_##x##_protocol; \ if(CONFIG_##X##_PROTOCOL) ffurl_register_protocol(&amp;ff_##x##_protocol, sizeof(ff_##x##_protocol)); &#125;// 注册函数 ffurl_register_protocolvoid av_register_all(void)&#123; static int initialized; if (initialized) return; initialized = 1; // 注册所有的 codec avcodec_register_all(); // 注册所有的 MUXER（复用器和解复用器） /* (de)muxers */ REGISTER_MUXER (A64, a64); REGISTER_DEMUXER (AAC, aac); REGISTER_MUXDEMUX (AC3, ac3); REGISTER_DEMUXER (ACT, act); REGISTER_DEMUXER (ADF, adf); REGISTER_MUXER (ADTS, adts); REGISTER_MUXDEMUX (ADX, adx); REGISTER_DEMUXER (AEA, aea); REGISTER_MUXDEMUX (AIFF, aiff); REGISTER_MUXDEMUX (AMR, amr); REGISTER_DEMUXER (ANM, anm); REGISTER_DEMUXER (APC, apc); REGISTER_DEMUXER (APE, ape); REGISTER_DEMUXER (APPLEHTTP, applehttp); REGISTER_MUXDEMUX (ASF, asf); REGISTER_MUXDEMUX (ASS, ass); REGISTER_MUXER (ASF_STREAM, asf_stream); REGISTER_MUXDEMUX (AU, au); REGISTER_MUXDEMUX (AVI, avi); REGISTER_DEMUXER (AVISYNTH, avisynth); REGISTER_MUXER (AVM2, avm2); REGISTER_DEMUXER (AVS, avs); REGISTER_DEMUXER (BETHSOFTVID, bethsoftvid); REGISTER_DEMUXER (BFI, bfi); REGISTER_DEMUXER (BINTEXT, bintext); REGISTER_DEMUXER (BINK, bink); REGISTER_MUXDEMUX (BIT, bit); REGISTER_DEMUXER (BMV, bmv); REGISTER_DEMUXER (C93, c93); REGISTER_MUXDEMUX (CAF, caf); REGISTER_MUXDEMUX (CAVSVIDEO, cavsvideo); REGISTER_DEMUXER (CDG, cdg); REGISTER_MUXER (CRC, crc); REGISTER_MUXDEMUX (DAUD, daud); REGISTER_DEMUXER (DFA, dfa); REGISTER_MUXDEMUX (DIRAC, dirac); REGISTER_MUXDEMUX (DNXHD, dnxhd); REGISTER_DEMUXER (DSICIN, dsicin); REGISTER_MUXDEMUX (DTS, dts); REGISTER_MUXDEMUX (DV, dv); REGISTER_DEMUXER (DXA, dxa); REGISTER_DEMUXER (EA, ea); REGISTER_DEMUXER (EA_CDATA, ea_cdata); REGISTER_MUXDEMUX (EAC3, eac3); REGISTER_MUXDEMUX (FFM, ffm); REGISTER_MUXDEMUX (FFMETADATA, ffmetadata); REGISTER_MUXDEMUX (FILMSTRIP, filmstrip); REGISTER_MUXDEMUX (FLAC, flac); REGISTER_DEMUXER (FLIC, flic); REGISTER_MUXDEMUX (FLV, flv); REGISTER_DEMUXER (FOURXM, fourxm); REGISTER_MUXER (FRAMECRC, framecrc); REGISTER_MUXER (FRAMEMD5, framemd5); REGISTER_MUXDEMUX (G722, g722); REGISTER_MUXDEMUX (G723_1, g723_1); REGISTER_DEMUXER (G729, g729); REGISTER_MUXER (GIF, gif); REGISTER_DEMUXER (GSM, gsm); REGISTER_MUXDEMUX (GXF, gxf); REGISTER_MUXDEMUX (H261, h261); REGISTER_MUXDEMUX (H263, h263); REGISTER_MUXDEMUX (H264, h264); REGISTER_DEMUXER (ICO, ico); REGISTER_DEMUXER (IDCIN, idcin); REGISTER_DEMUXER (IDF, idf); REGISTER_DEMUXER (IFF, iff); REGISTER_MUXDEMUX (IMAGE2, image2); REGISTER_MUXDEMUX (IMAGE2PIPE, image2pipe); REGISTER_DEMUXER (INGENIENT, ingenient); REGISTER_DEMUXER (IPMOVIE, ipmovie); REGISTER_MUXER (IPOD, ipod); REGISTER_MUXER (ISMV, ismv); REGISTER_DEMUXER (ISS, iss); REGISTER_DEMUXER (IV8, iv8); REGISTER_MUXDEMUX (IVF, ivf); REGISTER_DEMUXER (JV, jv); REGISTER_MUXDEMUX (LATM, latm); REGISTER_DEMUXER (LMLM4, lmlm4); REGISTER_DEMUXER (LOAS, loas); REGISTER_DEMUXER (LXF, lxf); REGISTER_MUXDEMUX (M4V, m4v); REGISTER_MUXER (MD5, md5); REGISTER_MUXDEMUX (MATROSKA, matroska); REGISTER_MUXER (MATROSKA_AUDIO, matroska_audio); REGISTER_MUXDEMUX (MICRODVD, microdvd); REGISTER_MUXDEMUX (MJPEG, mjpeg); REGISTER_MUXDEMUX (MLP, mlp); REGISTER_DEMUXER (MM, mm); REGISTER_MUXDEMUX (MMF, mmf); REGISTER_MUXDEMUX (MOV, mov); REGISTER_MUXER (MP2, mp2); REGISTER_MUXDEMUX (MP3, mp3); REGISTER_MUXER (MP4, mp4); REGISTER_DEMUXER (MPC, mpc); REGISTER_DEMUXER (MPC8, mpc8); REGISTER_MUXER (MPEG1SYSTEM, mpeg1system); REGISTER_MUXER (MPEG1VCD, mpeg1vcd); REGISTER_MUXER (MPEG1VIDEO, mpeg1video); REGISTER_MUXER (MPEG2DVD, mpeg2dvd); REGISTER_MUXER (MPEG2SVCD, mpeg2svcd); REGISTER_MUXER (MPEG2VIDEO, mpeg2video); REGISTER_MUXER (MPEG2VOB, mpeg2vob); REGISTER_DEMUXER (MPEGPS, mpegps); REGISTER_MUXDEMUX (MPEGTS, mpegts); REGISTER_DEMUXER (MPEGTSRAW, mpegtsraw); REGISTER_DEMUXER (MPEGVIDEO, mpegvideo); REGISTER_MUXER (MPJPEG, mpjpeg); REGISTER_DEMUXER (MSNWC_TCP, msnwc_tcp); REGISTER_DEMUXER (MTV, mtv); REGISTER_DEMUXER (MVI, mvi); REGISTER_MUXDEMUX (MXF, mxf); REGISTER_MUXER (MXF_D10, mxf_d10); REGISTER_DEMUXER (MXG, mxg); REGISTER_DEMUXER (NC, nc); REGISTER_DEMUXER (NSV, nsv); REGISTER_MUXER (NULL, null); REGISTER_MUXDEMUX (NUT, nut); REGISTER_DEMUXER (NUV, nuv); REGISTER_MUXDEMUX (OGG, ogg); REGISTER_MUXDEMUX (OMA, oma); REGISTER_MUXDEMUX (PCM_ALAW, pcm_alaw); REGISTER_MUXDEMUX (PCM_MULAW, pcm_mulaw); REGISTER_MUXDEMUX (PCM_F64BE, pcm_f64be); REGISTER_MUXDEMUX (PCM_F64LE, pcm_f64le); REGISTER_MUXDEMUX (PCM_F32BE, pcm_f32be); REGISTER_MUXDEMUX (PCM_F32LE, pcm_f32le); REGISTER_MUXDEMUX (PCM_S32BE, pcm_s32be); REGISTER_MUXDEMUX (PCM_S32LE, pcm_s32le); REGISTER_MUXDEMUX (PCM_S24BE, pcm_s24be); REGISTER_MUXDEMUX (PCM_S24LE, pcm_s24le); REGISTER_MUXDEMUX (PCM_S16BE, pcm_s16be); REGISTER_MUXDEMUX (PCM_S16LE, pcm_s16le); REGISTER_MUXDEMUX (PCM_S8, pcm_s8); REGISTER_MUXDEMUX (PCM_U32BE, pcm_u32be); REGISTER_MUXDEMUX (PCM_U32LE, pcm_u32le); REGISTER_MUXDEMUX (PCM_U24BE, pcm_u24be); REGISTER_MUXDEMUX (PCM_U24LE, pcm_u24le); REGISTER_MUXDEMUX (PCM_U16BE, pcm_u16be); REGISTER_MUXDEMUX (PCM_U16LE, pcm_u16le); REGISTER_MUXDEMUX (PCM_U8, pcm_u8); REGISTER_DEMUXER (PMP, pmp); REGISTER_MUXER (PSP, psp); REGISTER_DEMUXER (PVA, pva); REGISTER_DEMUXER (QCP, qcp); REGISTER_DEMUXER (R3D, r3d); REGISTER_MUXDEMUX (RAWVIDEO, rawvideo); REGISTER_DEMUXER (RL2, rl2); REGISTER_MUXDEMUX (RM, rm); REGISTER_MUXDEMUX (ROQ, roq); REGISTER_DEMUXER (RPL, rpl); REGISTER_MUXDEMUX (RSO, rso); REGISTER_MUXDEMUX (RTP, rtp); REGISTER_MUXDEMUX (RTSP, rtsp); REGISTER_MUXDEMUX (SAP, sap); REGISTER_DEMUXER (SBG, sbg); REGISTER_DEMUXER (SDP, sdp);#if CONFIG_RTPDEC av_register_rtp_dynamic_payload_handlers(); av_register_rdt_dynamic_payload_handlers();#endif REGISTER_DEMUXER (SEGAFILM, segafilm); REGISTER_MUXER (SEGMENT, segment); REGISTER_DEMUXER (SHORTEN, shorten); REGISTER_DEMUXER (SIFF, siff); REGISTER_DEMUXER (SMACKER, smacker); REGISTER_MUXDEMUX (SMJPEG, smjpeg); REGISTER_DEMUXER (SOL, sol); REGISTER_MUXDEMUX (SOX, sox); REGISTER_MUXDEMUX (SPDIF, spdif); REGISTER_MUXDEMUX (SRT, srt); REGISTER_DEMUXER (STR, str); REGISTER_MUXDEMUX (SWF, swf); REGISTER_MUXER (TG2, tg2); REGISTER_MUXER (TGP, tgp); REGISTER_DEMUXER (THP, thp); REGISTER_DEMUXER (TIERTEXSEQ, tiertexseq); REGISTER_MUXER (MKVTIMESTAMP_V2, mkvtimestamp_v2); REGISTER_DEMUXER (TMV, tmv); REGISTER_MUXDEMUX (TRUEHD, truehd); REGISTER_DEMUXER (TTA, tta); REGISTER_DEMUXER (TXD, txd); REGISTER_DEMUXER (TTY, tty); REGISTER_DEMUXER (VC1, vc1); REGISTER_MUXDEMUX (VC1T, vc1t); REGISTER_DEMUXER (VMD, vmd); REGISTER_MUXDEMUX (VOC, voc); REGISTER_DEMUXER (VQF, vqf); REGISTER_DEMUXER (W64, w64); REGISTER_MUXDEMUX (WAV, wav); REGISTER_DEMUXER (WC3, wc3); REGISTER_MUXER (WEBM, webm); REGISTER_DEMUXER (WSAUD, wsaud); REGISTER_DEMUXER (WSVQA, wsvqa); REGISTER_MUXDEMUX (WTV, wtv); REGISTER_DEMUXER (WV, wv); REGISTER_DEMUXER (XA, xa); REGISTER_DEMUXER (XBIN, xbin); REGISTER_DEMUXER (XMV, xmv); REGISTER_DEMUXER (XWMA, xwma); REGISTER_DEMUXER (YOP, yop); REGISTER_MUXDEMUX (YUV4MPEGPIPE, yuv4mpegpipe); /* external libraries */#if CONFIG_LIBMODPLUG REGISTER_DEMUXER (LIBMODPLUG, libmodplug);#endif REGISTER_MUXDEMUX (LIBNUT, libnut); // 注册所有的 Protocol（位于 DEMUXER 之前（我的理解~~）） // 文件也是一种Protocol /* protocols */ REGISTER_PROTOCOL (APPLEHTTP, applehttp); REGISTER_PROTOCOL (CACHE, cache); REGISTER_PROTOCOL (CONCAT, concat); REGISTER_PROTOCOL (CRYPTO, crypto); REGISTER_PROTOCOL (FILE, file); REGISTER_PROTOCOL (GOPHER, gopher); REGISTER_PROTOCOL (HTTP, http); REGISTER_PROTOCOL (HTTPPROXY, httpproxy); REGISTER_PROTOCOL (HTTPS, https); REGISTER_PROTOCOL (MMSH, mmsh); REGISTER_PROTOCOL (MMST, mmst); REGISTER_PROTOCOL (MD5, md5); REGISTER_PROTOCOL (PIPE, pipe); REGISTER_PROTOCOL (RTMP, rtmp);// 如果包含了 LibRTMP#if CONFIG_LIBRTMP REGISTER_PROTOCOL (RTMP, rtmpt); REGISTER_PROTOCOL (RTMP, rtmpe); REGISTER_PROTOCOL (RTMP, rtmpte); REGISTER_PROTOCOL (RTMP, rtmps);#endif REGISTER_PROTOCOL (RTP, rtp); REGISTER_PROTOCOL (TCP, tcp); REGISTER_PROTOCOL (TLS, tls); REGISTER_PROTOCOL (UDP, udp);&#125; 整个代码没太多可说的，首先确定是不是已经初始化过了（initialized），如果没有，就调用 avcodec_register_all() 注册编解码器（这个先不分析），然后就是注册，注册，注册…直到完成所有注册。 PS：曾经研究过一阵子 RTMP 协议，以及对应的开源工程 librtmp。在这里发现有一点值得注意，ffmpeg自带了 RTMP 协议的支持，只有使用 rtmpt://, rtmpe://, rtmpte:// 等的时候才会使用 librtmp 库。 函数调用关系图如下图所示。av_register_all() 调用了 avcodec_register_all() 。 avcodec_register_all() 注册了和编解码器有关的组件：硬件加速器，解码器，编码器，Parser，Bitstream Filter。av_register_all() 除了调用 avcodec_register_all() 之外，还注册了复用器，解复用器，协议处理器。 下面附上复用器，解复用器，协议处理器的代码。 注册复用器的函数是 av_register_output_format()。 12345678void av_register_output_format(AVOutputFormat *format)&#123; AVOutputFormat **p; p = &amp;first_oformat; while (*p != NULL) p = &amp;(*p)-&gt;next; *p = format; format-&gt;next = NULL;&#125; 注册解复用器的函数是 av_register_input_format()。 12345678void av_register_input_format(AVInputFormat *format)&#123; AVInputFormat **p; p = &amp;first_iformat; while (*p != NULL) p = &amp;(*p)-&gt;next; *p = format; format-&gt;next = NULL;&#125; 注册协议处理器的函数是 ffurl_register_protocol() 。 12345678910int ffurl_register_protocol(URLProtocol *protocol)&#123; URLProtocol **p; p = &amp;first_protocol; while (*p) p = &amp;(*p)-&gt;next; *p = protocol; protocol-&gt;next = NULL; return 0;&#125; avcodec_register_all()ffmpeg注册编解码器等的函数 avcodec_register_all()（注意不是 av_register_all()，那是注册所有东西的）。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用编解码器等。 其实注册编解码器和注册复用器解复用器道理是差不多的，重复的内容不再多说。 123456789101112131415161718// 编码器的注册是：REGISTER_ENCODER (X,x); REGISTER_ENCODER (LJPEG, ljpeg);// 解码器的注册是：REGISTER_DECODER (X,x); REGISTER_DECODER (H264, h264);// 既包含编码器有包含解码器的注册是：REGISTER_ENCDEC (X,x); REGISTER_ENCDEC (BMP, bmp);// 此外还有几种注册：// Parser：REGISTER_PARSER (X,x); REGISTER_PARSER (H264, h264);// BSF（bitstream filters，比特流滤镜，有一个常用：h264_mp4toannexb）：REGISTER_BSF (X,x); REGISTER_BSF (H264_MP4TOANNEXB, h264_mp4toannexb);// HWACCEL（hardware accelerators，硬件加速器）：REGISTER_HWACCEL (X,x); REGISTER_HWACCEL (H264_DXVA2, h264_dxva2); 我们来看一下宏的定义，这里以编解码器为例： 1234567#define REGISTER_ENCODER(X,x) &#123; \ extern AVCodec ff_##x##_encoder; \ if(CONFIG_##X##_ENCODER) avcodec_register(&amp;ff_##x##_encoder); &#125;#define REGISTER_DECODER(X,x) &#123; \ extern AVCodec ff_##x##_decoder; \ if(CONFIG_##X##_DECODER) avcodec_register(&amp;ff_##x##_decoder); &#125;#define REGISTER_ENCDEC(X,x) REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x) 在这里，我发现其实编码器和解码器用的注册函数都是一样的：avcodec_register() 以 REGISTER_DECODER (H264, h264) 为例，就是等效于 12extern AVCodec ff_h264_decoder; if(CONFIG_H264_DECODER) avcodec_register(&amp;ff_h264_decoder); 下面看一下 avcodec_register() 的源代码： 123456789101112131415//注册所有的AVCodecvoid avcodec_register(AVCodec *codec)&#123; AVCodec **p; //初始化 avcodec_init(); //从第一个开始 p = &amp;first_avcodec; while (*p != NULL) p = &amp;(*p)-&gt;next; *p = codec; codec-&gt;next = NULL; if (codec-&gt;init_static_data) codec-&gt;init_static_data(codec);&#125; 这段代码是比较容易理解的。首先先提一点，first_avcdec 是就是 AVCodec 链表的头部地址，是一个全局静态变量，定义如下： 12/* encoder management */static AVCodec *first_avcodec = NULL; 由此我们可以分析出avcodec_register()的含义，一句话概括就是：遍历链表并把当前的AVCodec加到链表的尾部。同理，Parser，BSF（bitstream filters，比特流滤镜），HWACCEL（hardware accelerators，硬件加速器）的注册方式都是类似的。不再详述。 下面贴出它的原代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449#include "avcodec.h"// 硬件加速#define REGISTER_HWACCEL(X,x) &#123; \ extern AVHWAccel ff_##x##_hwaccel; \ if(CONFIG_##X##_HWACCEL) av_register_hwaccel(&amp;ff_##x##_hwaccel); &#125; #define REGISTER_ENCODER(X,x) &#123; \ extern AVCodec ff_##x##_encoder; \ if(CONFIG_##X##_ENCODER) avcodec_register(&amp;ff_##x##_encoder); &#125;// 定义的宏？宏的速度会快一点？注册AVCodec// extern AVCodec ff_##x##_decoder;// 注意：extern 表明全局唯一// 在h264中，对应的就是 ff_h264_decoder// 由此可见 AVCodecParser 的名字是固定的#define REGISTER_DECODER(X,x) &#123; \ extern AVCodec ff_##x##_decoder; \ if(CONFIG_##X##_DECODER) avcodec_register(&amp;ff_##x##_decoder); &#125;#define REGISTER_ENCDEC(X,x) REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x)// 定义的宏？宏的速度会快一点？注册AVCodecParser// extern AVCodecParser ff_##x##_parser;// 在h264中，对应的就是ff_h264_parser// 由此可见AVCodecParser的名字是固定的#define REGISTER_PARSER(X,x) &#123; \ extern AVCodecParser ff_##x##_parser; \ if(CONFIG_##X##_PARSER) av_register_codec_parser(&amp;ff_##x##_parser); &#125;#define REGISTER_BSF(X,x) &#123; \ extern AVBitStreamFilter ff_##x##_bsf; \ if(CONFIG_##X##_BSF) av_register_bitstream_filter(&amp;ff_##x##_bsf); &#125; void avcodec_register_all(void)&#123; static int initialized; if (initialized) return; initialized = 1; /* hardware accelerators */ REGISTER_HWACCEL (H263_VAAPI, h263_vaapi); REGISTER_HWACCEL (H264_DXVA2, h264_dxva2); REGISTER_HWACCEL (H264_VAAPI, h264_vaapi); REGISTER_HWACCEL (H264_VDA, h264_vda); REGISTER_HWACCEL (MPEG1_VDPAU, mpeg1_vdpau); REGISTER_HWACCEL (MPEG2_DXVA2, mpeg2_dxva2); REGISTER_HWACCEL (MPEG2_VAAPI, mpeg2_vaapi); REGISTER_HWACCEL (MPEG2_VDPAU, mpeg2_vdpau); REGISTER_HWACCEL (MPEG4_VAAPI, mpeg4_vaapi); REGISTER_HWACCEL (VC1_DXVA2, vc1_dxva2); REGISTER_HWACCEL (VC1_VAAPI, vc1_vaapi); REGISTER_HWACCEL (WMV3_DXVA2, wmv3_dxva2); REGISTER_HWACCEL (WMV3_VAAPI, wmv3_vaapi); /* video codecs */ REGISTER_ENCODER (A64MULTI, a64multi); REGISTER_ENCODER (A64MULTI5, a64multi5); REGISTER_DECODER (AASC, aasc); REGISTER_ENCDEC (AMV, amv); REGISTER_DECODER (ANM, anm); REGISTER_DECODER (ANSI, ansi); REGISTER_ENCDEC (ASV1, asv1); REGISTER_ENCDEC (ASV2, asv2); REGISTER_DECODER (AURA, aura); REGISTER_DECODER (AURA2, aura2); REGISTER_ENCDEC (AVRP, avrp); REGISTER_DECODER (AVS, avs); REGISTER_DECODER (BETHSOFTVID, bethsoftvid); REGISTER_DECODER (BFI, bfi); REGISTER_DECODER (BINK, bink); REGISTER_ENCDEC (BMP, bmp); REGISTER_DECODER (BMV_VIDEO, bmv_video); REGISTER_DECODER (C93, c93); REGISTER_DECODER (CAVS, cavs); REGISTER_DECODER (CDGRAPHICS, cdgraphics); REGISTER_DECODER (CINEPAK, cinepak); REGISTER_ENCDEC (CLJR, cljr); REGISTER_DECODER (CSCD, cscd); REGISTER_DECODER (CYUV, cyuv); REGISTER_DECODER (DFA, dfa); REGISTER_DECODER (DIRAC, dirac); REGISTER_ENCDEC (DNXHD, dnxhd); REGISTER_ENCDEC (DPX, dpx); REGISTER_DECODER (DSICINVIDEO, dsicinvideo); REGISTER_ENCDEC (DVVIDEO, dvvideo); REGISTER_DECODER (DXA, dxa); REGISTER_DECODER (DXTORY, dxtory); REGISTER_DECODER (EACMV, eacmv); REGISTER_DECODER (EAMAD, eamad); REGISTER_DECODER (EATGQ, eatgq); REGISTER_DECODER (EATGV, eatgv); REGISTER_DECODER (EATQI, eatqi); REGISTER_DECODER (EIGHTBPS, eightbps); REGISTER_DECODER (EIGHTSVX_EXP, eightsvx_exp); REGISTER_DECODER (EIGHTSVX_FIB, eightsvx_fib); REGISTER_DECODER (ESCAPE124, escape124); REGISTER_DECODER (ESCAPE130, escape130); REGISTER_ENCDEC (FFV1, ffv1); REGISTER_ENCDEC (FFVHUFF, ffvhuff); REGISTER_ENCDEC (FLASHSV, flashsv); REGISTER_ENCDEC (FLASHSV2, flashsv2); REGISTER_DECODER (FLIC, flic); REGISTER_ENCDEC (FLV, flv); REGISTER_DECODER (FOURXM, fourxm); REGISTER_DECODER (FRAPS, fraps); REGISTER_DECODER (FRWU, frwu); REGISTER_ENCDEC (GIF, gif); REGISTER_ENCDEC (H261, h261); REGISTER_ENCDEC (H263, h263); REGISTER_DECODER (H263I, h263i); REGISTER_ENCODER (H263P, h263p); REGISTER_DECODER (H264, h264); REGISTER_DECODER (H264_CRYSTALHD, h264_crystalhd); REGISTER_DECODER (H264_VDPAU, h264_vdpau); REGISTER_ENCDEC (HUFFYUV, huffyuv); REGISTER_DECODER (IDCIN, idcin); REGISTER_DECODER (IFF_BYTERUN1, iff_byterun1); REGISTER_DECODER (IFF_ILBM, iff_ilbm); REGISTER_DECODER (INDEO2, indeo2); REGISTER_DECODER (INDEO3, indeo3); REGISTER_DECODER (INDEO4, indeo4); REGISTER_DECODER (INDEO5, indeo5); REGISTER_DECODER (INTERPLAY_VIDEO, interplay_video); REGISTER_ENCDEC (JPEG2000, jpeg2000); REGISTER_ENCDEC (JPEGLS, jpegls); REGISTER_DECODER (JV, jv); REGISTER_DECODER (KGV1, kgv1); REGISTER_DECODER (KMVC, kmvc); REGISTER_DECODER (LAGARITH, lagarith); REGISTER_ENCODER (LJPEG, ljpeg); REGISTER_DECODER (LOCO, loco); REGISTER_DECODER (MDEC, mdec); REGISTER_DECODER (MIMIC, mimic); REGISTER_ENCDEC (MJPEG, mjpeg); REGISTER_DECODER (MJPEGB, mjpegb); REGISTER_DECODER (MMVIDEO, mmvideo); REGISTER_DECODER (MOTIONPIXELS, motionpixels); REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc); REGISTER_ENCDEC (MPEG1VIDEO, mpeg1video); REGISTER_ENCDEC (MPEG2VIDEO, mpeg2video); REGISTER_ENCDEC (MPEG4, mpeg4); REGISTER_DECODER (MPEG4_CRYSTALHD, mpeg4_crystalhd); REGISTER_DECODER (MPEG4_VDPAU, mpeg4_vdpau); REGISTER_DECODER (MPEGVIDEO, mpegvideo); REGISTER_DECODER (MPEG_VDPAU, mpeg_vdpau); REGISTER_DECODER (MPEG1_VDPAU, mpeg1_vdpau); REGISTER_DECODER (MPEG2_CRYSTALHD, mpeg2_crystalhd); REGISTER_DECODER (MSMPEG4_CRYSTALHD, msmpeg4_crystalhd); REGISTER_DECODER (MSMPEG4V1, msmpeg4v1); REGISTER_ENCDEC (MSMPEG4V2, msmpeg4v2); REGISTER_ENCDEC (MSMPEG4V3, msmpeg4v3); REGISTER_DECODER (MSRLE, msrle); REGISTER_ENCDEC (MSVIDEO1, msvideo1); REGISTER_DECODER (MSZH, mszh); REGISTER_DECODER (MXPEG, mxpeg); REGISTER_DECODER (NUV, nuv); REGISTER_ENCDEC (PAM, pam); REGISTER_ENCDEC (PBM, pbm); REGISTER_ENCDEC (PCX, pcx); REGISTER_ENCDEC (PGM, pgm); REGISTER_ENCDEC (PGMYUV, pgmyuv); REGISTER_DECODER (PICTOR, pictor); REGISTER_ENCDEC (PNG, png); REGISTER_ENCDEC (PPM, ppm); REGISTER_ENCDEC (PRORES, prores); REGISTER_DECODER (PRORES_LGPL, prores_lgpl); REGISTER_DECODER (PTX, ptx); REGISTER_DECODER (QDRAW, qdraw); REGISTER_DECODER (QPEG, qpeg); REGISTER_ENCDEC (QTRLE, qtrle); REGISTER_ENCDEC (R10K, r10k); REGISTER_ENCDEC (R210, r210); REGISTER_ENCDEC (RAWVIDEO, rawvideo); REGISTER_DECODER (RL2, rl2); REGISTER_ENCDEC (ROQ, roq); REGISTER_DECODER (RPZA, rpza); REGISTER_ENCDEC (RV10, rv10); REGISTER_ENCDEC (RV20, rv20); REGISTER_DECODER (RV30, rv30); REGISTER_DECODER (RV40, rv40); REGISTER_DECODER (S302M, s302m); REGISTER_ENCDEC (SGI, sgi); REGISTER_DECODER (SMACKER, smacker); REGISTER_DECODER (SMC, smc); REGISTER_ENCDEC (SNOW, snow); REGISTER_DECODER (SP5X, sp5x); REGISTER_DECODER (SUNRAST, sunrast); REGISTER_ENCDEC (SVQ1, svq1); REGISTER_DECODER (SVQ3, svq3); REGISTER_ENCDEC (TARGA, targa); REGISTER_DECODER (THEORA, theora); REGISTER_DECODER (THP, thp); REGISTER_DECODER (TIERTEXSEQVIDEO, tiertexseqvideo); REGISTER_ENCDEC (TIFF, tiff); REGISTER_DECODER (TMV, tmv); REGISTER_DECODER (TRUEMOTION1, truemotion1); REGISTER_DECODER (TRUEMOTION2, truemotion2); REGISTER_DECODER (TSCC, tscc); REGISTER_DECODER (TXD, txd); REGISTER_DECODER (ULTI, ulti); REGISTER_DECODER (UTVIDEO, utvideo); REGISTER_ENCDEC (V210, v210); REGISTER_DECODER (V210X, v210x); REGISTER_ENCDEC (V308, v308); REGISTER_ENCDEC (V410, v410); REGISTER_DECODER (VB, vb); REGISTER_DECODER (VBLE, vble); REGISTER_DECODER (VC1, vc1); REGISTER_DECODER (VC1_CRYSTALHD, vc1_crystalhd); REGISTER_DECODER (VC1_VDPAU, vc1_vdpau); REGISTER_DECODER (VC1IMAGE, vc1image); REGISTER_DECODER (VCR1, vcr1); REGISTER_DECODER (VMDVIDEO, vmdvideo); REGISTER_DECODER (VMNC, vmnc); REGISTER_DECODER (VP3, vp3); REGISTER_DECODER (VP5, vp5); REGISTER_DECODER (VP6, vp6); REGISTER_DECODER (VP6A, vp6a); REGISTER_DECODER (VP6F, vp6f); REGISTER_DECODER (VP8, vp8); REGISTER_DECODER (VQA, vqa); REGISTER_ENCDEC (WMV1, wmv1); REGISTER_ENCDEC (WMV2, wmv2); REGISTER_DECODER (WMV3, wmv3); REGISTER_DECODER (WMV3_CRYSTALHD, wmv3_crystalhd); REGISTER_DECODER (WMV3_VDPAU, wmv3_vdpau); REGISTER_DECODER (WMV3IMAGE, wmv3image); REGISTER_DECODER (WNV1, wnv1); REGISTER_DECODER (XAN_WC3, xan_wc3); REGISTER_DECODER (XAN_WC4, xan_wc4); REGISTER_DECODER (XL, xl); REGISTER_ENCDEC (XWD, xwd); REGISTER_ENCDEC (Y41P, y41p); REGISTER_DECODER (YOP, yop); REGISTER_ENCDEC (YUV4, yuv4); REGISTER_ENCDEC (ZLIB, zlib); REGISTER_ENCDEC (ZMBV, zmbv); /* audio codecs */ REGISTER_ENCDEC (AAC, aac); REGISTER_DECODER (AAC_LATM, aac_latm); REGISTER_ENCDEC (AC3, ac3); REGISTER_ENCODER (AC3_FIXED, ac3_fixed); REGISTER_ENCDEC (ALAC, alac); REGISTER_DECODER (ALS, als); REGISTER_DECODER (AMRNB, amrnb); REGISTER_DECODER (AMRWB, amrwb); REGISTER_DECODER (APE, ape); REGISTER_DECODER (ATRAC1, atrac1); REGISTER_DECODER (ATRAC3, atrac3); REGISTER_DECODER (BINKAUDIO_DCT, binkaudio_dct); REGISTER_DECODER (BINKAUDIO_RDFT, binkaudio_rdft); REGISTER_DECODER (BMV_AUDIO, bmv_audio); REGISTER_DECODER (COOK, cook); REGISTER_ENCDEC (DCA, dca); REGISTER_DECODER (DSICINAUDIO, dsicinaudio); REGISTER_ENCDEC (EAC3, eac3); REGISTER_DECODER (FFWAVESYNTH, ffwavesynth); REGISTER_ENCDEC (FLAC, flac); REGISTER_ENCDEC (G723_1, g723_1); REGISTER_DECODER (G729, g729); REGISTER_DECODER (GSM, gsm); REGISTER_DECODER (GSM_MS, gsm_ms); REGISTER_DECODER (IMC, imc); REGISTER_DECODER (MACE3, mace3); REGISTER_DECODER (MACE6, mace6); REGISTER_DECODER (MLP, mlp); REGISTER_DECODER (MP1, mp1); REGISTER_DECODER (MP1FLOAT, mp1float); REGISTER_ENCDEC (MP2, mp2); REGISTER_DECODER (MP2FLOAT, mp2float); REGISTER_DECODER (MP3, mp3); REGISTER_DECODER (MP3FLOAT, mp3float); REGISTER_DECODER (MP3ADU, mp3adu); REGISTER_DECODER (MP3ADUFLOAT, mp3adufloat); REGISTER_DECODER (MP3ON4, mp3on4); REGISTER_DECODER (MP3ON4FLOAT, mp3on4float); REGISTER_DECODER (MPC7, mpc7); REGISTER_DECODER (MPC8, mpc8); REGISTER_ENCDEC (NELLYMOSER, nellymoser); REGISTER_DECODER (QCELP, qcelp); REGISTER_DECODER (QDM2, qdm2); REGISTER_ENCDEC (RA_144, ra_144); REGISTER_DECODER (RA_288, ra_288); REGISTER_DECODER (SHORTEN, shorten); REGISTER_DECODER (SIPR, sipr); REGISTER_DECODER (SMACKAUD, smackaud); REGISTER_ENCDEC (SONIC, sonic); REGISTER_ENCODER (SONIC_LS, sonic_ls); REGISTER_DECODER (TRUEHD, truehd); REGISTER_DECODER (TRUESPEECH, truespeech); REGISTER_DECODER (TTA, tta); REGISTER_DECODER (TWINVQ, twinvq); REGISTER_DECODER (VMDAUDIO, vmdaudio); REGISTER_ENCDEC (VORBIS, vorbis); REGISTER_DECODER (WAVPACK, wavpack); REGISTER_DECODER (WMALOSSLESS, wmalossless); REGISTER_DECODER (WMAPRO, wmapro); REGISTER_ENCDEC (WMAV1, wmav1); REGISTER_ENCDEC (WMAV2, wmav2); REGISTER_DECODER (WMAVOICE, wmavoice); REGISTER_DECODER (WS_SND1, ws_snd1); /* PCM codecs */ REGISTER_ENCDEC (PCM_ALAW, pcm_alaw); REGISTER_DECODER (PCM_BLURAY, pcm_bluray); REGISTER_DECODER (PCM_DVD, pcm_dvd); REGISTER_ENCDEC (PCM_F32BE, pcm_f32be); REGISTER_ENCDEC (PCM_F32LE, pcm_f32le); REGISTER_ENCDEC (PCM_F64BE, pcm_f64be); REGISTER_ENCDEC (PCM_F64LE, pcm_f64le); REGISTER_DECODER (PCM_LXF, pcm_lxf); REGISTER_ENCDEC (PCM_MULAW, pcm_mulaw); REGISTER_ENCDEC (PCM_S8, pcm_s8); REGISTER_DECODER (PCM_S8_PLANAR, pcm_s8_planar); REGISTER_ENCDEC (PCM_S16BE, pcm_s16be); REGISTER_ENCDEC (PCM_S16LE, pcm_s16le); REGISTER_DECODER (PCM_S16LE_PLANAR, pcm_s16le_planar); REGISTER_ENCDEC (PCM_S24BE, pcm_s24be); REGISTER_ENCDEC (PCM_S24DAUD, pcm_s24daud); REGISTER_ENCDEC (PCM_S24LE, pcm_s24le); REGISTER_ENCDEC (PCM_S32BE, pcm_s32be); REGISTER_ENCDEC (PCM_S32LE, pcm_s32le); REGISTER_ENCDEC (PCM_U8, pcm_u8); REGISTER_ENCDEC (PCM_U16BE, pcm_u16be); REGISTER_ENCDEC (PCM_U16LE, pcm_u16le); REGISTER_ENCDEC (PCM_U24BE, pcm_u24be); REGISTER_ENCDEC (PCM_U24LE, pcm_u24le); REGISTER_ENCDEC (PCM_U32BE, pcm_u32be); REGISTER_ENCDEC (PCM_U32LE, pcm_u32le); REGISTER_DECODER (PCM_ZORK , pcm_zork); /* DPCM codecs */ REGISTER_DECODER (INTERPLAY_DPCM, interplay_dpcm); REGISTER_ENCDEC (ROQ_DPCM, roq_dpcm); REGISTER_DECODER (SOL_DPCM, sol_dpcm); REGISTER_DECODER (XAN_DPCM, xan_dpcm); /* ADPCM codecs */ REGISTER_DECODER (ADPCM_4XM, adpcm_4xm); REGISTER_ENCDEC (ADPCM_ADX, adpcm_adx); REGISTER_DECODER (ADPCM_CT, adpcm_ct); REGISTER_DECODER (ADPCM_EA, adpcm_ea); REGISTER_DECODER (ADPCM_EA_MAXIS_XA, adpcm_ea_maxis_xa); REGISTER_DECODER (ADPCM_EA_R1, adpcm_ea_r1); REGISTER_DECODER (ADPCM_EA_R2, adpcm_ea_r2); REGISTER_DECODER (ADPCM_EA_R3, adpcm_ea_r3); REGISTER_DECODER (ADPCM_EA_XAS, adpcm_ea_xas); REGISTER_ENCDEC (ADPCM_G722, adpcm_g722); REGISTER_ENCDEC (ADPCM_G726, adpcm_g726); REGISTER_DECODER (ADPCM_IMA_AMV, adpcm_ima_amv); REGISTER_DECODER (ADPCM_IMA_APC, adpcm_ima_apc); REGISTER_DECODER (ADPCM_IMA_DK3, adpcm_ima_dk3); REGISTER_DECODER (ADPCM_IMA_DK4, adpcm_ima_dk4); REGISTER_DECODER (ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs); REGISTER_DECODER (ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead); REGISTER_DECODER (ADPCM_IMA_ISS, adpcm_ima_iss); REGISTER_ENCDEC (ADPCM_IMA_QT, adpcm_ima_qt); REGISTER_DECODER (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg); REGISTER_ENCDEC (ADPCM_IMA_WAV, adpcm_ima_wav); REGISTER_DECODER (ADPCM_IMA_WS, adpcm_ima_ws); REGISTER_ENCDEC (ADPCM_MS, adpcm_ms); REGISTER_DECODER (ADPCM_SBPRO_2, adpcm_sbpro_2); REGISTER_DECODER (ADPCM_SBPRO_3, adpcm_sbpro_3); REGISTER_DECODER (ADPCM_SBPRO_4, adpcm_sbpro_4); REGISTER_ENCDEC (ADPCM_SWF, adpcm_swf); REGISTER_DECODER (ADPCM_THP, adpcm_thp); REGISTER_DECODER (ADPCM_XA, adpcm_xa); REGISTER_ENCDEC (ADPCM_YAMAHA, adpcm_yamaha); /* subtitles */ REGISTER_ENCDEC (ASS, ass); REGISTER_ENCDEC (DVBSUB, dvbsub); REGISTER_ENCDEC (DVDSUB, dvdsub); REGISTER_DECODER (PGSSUB, pgssub); REGISTER_ENCDEC (SRT, srt); REGISTER_ENCDEC (XSUB, xsub); /* external libraries */ REGISTER_ENCODER (LIBAACPLUS, libaacplus); REGISTER_DECODER (LIBCELT, libcelt); REGISTER_ENCDEC (LIBDIRAC, libdirac); REGISTER_ENCODER (LIBFAAC, libfaac); REGISTER_ENCDEC (LIBGSM, libgsm); REGISTER_ENCDEC (LIBGSM_MS, libgsm_ms); REGISTER_ENCODER (LIBMP3LAME, libmp3lame); REGISTER_ENCDEC (LIBOPENCORE_AMRNB, libopencore_amrnb); REGISTER_DECODER (LIBOPENCORE_AMRWB, libopencore_amrwb); REGISTER_ENCDEC (LIBOPENJPEG, libopenjpeg); REGISTER_ENCDEC (LIBSCHROEDINGER, libschroedinger); REGISTER_ENCDEC (LIBSPEEX, libspeex); REGISTER_DECODER (LIBSTAGEFRIGHT_H264, libstagefright_h264); REGISTER_ENCODER (LIBTHEORA, libtheora); REGISTER_DECODER (LIBUTVIDEO, libutvideo); REGISTER_ENCODER (LIBVO_AACENC, libvo_aacenc); REGISTER_ENCODER (LIBVO_AMRWBENC, libvo_amrwbenc); REGISTER_ENCODER (LIBVORBIS, libvorbis); REGISTER_ENCDEC (LIBVPX, libvpx); REGISTER_ENCODER (LIBX264, libx264); REGISTER_ENCODER (LIBX264RGB, libx264rgb); REGISTER_ENCODER (LIBXAVS, libxavs); REGISTER_ENCODER (LIBXVID, libxvid); /* text */ REGISTER_DECODER (BINTEXT, bintext); REGISTER_DECODER (XBIN, xbin); REGISTER_DECODER (IDF, idf); /* parsers */ REGISTER_PARSER (AAC, aac); REGISTER_PARSER (AAC_LATM, aac_latm); REGISTER_PARSER (AC3, ac3); REGISTER_PARSER (ADX, adx); REGISTER_PARSER (CAVSVIDEO, cavsvideo); REGISTER_PARSER (DCA, dca); REGISTER_PARSER (DIRAC, dirac); REGISTER_PARSER (DNXHD, dnxhd); REGISTER_PARSER (DVBSUB, dvbsub); REGISTER_PARSER (DVDSUB, dvdsub); REGISTER_PARSER (FLAC, flac); REGISTER_PARSER (GSM, gsm); REGISTER_PARSER (H261, h261); REGISTER_PARSER (H263, h263); REGISTER_PARSER (H264, h264); REGISTER_PARSER (MJPEG, mjpeg); REGISTER_PARSER (MLP, mlp); REGISTER_PARSER (MPEG4VIDEO, mpeg4video); REGISTER_PARSER (MPEGAUDIO, mpegaudio); REGISTER_PARSER (MPEGVIDEO, mpegvideo); REGISTER_PARSER (PNM, pnm); REGISTER_PARSER (RV30, rv30); REGISTER_PARSER (RV40, rv40); REGISTER_PARSER (VC1, vc1); REGISTER_PARSER (VP3, vp3); REGISTER_PARSER (VP8, vp8); /* bitstream filters */ REGISTER_BSF (AAC_ADTSTOASC, aac_adtstoasc); REGISTER_BSF (CHOMP, chomp); REGISTER_BSF (DUMP_EXTRADATA, dump_extradata); REGISTER_BSF (H264_MP4TOANNEXB, h264_mp4toannexb); REGISTER_BSF (IMX_DUMP_HEADER, imx_dump_header); REGISTER_BSF (MJPEG2JPEG, mjpeg2jpeg); REGISTER_BSF (MJPEGA_DUMP_HEADER, mjpega_dump_header); REGISTER_BSF (MP3_HEADER_COMPRESS, mp3_header_compress); REGISTER_BSF (MP3_HEADER_DECOMPRESS, mp3_header_decompress); REGISTER_BSF (MOV2TEXTSUB, mov2textsub); REGISTER_BSF (NOISE, noise); REGISTER_BSF (REMOVE_EXTRADATA, remove_extradata); REGISTER_BSF (TEXT2MOVSUB, text2movsub);&#125; 整个代码的过程就是首先确定是不是已经初始化过了（initialized），如果没有，就注册，注册，注册…直到完成所有注册。 函数的调用关系图如下图所示。av_register_all() 调用了 avcodec_register_all()。因此如果调用过 av_register_all() 的话就不需要再调用 avcodec_register_all() 了。 下面附上硬件加速器，编码器/解码器，parser，Bitstream Filter的注册代码。 硬件加速器注册函数是 av_register_hwaccel()。 12345678void av_register_hwaccel(AVHWAccel *hwaccel)&#123; AVHWAccel **p = last_hwaccel; hwaccel-&gt;next = NULL; while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, hwaccel)) p = &amp;(*p)-&gt;next; last_hwaccel = &amp;hwaccel-&gt;next;&#125; 编解码器注册函数是 avcodec_register()。 1234567891011121314av_cold void avcodec_register(AVCodec *codec)&#123; AVCodec **p; avcodec_init(); p = last_avcodec; codec-&gt;next = NULL; while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, codec)) p = &amp;(*p)-&gt;next; last_avcodec = &amp;codec-&gt;next; if (codec-&gt;init_static_data) codec-&gt;init_static_data(codec);&#125; parser注册函数是 av_register_codec_parser()。 123456void av_register_codec_parser(AVCodecParser *parser)&#123; do &#123; parser-&gt;next = av_first_parser; &#125; while (parser-&gt;next != avpriv_atomic_ptr_cas((void * volatile *)&amp;av_first_parser, parser-&gt;next, parser));&#125; Bitstream Filter注册函数是 av_register_bitstream_filter()。 123456void av_register_bitstream_filter(AVBitStreamFilter *bsf)&#123; do &#123; bsf-&gt;next = first_bitstream_filter; &#125; while(bsf-&gt;next != avpriv_atomic_ptr_cas((void * volatile *)&amp;first_bitstream_filter, bsf-&gt;next, bsf));&#125; 后两个函数中的 avpriv_atomic_ptr_cas() 定义如下。 12345678void *avpriv_atomic_ptr_cas(void * volatile *ptr, void *oldval, void *newval)&#123; if (*ptr == oldval) &#123; *ptr = newval; return oldval; &#125; return *ptr;&#125;]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC（三）]]></title>
    <url>%2F2019%2F05%2F17%2FWebRTC%2Fwebrtc-03%2F</url>
    <content type="text"><![CDATA[WebRTC 环境搭建简单的 https server 服务搭建 1234567891011# 二进制安装$ apt/brew/yum install nodejs$ apt/brew/yum install npm$ apt-cache search xxx # 查看源上相关软件版本信息# 源码安装# 下载 Nodejs 源码 http://nodejs.cn/download/$ wget -c https://npm.taobao.org/mirrors/node/v10.16.0/node-v10.16.0.tar.gz# 生成 Makefile$ ./configure --prefix=/usr/local/nodejs$ make -j 4 &amp;&amp; sudo make install 123456789101112131415# server.js'use strict'var https = require('https');var fs = require('fs');var options = &#123; key : fs.readFileSync('./cert/server.key'), cert : fs.readFileSync('./cert/server.pem')&#125;var app = https.createServer(options, function(req, res)&#123; res.writeHead(200, &#123;'Content-Type':'text/plain'&#125;); res.end('Hello Mr.Miaow!\n');&#125;).listen(443, '0.0.0.0'); 启动 server 123$ node server.js$ nohub node server.js &amp;$ forever start server.js # nmp install forever -g 真正的Web服务 引用 express 模块 引入 serve-index 模块 指定发布目录 1$ npm install express serve-index web server 服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105'use strict'var http = require('http');var https = require('https');var fs = require('fs');var express = require('express');var serverIndex = require('serve-index');var socketIo = require('socket.io');var log4js = require('log4js');var USERCOUNT = 3;log4js.configure(&#123; appenders: &#123; file: &#123; type: 'file', filename: 'app.log', layout: &#123; type: 'pattern', pattern: '%r %p - %m', &#125; &#125; &#125;, categories: &#123; default: &#123; appenders: ['file'], level: 'debug' &#125; &#125;&#125;);var logger = log4js.getLogger();var app = express();app.use(serverIndex('./public'));app.use(express.static('./public'));var http_server = http.createServer(app);http_server.listen(80, '0.0.0.0');var options = &#123; key : fs.readFileSync('./cert/server.key'), cert : fs.readFileSync('./cert/server.pem')&#125;var https_server = https.createServer(options, app);// bind socket.io with https_servervar io = socketIo.listen(https_server);var sockio = socketIo.listen(http_server);// connectionio.sockets.on('connection', (socket)=&gt;&#123; logger.log('Socket.io connection ...'); socket.on('message', (room, data)=&gt;&#123; socket.to(room).emit('message', room, data); //除自己之外 &#125;); // 该函数应该加锁 socket.on('join', (room)=&gt;&#123; socket.join(room); var myRoom = io.sockets.adapter.rooms[room]; var users = (myRoom) ? Object.keys(myRoom.sockets).length : 0; logger.debug('The number of user in room is:' + users); // 在这里可以控制进入房间的人数,现在一个房间最多 2个人 // 为了便于客户端控制，如果是多人的话，应该将目前房间里 // 人的个数当做数据下发下去。 if(users &lt; USERCOUNT) &#123; socket.emit('joined', room, socket.id); // 谁来了发给谁 if (users &gt; 1) &#123; socket.to(room).emit('otherjoin', room, socket.id);//除自己之外 &#125; &#125;else &#123; socket.leave(room); socket.emit('full', room, socket.id); &#125; //socket.emit('joined', room, socket.id); // 发给自己 //socket.to(room).emit('joined', room, socket.id); // 发给除自己之外的房间内的所有人 //io.in(room).emit('joined', room, socket.id); // 发给房间内所有人 //socket.broadcast.emit('joined', room, socket.id); // 发给除自己之外，这个节点上的所有人 &#125;); socket.on('leave', (room)=&gt;&#123; var myRoom = io.sockets.adapter.rooms[room]; var users = (myRoom) ? Object.keys(myRoom.sockets).length : 0; // users - 1 logger.debug('The number of user in room is:' + (users-1)); socket.leave(room); socket.to(room).emit('bye', room, socket.id); //房间内所有人,除自己外 socket.emit('leaved', room, socket.id); // 给自己发leaved //socket.to(room).emit('leaved', room, socket.id); // 除自己之外 //io.in(room).emit('leaved', room, socket.id); // 房间内所有人 //socket.broadcast.emit('leaved', room, socket.id); // 除自己，全部站点 &#125;)&#125;)https_server.listen(443, '0.0.0.0'); 项目目录结构图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$ tree -I "node_modules|WebRTCAndroid" .├── app.log├── cert│ ├── server.key│ └── server.pem├── package-lock.json├── public│ ├── bandwidth│ │ ├── css│ │ │ └── main.css│ │ ├── js│ │ │ └── main.js│ │ └── room.html│ ├── chat│ │ ├── css│ │ │ └── main.css│ │ ├── index.html│ │ └── js│ │ ├── main.js│ │ └── third_party│ │ └── graph.js│ ├── chatroom│ │ ├── css│ │ │ └── main.css│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── device│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── getstats│ │ ├── css│ │ │ └── main.css│ │ ├── js│ │ │ ├── main.js│ │ │ └── third_party│ │ │ └── graph.js│ │ └── room.html│ ├── mediaDisplay│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── mediastream│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── mediastream_bak│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── only_audio│ │ ├── index.html│ │ └── js│ │ └── client.js│ ├── peerConnection│ │ ├── css│ │ │ └── main.css│ │ ├── index.html│ │ └── js│ │ └── main.js│ ├── realyPeerConnection│ │ ├── css│ │ │ └── main.css│ │ ├── js│ │ │ └── main.js│ │ └── room.html│ ├── sendfile│ │ ├── css│ │ │ └── main.css│ │ ├── index.html│ │ └── js│ │ ├── main_bw.js│ │ └── third_party│ │ └── graph.js│ └── testCreateOffer│ ├── index.html│ └── js│ └── main.js├── server-bak-01.js└── server.js38 directories, 42 files PeerConnectionroom.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;head&gt; &lt;title&gt;WebRTC PeerConnection&lt;/title&gt; &lt;link href="./css/main.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div&gt; &lt;button id="connserver"&gt;Connect Sig Server&lt;/button&gt; &lt;button id="leave"&gt;Leave&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;input id="shareDesk" type="checkbox"/&gt;&lt;label for="shareDesk"&gt;Share Desktop&lt;/label&gt; &lt;/div&gt; &lt;div id="preview"&gt; &lt;div&gt; &lt;h2&gt;Local:&lt;/h2&gt; &lt;video id="localvideo" autoplay playsinline muted&gt;&lt;/video&gt; &lt;h2&gt;Offer SDP:&lt;/h2&gt; &lt;textarea id="offer"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;Remote:&lt;/h2&gt; &lt;video id="remotevideo" autoplay playsinline&gt;&lt;/video&gt; &lt;h2&gt;Answer SDP:&lt;/h2&gt; &lt;textarea id="answer"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt; &lt;script src="https://webrtc.github.io/adapter/adapter-latest.js"&gt;&lt;/script&gt; &lt;script src="./js/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */button &#123; margin: 0 20px 25px 0; vertical-align: top; width: 134px;&#125;textarea &#123; color: #444; font-size: 0.9em; font-weight: 300; height: 20.0em; padding: 5px; width: calc(100% - 10px);&#125;div#getUserMedia &#123; padding: 0 0 8px 0;&#125;div.input &#123; display: inline-block; margin: 0 4px 0 0; vertical-align: top; width: 310px;&#125;div.input &gt; div &#123; margin: 0 0 20px 0; vertical-align: top;&#125;div.output &#123; background-color: #eee; display: inline-block; font-family: 'Inconsolata', 'Courier New', monospace; font-size: 0.9em; padding: 10px 10px 10px 25px; position: relative; top: 10px; white-space: pre; width: 270px;&#125;div#preview &#123; border-bottom: 1px solid #eee; margin: 0 0 1em 0; padding: 0 0 0.5em 0;&#125;div#preview &gt; div &#123; display: inline-block; vertical-align: top; width: calc(50% - 12px);&#125;section#statistics div &#123; display: inline-block; font-family: 'Inconsolata', 'Courier New', monospace; vertical-align: top; width: 308px;&#125;section#statistics div#senderStats &#123; margin: 0 20px 0 0;&#125;section#constraints &gt; div &#123; margin: 0 0 20px 0;&#125;h2 &#123; margin: 0 0 1em 0;&#125;section#constraints label &#123; display: inline-block; width: 156px;&#125;section &#123; margin: 0 0 20px 0; padding: 0 0 15px 0;&#125;video &#123; background: #222; margin: 0 0 0 0; --width: 100%; width: var(--width); height: 225px;&#125;@media screen and (max-width: 720px) &#123; button &#123; font-weight: 500; height: 56px; line-height: 1.3em; width: 90px; &#125; div#getUserMedia &#123; padding: 0 0 40px 0; &#125; section#statistics div &#123; width: calc(50% - 14px); &#125;&#125; main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397'use strict'var localVideo = document.querySelector('video#localvideo');var remoteVideo = document.querySelector('video#remotevideo');var btnConn = document.querySelector('button#connserver');var btnLeave = document.querySelector('button#leave');var offer = document.querySelector('textarea#offer');var answer = document.querySelector('textarea#answer');var shareDeskBox = document.querySelector('input#shareDesk');var pcConfig = &#123; 'iceServers': [&#123; 'urls': 'turn:stun.al.learningrtc.cn:3478', 'credential': "mypasswd", 'username': "garrylea" &#125;]&#125;;var localStream = null;var remoteStream = null;var roomid = '123123';var socket = null;var offerdesc = null;var state = 'init';var pc = null;// 以下代码是从网上找的//================================================================================//如果返回的是false说明当前操作系统是手机端，如果返回的是true则说明当前的操作系统是电脑端function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = ["Android", "iPhone","SymbianOS", "Windows Phone","iPad", "iPod"]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;//如果返回true 则说明是Android false是iosfunction is_android() &#123; var u = navigator.userAgent, app = navigator.appVersion; var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; //g var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 if (isAndroid) &#123; //这个是安卓操作系统 return true; &#125; if (isIOS) &#123; //这个是ios操作系统 return false; &#125;&#125;//获取url参数function getQueryVariable(variable)&#123; var query = window.location.search.substring(1); var vars = query.split("&amp;"); for (var i=0;i&lt;vars.length;i++) &#123; var pair = vars[i].split("="); if(pair[0] == variable)&#123;return pair[1];&#125; &#125; return(false);&#125;//=======================================================================function getRemoteStream(e)&#123; remoteStream = e.streams[0]; remoteVideo.srcObject = e.streams[0];&#125;function sendMessage(roomid, data)&#123; console.log('Send p2p message: roomid=' + roomid + ' data=' + data); if(!socket) &#123; console.log('SendMessage is error: socket is null'); &#125; socket.emit('message', roomid, data);&#125;function createPeerConnection()&#123; //如果是多人的话，在这里要创建一个新的连接. //新创建好的要放到一个map表中。 //key=userid, value=peerconnection console.log('Create RTCPeerConnection ...'); if(!pc) &#123; pc = new RTCPeerConnection(pcConfig); pc.onicecandidate = (e)=&gt; &#123; // 监听 candidate 事件 if(e.candidate) &#123; console.log('Find an new candidate:', e.candidate); sendMessage(roomid, &#123; type: 'candidate', label: e.candidate.sdpMLineIndex, id: e.candidate.sdpMid, candidate: e.candidate.candidate &#125;); &#125; else &#123; console.log('This is the end candidate'); &#125; &#125; pc.ontrack = getRemoteStream; // 监听 轨 事件 &#125; else &#123; console.log('The pc have be created!'); &#125; //if(localStream) &#123; // localStream.getTracks().forEach((track)=&gt;&#123; // pc.addTrack(track); // &#125;); //&#125; return;&#125;//绑定永远与 peerconnection在一起，//所以没必要再单独做成一个函数function bindTracks()&#123; console.log('Bind tracks into RTCPeerConnection!'); if( pc === null || pc === undefined) &#123; console.error('pc is null or undefined!'); return; &#125; if(localStream === null || localStream === undefined) &#123; console.error('localstream is null or undefined!'); return; &#125; //add all track into peer connection localStream.getTracks().forEach((track)=&gt;&#123; pc.addTrack(track, localStream); &#125;);&#125;function getOffer(desc)&#123; pc.setLocalDescription(desc); offer.value = desc.sdp; offerdesc = desc; sendMessage(roomid, offerdesc);&#125;function handleOfferError(err) &#123; console.error('Failed to get Offer!', err);&#125;function call()&#123; console.log('call ...'); if(state === 'joined_conn') &#123; if(pc) &#123; // 控制接受远端视频和音频参数配置 var options = &#123; // 还有两个参数 1. icerestart 2. 静音检测 offerToRecieveVideo: 1, offerToRecieveAudio: 1 &#125; pc.createOffer(options) .then(getOffer).catch(handleOfferError); &#125; &#125;&#125;function closeLocalMedia()&#123; if(localStream &amp;&amp; localStream.getTracks()) &#123; localStream.getTracks().forEach((track)=&gt;&#123; track.stop(); &#125;); &#125; localStream = null;&#125;function hangup()&#123; console.log('Close RTCPeerConnection ...'); if(pc) &#123; offerdesc = null; pc.close(); pc = null; &#125;&#125;function getAnswer(desc)&#123; pc.setLocalDescription(desc); // 通知本地手机candidate answer.value = desc.sdp; sendMessage(roomid, desc);&#125;function handleAnswerError(err)&#123; console.error('Failed to get Answer!', err);&#125;function conn()&#123; socket = io.connect(); // 与信令服务器进行连接 // 注册 接收服务端的 消息函数 socket.on('joined', (roomid, id)=&gt; &#123; // id -&gt; 用户id btnConn.disabled = true; btnLeave.disabled = false; state = 'joined'; createPeerConnection(); bindTracks(); console.log('Receive joined message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('otherjoin', (roomid, id)=&gt; &#123; if(state === 'joined_unbind') &#123; createPeerConnection(); bindTracks(); &#125; state = 'joined_conn'; // 媒体协商 call(); console.log('Receive otherjoin message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('full', (roomid, id)=&gt; &#123; state = 'leaved'; hangup(); //socket.disconnect(); closeLocalMedia(); btnConn.disabled = false; btnLeave.disabled = true; console.log('Receive full message: roomid=' + roomid + ' userid=' + id + ' state=' + state); alert('The room is full!'); &#125;); socket.on('leaved', (roomid, id)=&gt; &#123; state = 'leaved'; socket.disconnect(); // 关闭连接 btnConn.disabled = false; btnLeave.disabled = true; console.log('Receive leaved message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('bye', (roomid, id)=&gt; &#123; //state = 'created'; //当是多人通话时，应该带上当前房间的用户数 //如果当前房间用户不小于 2, 则不用修改状态 //并且，关闭的应该是对应用户的peerconnection //在客户端应该维护一张peerconnection表，它是 //一个key:value的格式，key=userid, value=peerconnection state = 'joined_unbind'; hangup(); offer.value = ''; answer.value = ''; console.log('Receive bye message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('disconnect', (socket) =&gt; &#123; if(!(state === 'leaved'))&#123; hangup(); closeLocalMedia(); &#125; state = 'leaved'; console.log('Receive disconnect message! roomid=' + roomid); &#125;); // 端对端的消息 socket.on('message', (roomid, data)=&gt; &#123; // 媒体协商 if(data === null || data === undefined)&#123; console.error('The message is invalid!'); return; &#125; if(data.hasOwnProperty('type') &amp;&amp; data.type === 'offer') &#123; offer.value = data.sdp; pc.setRemoteDescription(new RTCSessionDescription(data)); // data 发送前是一个对象，发送过来的时候已经变成了一个文本，所以这儿要转换 pc.createAnswer() .then(getAnswer).catch(handleAnswerError); &#125; else if(data.hasOwnProperty('type') &amp;&amp; data.type == 'answer')&#123; answer.value = data.sdp; pc.setRemoteDescription(new RTCSessionDescription(data)); &#125; else if (data.hasOwnProperty('type') &amp;&amp; data.type === 'candidate')&#123; var candidate = new RTCIceCandidate(&#123; sdpMLineIndex: data.label, candidate: data.candidate &#125;); pc.addIceCandidate(candidate); // 将 candidate 添加到本端 &#125; else &#123; console.error('The message is invalid!', data); &#125; console.log('Receive client message: roomid=' + roomid + ' data=' + data); &#125;); //roomid = getQueryVariable('room'); socket.emit('join', roomid); // 发送消息，加入 roomid 这个房间 return;&#125;function getMediaStream(stream)&#123; if(localStream)&#123; stream.getAudioTracks().forEach((track)=&gt;&#123; localStream.addTrack(track); stream.removeTrack(track); &#125;); &#125;else&#123; localStream = stream; &#125; localVideo.srcObject = localStream; // 本地视频在视频标签中显示 //这个函数的位置特别重要， //一定要放到getMediaStream之后再调用 //否则就会出现绑定失败的情况 //setup connection conn(); // 信令功能实现&#125;function handleError(err)&#123; console.error('Failed to get Media Stream: ', err.name);&#125;function getDeskStream(stream)&#123; localStream = stream;&#125;function handleShareDeskError(err)&#123; console.error('Failed to get Media Stream!', err);&#125;function shareDesk()&#123; if(IsPC())&#123; navigator.mediaDevices.getDisplayMedia(&#123;video: true&#125;) .then(getDeskStream).catch(handleShareDeskError); return true; &#125; return false;&#125;function start()&#123; if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) &#123; console.error('The getUserMedia is not supported!'); return; &#125; else &#123; var constraints; if(shareDeskBox.checked &amp;&amp; shareDesk()) &#123; constraints = &#123; video: false, audio: &#123; echoCancellation: true, noiseSuppression: true, autoGainControl: true &#125; &#125; &#125; else &#123; constraints = &#123; video: true, audio: &#123; echoCancellation: true, // 回音消除 noiseSuppression: true, // 降噪？ autoGainControl: true // &#125; &#125; &#125; navigator.mediaDevices.getUserMedia(constraints) .then(getMediaStream).catch(handleError); &#125;&#125;function connSignalServer()&#123; // 开启本地视频 start(); return true;&#125;function closePeerConnection()&#123; console.log('Close RTCPeerConnection ...'); if(pc) &#123; pc.close(); pc = null; &#125;&#125;function leave()&#123; if(socket) &#123; socket.emit('leave', roomid); &#125; hangup(); closeLocalMedia(); offer.value = ''; answer.value = ''; btnConn.disabled = false; btnLeave.disabled = true;&#125;btnConn.onclick = connSignalServer;btnLeave.onclick = leave; Chatmain.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/* * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */button &#123; margin: 10px 20px 25px 0; vertical-align: top; width: 134px;&#125;table &#123; margin: 200px (50% - 100) 0 0; &#125;textarea &#123; color: #444; font-size: 0.9em; font-weight: 300; height: 20.0em; padding: 5px; width: calc(100% - 10px);&#125;div#getUserMedia &#123; padding: 0 0 8px 0;&#125;div.input &#123; display: inline-block; margin: 0 4px 0 0; vertical-align: top; width: 310px;&#125;div.input &gt; div &#123; margin: 0 0 20px 0; vertical-align: top;&#125;div.output &#123; background-color: #eee; display: inline-block; font-family: 'Inconsolata', 'Courier New', monospace; font-size: 0.9em; padding: 10px 10px 10px 25px; position: relative; top: 10px; white-space: pre; width: 270px;&#125;div.label &#123; display: inline-block; font-weight: 400; width: 120px;&#125;div.graph-container &#123; background-color: #ccc; float: left; margin: 0.2em; width: calc(50%-1em);&#125;div#preview &#123; border-bottom: 1px solid #eee; margin: 0 0 1em 0; padding: 0 0 0.5em 0;&#125;div#preview &gt; div &#123; display: inline-block; vertical-align: top; width: calc(50% - 12px);&#125;section#statistics div &#123; display: inline-block; font-family: 'Inconsolata', 'Courier New', monospace; vertical-align: top; width: 308px;&#125;section#statistics div#senderStats &#123; margin: 0 20px 0 0;&#125;section#constraints &gt; div &#123; margin: 0 0 20px 0;&#125;h2 &#123; margin: 0 0 1em 0;&#125;section#constraints label &#123; display: inline-block; width: 156px;&#125;section &#123; margin: 0 0 20px 0; padding: 0 0 15px 0;&#125;video &#123; background: #222; margin: 0 0 0 0; --width: 100%; width: var(--width); height: 225px;&#125;@media screen and (max-width: 720px) &#123; button &#123; font-weight: 500; height: 56px; line-height: 1.3em; width: 90px; &#125; div#getUserMedia &#123; padding: 0 0 40px 0; &#125; section#statistics div &#123; width: calc(50% - 14px); &#125;&#125; Chat.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;html&gt; &lt;head&gt; &lt;title&gt;WebRTC PeerConnection&lt;/title&gt; &lt;link href="./css/main.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div&gt; &lt;button id="connserver"&gt;Connect Sig Server&lt;/button&gt; &lt;button id="leave"&gt;Leave&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;BandWidth:&lt;/label&gt; &lt;select id="bandwidth" disabled&gt; &lt;option value="unlimited" selected&gt;unlimited&lt;/option&gt; &lt;option value="2000"&gt;2000&lt;/option&gt; &lt;option value="1000"&gt;1000&lt;/option&gt; &lt;option value="500"&gt;500&lt;/option&gt; &lt;option value="250"&gt;250&lt;/option&gt; &lt;option value="125"&gt;125&lt;/option&gt; &lt;/select&gt; kbps &lt;/div&gt; &lt;div&gt; &lt;input id="shareDesk" type="checkbox"/&gt;&lt;label for="shareDesk"&gt;Share Desktop&lt;/label&gt; &lt;/div&gt; &lt;div id="preview"&gt; &lt;div&gt; &lt;h2&gt;Local:&lt;/h2&gt; &lt;video id="localvideo" autoplay playsinline muted&gt;&lt;/video&gt; &lt;h2&gt;Remote:&lt;/h2&gt; &lt;video id="remotevideo" autoplay playsinline&gt;&lt;/video&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;Chat:&lt;/h2&gt; &lt;textarea id="chat" disabled&gt;&lt;/textarea&gt; &lt;textarea id="sendtxt" disabled&gt;&lt;/textarea&gt; &lt;button id="send"&gt;Send&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="preview"&gt; &lt;div class="graph-container" id="bitrateGraph"&gt; &lt;div&gt;Bitrate&lt;/div&gt; &lt;canvas id="bitrateCanvas"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div class="graph-container" id="packetGraph"&gt; &lt;div&gt;Packets sent per second&lt;/div&gt; &lt;canvas id="packetCanvas"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/third_party/graph.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt; &lt;script src="https://webrtc.github.io/adapter/adapter-latest.js"&gt;&lt;/script&gt; &lt;script src="./js/Chat.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Chat.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571'use strict'var localVideo = document.querySelector('video#localvideo');var remoteVideo = document.querySelector('video#remotevideo');var btnConn = document.querySelector('button#connserver');var btnLeave = document.querySelector('button#leave');var optBW = document.querySelector('select#bandwidth');var shareDeskBox = document.querySelector('input#shareDesk');var chat = document.querySelector('textarea#chat');var sendTxt = document.querySelector('textarea#sendtxt');var btnSend = document.querySelector('button#send');var pcConfig = &#123; 'iceServers': [&#123; 'urls': 'turn:stun.al.learningrtc.cn:3478', 'credential': "mypasswd", 'username': "garrylea" &#125;]&#125;;var bitrateGraph;var bitrateSeries;var packetGraph;var packetSeries;var lastReportResult;var localStream = null;var remoteStream = null;var roomid = '123123';var socket = null;var offerdesc = null;var state = 'init';var pc = null;var dc = null;// 以下代码是从网上找的//=========================================================================================//如果返回的是false说明当前操作系统是手机端，如果返回的是true则说明当前的操作系统是电脑端function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = ["Android", "iPhone","SymbianOS", "Windows Phone","iPad", "iPod"]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;//如果返回true 则说明是Android false是iosfunction is_android() &#123; var u = navigator.userAgent, app = navigator.appVersion; var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; //g var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 if (isAndroid) &#123; //这个是安卓操作系统 return true; &#125; if (isIOS) &#123; //这个是ios操作系统 return false; &#125;&#125;//获取url参数function getQueryVariable(variable)&#123; var query = window.location.search.substring(1); var vars = query.split("&amp;"); for (var i=0;i&lt;vars.length;i++) &#123; var pair = vars[i].split("="); if(pair[0] == variable)&#123;return pair[1];&#125; &#125; return(false);&#125;//=======================================================================function sendMessage(roomid, data)&#123; console.log('Send p2p message: roomid=' + roomid + ' data=' + data); if(!socket) &#123; console.log('SendMessage is error: socket is null'); &#125; socket.emit('message', roomid, data);&#125;function getOffer(desc)&#123; pc.setLocalDescription(desc); offerdesc = desc; sendMessage(roomid, offerdesc);&#125;function handleOfferError(err) &#123; console.error('Failed to get Offer!', err);&#125;function getAnswer(desc)&#123; pc.setLocalDescription(desc); optBW.disabled = false; sendMessage(roomid, desc);&#125;function handleAnswerError(err)&#123; console.error('Failed to get Answer!', err);&#125;function call()&#123; console.log('call ...'); if(state === 'joined_conn') &#123; if(pc) &#123; var options = &#123; offerToRecieveVideo: 1, offerToRecieveAudio: 1 &#125; pc.createOffer(options) .then(getOffer).catch(handleOfferError); &#125; &#125;&#125;function connSignalServer()&#123; // 开启本地视频 start(); return true;&#125;function receivemsg(e)&#123; var msg = e.data; if(msg) &#123; chat.value += '-&gt;' + msg + '\r\n'; &#125; else &#123; console.error('Received msg is null!'); &#125;&#125;function dataChannelStateChange() &#123; var readyState = dc.readyState; console.log('Send channel state is: ' + readyState); if (readyState === 'open') &#123; sendTxt.disabled = false; send.disabled = false; &#125; else &#123; sendTxt.disabled = true; send.disabled = true; &#125;&#125;function conn()&#123; socket = io.connect(); socket.on('joined', (roomid, id) =&gt; &#123; state = 'joined' //如果是多人的话，第一个人不该在这里创建peerConnection //都等到收到一个otherjoin时再创建 //所以，在这个消息里应该带当前房间的用户数 // //create conn and bind media track createPeerConnection(); bindTracks(); btnConn.disabled = true; btnLeave.disabled = false; console.log('receive joined message, state=', state); &#125;); socket.on('otherjoin', (roomid, id) =&gt; &#123; //如果是多人的话，每上来一个人都要创建一个新的 peerConnection // if(state === 'joined_unbind')&#123; createPeerConnection(); bindTracks(); &#125; //create data channel for transporting non-audio/video data dc = pc.createDataChannel('chatchannel'); dc.onmessage = receivemsg; dc.onopen = dataChannelStateChange; dc.onclose = dataChannelStateChange; state = 'joined_conn'; // 媒体协商 call(); console.log('Receive otherjoin message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('full', (roomid, id)=&gt; &#123; state = 'leaved'; hangup(); closeLocalMedia(); btnConn.disabled = false; btnLeave.disabled = true; console.log('Receive full message: roomid=' + roomid + ' userid=' + id + ' state=' + state); alert('The room is full!'); &#125;); socket.on('leaved', (roomid, id)=&gt; &#123; state = 'leaved'; socket.disconnect(); btnConn.disabled = false; btnLeave.disabled = true; console.log('Receive leaved message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('bye', (roomid, id)=&gt; &#123; //state = 'created'; //当是多人通话时，应该带上当前房间的用户数 //如果当前房间用户不小于 2, 则不用修改状态 //并且，关闭的应该是对应用户的peerconnection //在客户端应该维护一张peerconnection表，它是 //一个key:value的格式，key=userid, value=peerconnection state = 'joined_unbind'; hangup(); console.log('Receive bye message: roomid=' + roomid + ' userid=' + id + ' state=' + state); &#125;); socket.on('disconnect', (socket) =&gt; &#123; if(!(state === 'leaved'))&#123; hangup(); closeLocalMedia(); &#125; state = 'leaved'; console.log('Receive disconnect message! roomid=' + roomid); &#125;); socket.on('message', (roomid, data)=&gt; &#123; // 媒体协商 if(data === null || data === undefined)&#123; console.error('The message is invalid!'); return; &#125; if(data.hasOwnProperty('type') &amp;&amp; data.type === 'offer') &#123; pc.setRemoteDescription(new RTCSessionDescription(data)); pc.createAnswer() .then(getAnswer).catch(handleAnswerError); &#125; else if(data.hasOwnProperty('type') &amp;&amp; data.type == 'answer')&#123; optBW.disabled = false; pc.setRemoteDescription(new RTCSessionDescription(data)); &#125; else if (data.hasOwnProperty('type') &amp;&amp; data.type === 'candidate')&#123; var candidate = new RTCIceCandidate(&#123; sdpMLineIndex: data.label, candidate: data.candidate &#125;); pc.addIceCandidate(candidate); &#125; else &#123; console.error('The message is invalid!', data); &#125; console.log('Receive client message: roomid=' + roomid + ' data=' + data); &#125;); //roomid = getQueryVariable('room'); socket.emit('join', roomid); return;&#125;function getMediaStream(stream)&#123; if(localStream)&#123; stream.getAudioTracks().forEach((track)=&gt;&#123; localStream.addTrack(track); stream.removeTrack(track); &#125;); &#125;else&#123; localStream = stream; &#125; localVideo.srcObject = localStream; //这个函数的位置特别重要， //一定要放到getMediaStream之后再调用 //否则就会出现绑定失败的情况 // //setup connection conn(); bitrateSeries = new TimelineDataSeries(); bitrateGraph = new TimelineGraphView('bitrateGraph', 'bitrateCanvas'); bitrateGraph.updateEndDate(); packetSeries = new TimelineDataSeries(); packetGraph = new TimelineGraphView('packetGraph', 'packetCanvas'); packetGraph.updateEndDate();&#125;function handleError(err)&#123; console.error('Failed to get Media Stream: ', err.name);&#125;function getDeskStream(stream)&#123; localStream = stream;&#125;function handleShareDeskError(err)&#123; console.error('Failed to get Media Stream!', err);&#125;function shareDesk()&#123; if(IsPC())&#123; navigator.mediaDevices.getDisplayMedia(&#123;video: true&#125;) .then(getDeskStream).catch(handleShareDeskError); return true; &#125; return false;&#125;function start()&#123; if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) &#123; console.error('The getUserMedia is not supported!'); return; &#125; else &#123; var constraints; if(shareDeskBox.checked &amp;&amp; shareDesk()) &#123; constraints = &#123; video: false, audio: &#123; echoCancellation: true, noiseSuppression: true, autoGainControl: true &#125; &#125; &#125; else &#123; constraints = &#123; video: true, audio: &#123; echoCancellation: true, noiseSuppression: true, autoGainControl: true &#125; &#125; &#125; navigator.mediaDevices.getUserMedia(constraints) .then(getMediaStream).catch(handleError); &#125;&#125;function closeLocalMedia()&#123; if(localStream &amp;&amp; localStream.getTracks()) &#123; localStream.getTracks().forEach((track)=&gt;&#123; track.stop(); &#125;); &#125; localStream = null;&#125;function leave()&#123; if(socket) &#123; socket.emit('leave', '123123'); &#125; hangup(); closeLocalMedia(); btnConn.disabled = false; btnLeave.disabled = true;&#125;function getRemoteStream(e)&#123; remoteStream = e.streams[0]; remoteVideo.srcObject = e.streams[0];&#125;function createPeerConnection()&#123; //如果是多人的话，在这里要创建一个新的连接. //新创建好的要放到一个map表中。 //key=userid, value=peerconnection console.log('Create RTCPeerConnection ...'); if(!pc) &#123; pc = new RTCPeerConnection(pcConfig); pc.onicecandidate = (e)=&gt; &#123; if(e.candidate) &#123; console.log('Find an new candidate:', e.candidate); sendMessage(roomid, &#123; type: 'candidate', label: event.candidate.sdpMLineIndex, id: event.candidate.sdpMid, candidate: event.candidate.candidate &#125;); &#125; else &#123; console.log('This is the end candidate'); &#125; &#125; pc.ondatachannel = e=&gt; &#123; if(!dc)&#123; dc = e.channel; dc.onmessage = receivemsg; dc.onopen = dataChannelStateChange; dc.onclose = dataChannelStateChange; &#125; &#125; pc.ontrack = getRemoteStream; &#125; else &#123; console.log('The pc have be created!'); &#125; //if(localStream) &#123; // localStream.getTracks().forEach((track)=&gt;&#123; // pc.addTrack(track); // &#125;); //&#125; return;&#125;//绑定永远与 peerconnection在一起，//所以没必要再单独做成一个函数function bindTracks()&#123; console.log('Bind tracks into RTCPeerConnection!'); if( pc === null || pc === undefined) &#123; console.error('pc is null or undefined!'); return; &#125; if(localStream === null || localStream === undefined) &#123; console.error('localstream is null or undefined!'); return; &#125; //add all track into peer connection localStream.getTracks().forEach((track)=&gt;&#123; pc.addTrack(track, localStream); &#125;);&#125;function hangup()&#123; console.log('Close RTCPeerConnection ...'); if(pc) &#123; offerdesc = null; pc.close(); pc = null; &#125;&#125;function closePeerConnection()&#123; console.log('Close RTCPeerConnection ...'); if(pc) &#123; pc.close(); pc = null; &#125;&#125;function change_bw()&#123; bandwidth.disabled = true; var bw = optBW.options[optBW.selectedIndex].value; var vsender = null; var senders = pc.getSenders(); senders.forEach( sender =&gt; &#123; if(sender &amp;&amp; sender.track.kind === 'video') &#123; vsender = sender; &#125; &#125;); var parameters = vsender.getParameters(); if(!parameters.encodings) &#123; return; &#125; if(bw === 'unlimited') &#123; return; &#125; parameters.encodings[0].maxBitrate = bw * 1000; vsender.setParameters(parameters) .then(()=&gt;&#123; bandwidth.disabled = false; console.log('Successed to set parameters!'); &#125;) .catch(err =&gt;&#123; console.error(err); &#125;); return;&#125;// query getStats every second// 设置定时器，每秒处理一次，因为计算包的流量和发送包的次数都是1秒为单位的window.setInterval(() =&gt; &#123; if (!pc) &#123; return; &#125; var vsender = null; var senders = pc.getSenders(); senders.forEach( sender =&gt; &#123; if(sender &amp;&amp; sender.track.kind === 'video') &#123; vsender = sender; &#125; &#125;); //const vsender = pc.getSenders()[0]; if (!vsender) &#123; return; &#125; vsender.getStats() .then(reports =&gt; &#123; reports.forEach(report =&gt; &#123; let bytes; let packets; if (report.type === 'outbound-rtp') &#123; if (report.isRemote) &#123; return; &#125; const curTs = report.timestamp; bytes = report.bytesSent; packets = report.packetsSent; if (lastReportResult &amp;&amp; lastReportResult.has(report.id)) &#123; // calculate bitrate const bitrate = 8 * (bytes - lastReportResult.get(report.id).bytesSent) / (curTs - lastReportResult.get(report.id).timestamp); // append to chart bitrateSeries.addPoint(curTs, bitrate); bitrateGraph.setDataSeries([bitrateSeries]); bitrateGraph.updateEndDate(); // calculate number of packets and append to chart packetSeries.addPoint(curTs, packets - lastReportResult.get(report.id).packetsSent); packetGraph.setDataSeries([packetSeries]); packetGraph.updateEndDate(); &#125; &#125; &#125;); lastReportResult = reports; &#125;) .catch(err =&gt;&#123; console.log(err); &#125;);&#125;, 1000);function sendText()&#123; var data = sendTxt.value; if(data) &#123; dc.send(data); &#125; sendTxt.value = ''; chat.value += '&lt;-' + data + '\r\n';&#125;btnConn.onclick = connSignalServer;btnLeave.onclick = leave;optBW.onchange = change_bw;btnSend.onclick = sendText;]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC（二）]]></title>
    <url>%2F2019%2F05%2F15%2FWebRTC%2Fwebrtc-02%2F</url>
    <content type="text"><![CDATA[端对端1V1传输基本流程媒体能力协商过程WebRTC 端对端连接： RTCPeerConnection： 基本格式 1pc = new RTCPeerConnection([configuration]); RTCPeerConnection 方法分类： 媒体协商 Stream/Track 传输相关方法 统计相关方法 媒体协商方法： createOffer createAnswer setLocakDescription setRemoteDescription createOffer： 基本格式 1aPromise = myPeerConnection.createOffer([options]); createAnswer： 基本格式 1aPromise = myPeerConnection.createAnswer([options]); setLocakDescription： 基本格式 1aPromise = myPc.setLocalDescription(sessionDescription); setRemoteDescription： 基本格式 1aPromise = myPc.setRemoteDescription(sessionDescription); Track 方法： addTrack removeTrack addTrack： 基本格式 1rtpSender = myPc.addTrack(track, stream...); Parameters removeTrack： 基本格式 1myPc.remoteTrack(rtpSender); 重要事件： onnegotiationneeded - 协商的时候触发这个事件 onicecandidate - 当收到 ICE 候选者的时候触发这个事件 1:1 连接的基本流程 A 与 B 通信，大的方向分为三部分： 媒体协商部分 ICE 候选者的交换、连接、检测部分 媒体数据流的通信部分 【实战】WebRTC 视频传输TODO 【实战】显示通讯双方的 SDP 内容TODO WebRTC核心之SDP详解【协议规范】SDP 规范SDP 规范： 会话层 媒体层 可以把会话层看做树根，媒体层看成树干。 会话层： 会话的名称与目的 会话的存活时间 会话中包含多个媒体信息 SDP 媒体信息： 媒体格式 传输协议 传输 IP 和 端口 媒体负载类型 SDP 格式： 由多个 &lt;type&gt;=&lt;value&gt; 组成 一个会话级描述 多个媒体级描述 SDP 结构： Session Description Time Description Media Description 【协议规范】WebRTC 中的 SDP 【详解】WebRTC 中 Offer_Answer SDPSDP报文内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100v=0o=- 2584450093346841581 2 IN IP4 127.0.0.1s=-t=0 0a=group:BUNDLE audio video dataa=msid-semantic: WMS 616cfbb1-33a3-4d8c-8275-a199d6005549m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126c=IN IP4 0.0.0.0 a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:sXJ3a=ice-pwd:yEclOTrLg1gEubBFefOqtmyVa=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79a=setup:actpassa=mid:audioa=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-levela=sendrecva=rtcp-muxa=rtpmap:111 opus/48000/2a=rtcp-fb:111 transport-cca=fmtp:111 minptime=10;useinbandfec=1a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:110 telephone-event/48000a=rtpmap:112 telephone-event/32000a=rtpmap:113 telephone-event/16000a=rtpmap:126 telephone-event/8000a=ssrc:120276603 cname:iSkJ2vn5cYYubTvea=ssrc:120276603 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 1da3d329-7399-4fe9-b20f-69606bebd363a=ssrc:120276603 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:120276603 label:1da3d329-7399-4fe9-b20f-69606bebd363m=video 9 UDP/TLS/RTP/SAVPF 96 98 100 102 127 97 99 101 125c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:sXJ3a=ice-pwd:yEclOTrLg1gEubBFefOqtmyVa=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79a=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:4 urn:3gpp:video-orientationa=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=sendrecva=rtcp-muxa=rtcp-rsizea=rtpmap:96 VP8/90000a=rtcp-fb:96 ccm fira=rtcp-fb:96 nacka=rtcp-fb:96 nack plia=rtcp-fb:96 goog-remba=rtcp-fb:96 transport-cca=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:98 VP9/90000a=rtcp-fb:98 ccm fira=rtcp-fb:98 nacka=rtcp-fb:98 nack plia=rtcp-fb:98 goog-remba=rtcp-fb:98 transport-cca=rtpmap:100 H264/90000a=rtcp-fb:100 ccm fira=rtcp-fb:100 nacka=rtcp-fb:100 nack plia=rtcp-fb:100 goog-remba=rtcp-fb:100 transport-cca=fmtp:100 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01fa=rtpmap:102 red/90000a=rtpmap:127 ulpfec/90000a=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:99 rtx/90000a=fmtp:99 apt=98a=rtpmap:101 rtx/90000a=fmtp:101 apt=100a=rtpmap:125 rtx/90000a=fmtp:125 apt=102a=ssrc-group:FID 2580761338 611523443a=ssrc:2580761338 cname:iSkJ2vn5cYYubTvea=ssrc:2580761338 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:2580761338 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:2580761338 label:bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:611523443 cname:iSkJ2vn5cYYubTvea=ssrc:611523443 msid:616cfbb1-33a3-4d8c-8275-a199d6005549 bf270496-a23e-47b5-b901-ef23096cd961a=ssrc:611523443 mslabel:616cfbb1-33a3-4d8c-8275-a199d6005549a=ssrc:611523443 label:bf270496-a23e-47b5-b901-ef23096cd961m=application 9 DTLS/SCTP 5000c=IN IP4 0.0.0.0a=ice-ufrag:sXJ3a=ice-pwd:yEclOTrLg1gEubBFefOqtmyVa=fingerprint:sha-256 22:14:B5:AF:66:12:C7:C7:8D:EF:4B:DE:40:25:ED:5D:8F:17:54:DD:88:33:C0:13:2E:FD:1A:FA:7E:7A:1B:79a=setup:actpassa=mid:dataa=sctpmap:5000 webrtc-datachannel 1024 实现1V1音视频实时互动直播系统STUN/TURN 服务器搭建 webrtc进阶-信令篇-之三：信令、stun、turn、ice webRTC+coturn穿透服务器的安装与搭建 WebRTC的信令服务器Collider和Turn服务器搭建 AppRTC(WebRTC)服务器搭建 coTurn Download Address：https://github.com/coturn/coturn ICE 测试地址：https://webrtc.github.io/samples coturn 编译安装 12345$ git clone https://github.com/coturn/coturn $ cd coturn $ ./configure $ make $ make install 安装sqlite 1$ sudo atp-get install sqlite 生成认证用户 123$ turnadmin -A –u 用户名 -r beijing -p 密码 $ turnadmin -a –u 用户名 -r beijing -p 密码 # A 是添加管理员 然后生成md5码 1$ turnadmin -k –u 用户名 -r beijing -p 密码 生成证书 12$ openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes # 一路回车就好 创建配置文件 1234567891011121314151617181920$ vi /usr/local/etc/turnserver.conf listening-device=eth1 relay-device=eth1 listening-port=3478 listening-ip=YOU_IP listening-ip=YOU_IP2 # (stun 需要两个公网ip，只有一个公网ip只能作文turn服务器) tls-listening-port=5349 lt-cred-mech min-port=59000 max-port=65000 realm=beijing no-loopback-peers no-multicast-peers mobility no-cli cert=/etc/turn_server_cert.pem pkey=/etc/turn_server_pkey.pem fingerprint stale-nonce=600 启动 coturn 12# 启动 turn server$ turnserver -c /usr/local/coturn/etc/turnserver.conf 【参数介绍】再论 RTCPeerConnection 直播系统中的信令及其逻辑关系【实战】真正的音视频传输 客户端信令消息： join 加入房间 leave 离开房间 message 端到端消息 端到端信令消息： Offer 消息 Answer 消息 Candidate 消息 服务端信令消息： joined 已加入房间 otherjoin 其它用户加入房间 full 房间人数已满 leaved 已离开房间 bye 对方离开房间 实现 1：1 音视频实时互动信令服务器信令服务器改造 TODO 再论CreateOffer CreateOffer 实战： 接收远端音频 接收远端视频 静音检测 ICE restart WebRTC 客户端状态机及处理逻辑直播客户端的实现： WebRTC 客户端的实现 共享远程桌面 WebRTC核心之RTP媒体控制与数据统计RTPPReceiver 发送器RTP Media 里边两个重要的类：Receiver 和 Sender Receiver 和 Sender 共有的三个属性 getParameters - 编解码器相关参数 getSynchronizationSources - 获取共享源（同步源），每一个媒体流都一个唯一的共享源 getContributingSources - 贡献来源，最主要用于混音和混频的情况 getStats - 获取统计信息 getCapabilities - 获取协商后的媒体能力 RTPSender 发送器 RTCRtpTransceiver 可以同时处理 sender 和 receiver 传输速率的控制 chrome WebRTC 状态查询地址：chrome://webrtc-internals 【实战】WebRTC统计信息TODO WebRTC非音视频数据传输传输非音视频数据基础知识 ordered - udp包不保证包是有序的（传输非音视频数据的时候包是否是按顺序到达的），webrtc传输音视频的时候使用的是udp，webrtc在upd之上做了一层协议可以保证消息是按顺序到达（底层如果包是乱序的对包进行排序） maxPacketLifeTime/maxRetransmits - 包存活时间（包最大的存活时间/最大的传输次数），这两个参数是二选一，不能同时使用 negotiated - 协商，在创建datachannel的时候可以进行协商 onmessage - 当对方有数据过来的时候触发 onopen - 当创建好 datachannel 的时候触发 SCTP - stream control transport 流控 configurable - 可配置的 Reliability：可靠性 Delivery：可达性 Transmission：传输方式 Flow control：流控 Congestion control：拥塞控制 端到端文本聊天TODO 文件实时传输 WebRTC实时数据传输网络协议详解 浅析TCP字节流与UDP数据报的区别 tcp是流式传输， 这是什么意思？ 假设A给B通过TCP发了200字节， 然后又发了300字节， 此时B调用recv（设置预期接受1000个字节）， 那么请问B实际接受到多少字节？ 根据我们之前讲得tcp粘包特性，可知， B端调用一次recv, 接受到的是500字节。 所谓流式传输， 说白了， 就是管道中的水， 第一次给你发了200斤的水， 第二次给你发了300斤的水， 然后你在对端取的时候， 这200斤和300斤的水， 已经粘在一起了， 无法直接分割， 没有界限了。 udp是数据报传输， 什么意思？ 假设A给B通过udp发了200字节， 然后又发了300字节， 此时B调用recvfrom（设置预期接受1000个字节）， 那么请问B实际接受到多少字节？ 写了个程序测了一下， 发现B调用recvfrom接收到的是200自己， 另外的300字节必须再次调用recvfrom来接收。 所谓的数据报传输， 说白了， 就有消息和消息之间有天然的分割， 对端接收的时候， 不会出现粘包。 发10次， 就需要10次来接收。 【协议规范】RTP-SRTP协议头详解 DTLS - 证书检测，加密算法协商 contributing source - 贡献源，CC - 表示贡献者一共有多少个（最多可以表示16个贡献者） RTP报文头中的SSRC和CSRC RTP/RTCP协议详解 RTP 有效负载(载荷)类型，RTP Payload Type 最大的 RTP 包包含的字节是1400多字节，压缩后的 H264 帧也能达到 1M 多。一般帧 封包 后的最后一个包 就是 M 位 timestamp - 同一个帧的所有封包的 timestamp 是相同的，并且 seq number 是连续的。H264 内部有封包的起始位和结束位，根据这些标识就可以将多个封包组成一个完整的帧 SSRC - SSRC的作用就是贡献者，视频和音频的SSRC是完全不相同的。同一个视频的SSRC有可能发生变化（产生冲突会发生变化，因为SSRC是随机数） CSRC - 贡献者 【协议规范】RTCP 中的 SR 与 RR 报文 SDES - 中最重要的一个字段是 cname FR - 请求关键帧 necho - 发现丢包重传 NTP - 不同源之间的同步，比如音频和视频之间的同步 CNAME - 对于webrtc来说这个字段基本上是不用SDES这个消息，因为在SDP中就有CNAME的描述，除非音频源或者视频源发生了中断（or中转）会重新生成SSRC，然后再进行重新绑定 【协议规范】DTSL wireshark 分析 rtp-rtcp 包TODO Android端与浏览器互通Android 与浏览器互通 WebRTCNative 开发逻辑 实战-权限申请-库的引入与界面 实战-通过 socket.io 实现信令收发 实战-Android 与浏览器互通创建 PeerConnection： 音视频数据采集 创建 PeerConnection 媒体能力协商： 协商媒体能力 Candidate 连通 视频渲染 iOS端与浏览器互通IOS权限获取 IOS引入WebRTC库 IOS端SocketIO的使用 IOS界面布局TODO IOS本地视频采集与展示TODO IOS端RTCPeerConnectionTODO IOS媒体协商 IOS远端视频渲染 课程总结 即时通信（IM）和实时通信（RTC）的区别即时通信（IM=Instant messaging）和实时通信（rtc=Real-time communication）都是一套网络通信系统，其本质都是对信息进行转发。其最大的不同点，是对信息传递的时间规定。二者的区别可以从以下几个方面： 场景 即时通信 常见场景包括文字聊天、语音消息发送、文件传输、音视频播放等。通俗的说，就是发短信。 实时通信 场景包括语音、视频电话会议、网络电话等。通俗的说，就是打电话。 要求 即时通讯 主要要求可靠，考核送达率。要是你发一条短信，结果丢了，对方没收到！你再也不相信短信了吧。 实时通信 主要要求低延时和接通率。 低延时：你打一通电话，每说一句话，对方得几秒钟才有回应，这电话你也讲不下去了吧。 接通率：你打电话，你这边听到接通了，实际上对方的手机毫无反应，这实际上就没接通。 技术环节 即时通信 消息发送和确认，【消息接入端、服务端消息逻辑处理，服务端消息缓存和存储，转发，服务端用户状态管理，心跳机制，消息发送端】、消息接收和确认。 实时通信 技术环节：采集、前处理、编码、【服务端接入、转发、服务端接入】、解码、播放和渲染。 这些技术环节重合的部分是：信息转发。 传输协议公共互联网上，最常用的通信协议有TCP、UDP。 TCP：Transmission Control Protocol，传输控制协议是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。有延迟不可控的特点。 UDP：User Data Protocol，用户数据报协议，是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。 存在丢包、抖动、延迟的特征。 即时通信系统为了保证连接的可靠性，最常用的是TCP协议或者类TCP连接协议。这类协议的特点是追求连接的可靠性，而造成了延迟的不可控性，超过2秒的延迟响应是常态，甚至几十分钟的延迟响应，而电信级的实时通信标准是400ms，而基于互联网的实时通信需要另辟蹊径，开创出新的传输解决方案。发短信，延迟几秒钟送达，对使用者影响不大。 实时通信，一般采用 UDP 作为基础传输协议。在设计低延时的实时通信服务时，UDP 表现要比 TCP 好得多。这是因为实时通信中，低时延比可靠性更重要。打电话，几秒的延迟是不能忍受的。 TCP协议封装了消息的重传机制，在丢包的情况下，采用TCP协议的应用程序几乎无法优化这个重传机制，来达到低时延的效果。特别是在移动互联网络中，超过30%丢包时，TCP 的延时可以到几十分钟, 超过 50%丢包时，甚至很容易断开。 在同样丢包30%的链路上，UDP还可以传输数据，TCP就无法进行实时通信了。 成本成本涉及到的环节有：服务端接入、存储和转发。 二者成本会产生差异的环节有： 从服务端接入方式来看，即时通信采用TCP协议来保证可靠性，可能会建立多个连接，相比无连接的UDP传输方式，这是一种昂贵的传输方式。实时通信可以基于UDP协议，与服务端建立灵活的、快速的接入机制。 存储方面，实时通信在服务端是实时转发，不会在服务端存储数据，而即时消息系统一般会将缓存转为存储数据，包括富媒体数据，会占用大量的存储空间，产生更多的存储成本。 从成本上来看，传输同样信息量的数据，基于TCP的即时通信方式，更侧重于可靠性，会优先采用多线机房的传输方式，成本比较高； 而基于UDP的实时通信方式，会优先选取最优路径进行传输数据，并可以动态调整传输路径，这样能够高效的利用带宽，提高传输效率，降低成本。 可用的解决方案 即时通信：XMPP，MQTT 实时通信：WebRTC、Tokbox 免费的 im 与 rtc 示例：https://github.com/starrtc/android-demo Reference JavaScript 是如何工作的:WebRTC 和对等网络的机制！ 深入理解WebRTC WebRTC架构简介 HTTPS证书生成原理和部署细节 SSL证书生成流程 Gradle官网 Gradle 包 Mac下AndroidStudio中手动配置Gradle WebRTC的拥塞控制和带宽策略 小议WebRTC拥塞控制算法：GCC介绍 ***详读webrtc的视频统计信息之延迟、抖动与丢包 socket.io 原理详解 socket.io 原理详解 音视频数据采集与控制 WebRTC音频引擎实现分析 WebRTC手记之本地音频采集 WebRTC音视频同步分析 webrtc数据接收、解码、渲染等接口调用流程图 WebRTC视频采集和编码过程 H264中4x4、8x8和16x16尺寸对应场景 NAT 穿越 ICE协议下NAT穿越的实现（STUN&amp;TURN） WebRTC中NAT穿透浅析 ICE 原理 （转）NAT与NAT穿越学习总结–ICE过程讲的不错 ICE 原理学习 媒体协商过程 完整WebRTC技术及应用概要 WebRTC SDP协议 WebRTC 中的 SDP 协议 网络处理与流程 WEBRTC 视频接收原理及流程 webrtc(11) 数据接收——总流程 WebRTC 是如何进行通信的，WebRCT 的三种网络结构 | 野狗 WebRTC 专栏 WebRTC 音视频引擎研究 – 整体架构分析 如何实现并规模高并发 即构自研WebRTC网关服务器架构实践 WebRTC、标准测试、大前端技术、实时网络质量……RTC2018帮你“划重点”！ 如何更好的利用网络 WebRTC 点对点直播 回音消除与降噪 WebRTC音频降噪使用 webrtc–AudioProcessing– 音频降噪的处理过程 PCM音频处理——使用WebRTC音频降噪模块与其他方式的对比 音频降噪在 58 直播中的研究与实现 单独编译和使用webrtc音频回声消除模块(附完整源码+测试音频文件) 借助Webrtc音频采集、降噪、回音消除、静音检测、编解码、播放等功能，剥离Webrtc自带的RTP传输协议，使用私有的协议进行传输。从而实现自己的实时语音聊天功能。 webrtc学习2-音频预处理模块 OpenCVTODO OpenGL视频渲染TODO WebRTC的分层协议图： 信令，会话和协议： 问题解决里程node 启动 server 报错： 12345678910111213141516events.js:141 throw er; // Unhandled 'error' event ^Error: listen EACCES 0.0.0.0:443 at Object.exports._errnoException (util.js:870:11) at exports._exceptionWithHostPort (util.js:893:20) at Server._listen2 (net.js:1224:19) at listen (net.js:1273:10) at net.js:1382:9 at nextTickCallbackWith3Args (node.js:452:9) at process._tickCallback (node.js:358:17) at Function.Module.runMain (module.js:444:11) at startup (node.js:136:18) at node.js:966:3[Solve]$ sudo setcap 'cap_net_bind_service=+ep' $(readlink -f $(which node)) 查询端口是否别占用： 12345678# Linux$ netstat -ntpl | grep 443# MacOS# lsof 通过list open file命令可以查看到当前打开文件，在linux中所有事物都是以文件形式存在，包括网络连接及硬件设备。$ sudo lsof -i:80 // sudo lsof -i tcp:80# -i 参数表示网络链接，:80 指明端口号，该命令会同时列出 PID$ sudo lsof -i -P | grep -i "listen"# 查看所有进程监听的端口 补充 turnserver.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890# RFC5766-TURN-SERVER configuration file# RFC5766-TURN-SERVER配置文件## Boolean values note: where boolean value is supposed to be used,# you can use '0', 'off', 'no', 'false', 'f' as 'false,# and you can use '1', 'on', 'yes', 'true', 't' as 'true'# If the value is missed, then it means 'true'.## 布尔值注意: 布尔值应该被使用,# 您可以使用'0', 'off', 'no', 'false', 'f' 相当于 'false,# 还有你可以用'1', 'on', 'yes', 'true', 't' 相当于 'true'# 如果没有值，相当于'true'.## Listener interface device (optional, Linux only).# NOT RECOMMENDED.## 侦听器接口设备(仅可选,Linux)。# 不推荐。#listening-device=eth0# TURN listener port for UDP and TCP (Default: 3478).# Note: actually, TLS &amp; DTLS sessions can connect to the# "plain" TCP &amp; UDP port(s), too - if allowed by configuration.## TURN为UDP和TCP的侦听器端口(默认: 3478)。# 注:实际上,TLS和DTLS会话可以连接到"清晰的"TCP和UDP端口,——如果允许配置。##listening-port=3478listening-port=3478# TURN listener port for TLS (Default: 5349).# Note: actually, "plain" TCP &amp; UDP sessions can connect to the TLS &amp; DTLS# port(s), too - if allowed by configuration. The TURN server# "automatically" recognizes the type of traffic. Actually, two listening# endpoints (the "plain" one and the "tls" one) are equivalent in terms of# functionality; but we keep both endpoints to satisfy the RFC 5766 specs.# For secure TCP connections, we currently support SSL version 3 and# TLS version 1.0, 1.1 and 1.2. SSL2 "encapculation mode" is also supported.# For secure UDP connections, we support DTLS version 1.## TURN为TLS的侦听器端口(默认: 5349)。# 注意:事实上,"清晰的"TCP和UDP会话可以连接到TLS和DTLS端口，如果允许配置。# TURN服务器"自动"识别传输类型。实际上,两个监听终端点("清晰的"端和"TLS"端)是# 对等的功能;但我们保持两个端点来满足RFC 5766规范。# 对于安全的TCP连接,我们目前支持SSL的3个版本，是TLS 1.0版本,1.1版本和1.2版本。# SSL2还支持"encapculation模式"。对于安全的UDP连接,我们支持DTLS版本1。##tls-listening-port=5349tls-listening-port=5349# Alternative listening port for UDP and TCP listeners;# default (or zero) value means "listening port plus one".# This is needed for RFC 5780 support# (STUN extension specs, NAT behavior discovery). The TURN Server# supports RFC 5780 only if it is started with more than one# listening IP address of the same family (IPv4 or IPv6).# RFC 5780 is supported only by UDP protocol, other protocols# are listening to that endpoint only for "symmetry".## 选择UDP和TCP监听器监听端口;# 默认(或者0)是表示监听的端口加1.# 这是必须的，为了RFC 5780的支持(STUN的扩展规范, NAT后端的发现)。# TURN服务器支持RFC 5780只有启动与多个监听同一族的IP地址(IPv4或IPv6).# RFC 5780只有UDP协议,支持其他协议是监听"对称"型端口的。##alt-listening-port=0 # Alternative listening port for TLS and DTLS protocols.# Default (or zero) value means "TLS listening port plus one".## 选择监听端口TLS和DTLS协议。# 默认(或者0)是表示TLS监听的端口加1.##alt-tls-listening-port=0 # Listener IP address of relay server. Multiple listeners can be specified.# If no IP(s) specified in the config file or in the command line options,# then all IPv4 and IPv6 system IPs will be used for listening.## 侦听器中继服务器的IP地址。可以指定多个侦听器。# 如果没有在配置文件或者命令选项中指定监听的IP，# 那么所有的IPv4和IPv6所有的IP将被监听#listening-ip=172.26.7.151# Auxiliary STUN/TURN server listening endpoint.# Aux servers have almost full TURN and STUN functionality.# The (minor) limitations are:# 1) Auxiliary servers do not have alternative ports and# they do not support STUN RFC 5780 functionality (CHANGE REQUEST).# 2) Auxiliary servers also are never returning ALTERNATIVE-SERVER reply.# Valid formats are 1.2.3.4:5555 for IPv4 and [1:2::3:4]:5555 for IPv6.# There may be multiple aux-server options, each will be used for listening# to client requests.## 辅助STUN/TURN服务器监听端口。# 辅助服务器几乎有齐TURN和STUN功能# (一些)局限性:# 1) 辅助服务器没有替代的端口并且他们不支持STUN RFC 5780功能(变更请求)。# 2) 辅助服务器也不会返回ALTERNATIVE-SERVER回复。# 有效格式，IPv4的1.2.3.4:5555 和IPv6的[1:2::3:4]:5555。# 可能会有多个aux-server选项,每个将用于监听客户端请求。##aux-server=172.17.19.110:33478#aux-server=[2607:f0d0:1002:51::4]:33478# (recommended for older Linuxes only)# Automatically balance UDP traffic over auxiliary servers (if configured).# The load balancing is using the ALTERNATE-SERVER mechanism.# The TURN client must support 300 ALTERNATE-SERVER response for this# functionality.## (仅推荐老的Linuxes)# 在辅助服务器自动均衡UDP流量(如果配置)。# 使用ALTERNATE-SERVER的负载均衡机制。# TURN客户端必须支持300个ALTERNATE-SERVER响应。##udp-self-balance# Relay interface device for relay sockets (optional, Linux only).# NOT RECOMMENDED.## 终极接口设备为中继套接字(可选, 仅Linux).# 不推荐。##relay-device=eth1# Relay address (the local IP address that will be used to relay the# packets to the peer).# Multiple relay addresses may be used.# The same IP(s) can be used as both listening IP(s) and relay IP(s).# If no relay IP(s) specified, then the turnserver will apply the default# policy: it will decide itself which relay addresses to be used, and it# will always be using the client socket IP address as the relay IP address# of the TURN session (if the requested relay address family is the same# as the family of the client socket).## 中继地址(本地IP地址将用于传递数据包的给每个端)# 可以使用多个中继地址。# 相同的IP可以用作监听IP和继电器IP。# 如果没有指定中继IP，那么turnserver将应用默认策略：它将自行决定使用那个中继# 地址，并且它总是会使用客户端套接字的IP地址作为中继的IP地址在TURN会话中(如果# 请求的中继地址族解决同族的客户端套接字)。##relay-ip=172.17.19.105#relay-ip=2607:f0d0:1002:51::5relay-ip=172.26.7.151# For Amazon EC2 users:## TURN Server public/private address mapping, if the server is behind NAT.# In that situation, if a -X is used in form "-X &lt;ip&gt;" then that ip will be reported# as relay IP address of all allocations. This scenario works only in a simple case# when one single relay address is be used, and no RFC5780 functionality is required.# That single relay address must be mapped by NAT to the 'external' IP.# The "external-ip" value, if not empty, is returned in XOR-RELAYED-ADDRESS field.# For that 'external' IP, NAT must forward ports directly (relayed port 12345# must be always mapped to the same 'external' port 12345).# In more complex case when more than one IP address is involved,# that option must be used several times, each entry must# have form "-X &lt;public-ip/private-ip&gt;", to map all involved addresses.# RFC5780 NAT discovery STUN functionality will work correctly,# if the addresses are mapped properly, even when the TURN server itself# is behind A NAT.# By default, this value is empty, and no address mapping is used.## Amazon EC2用户:# TURN服务器公开/私有的地址映射，假如服务器是在NAT后端。# 在这种情况下,如果一个表单中"-X &lt;ip&gt;"使用一个-X，然后该ip将被作为中继ip地址来使用。# 这种情况只适用于一个简单的例子,当一个中继的地址是被使用,和没有RFC5780功能是必需的。# 单个中继地址必须通过NAT映射到外部的IP。# 外部的IP值，假如不为空，通过XOR-RELAYED-ADDRESS字段返回。# 外部的IP,NAT必须直接转发端口(转发端口12345，必须总是映射到相同的外部端口12345)。# 在更复杂的情况下,当涉及到多个IP地址,这个选项必须使用几次,每个条目必须形# 成"-X &lt;public-ip/private-ip&gt;",将所有涉及到的地址。# RFC5780 NAT发现STUN功能正常工作，如果正确的地址映射,即使TURN服务器本身是# 在一个NAT后。# 默认，该值为空，并且没有使用地址映射。##external-ip=60.70.80.91##OR:##external-ip=60.70.80.91/172.17.19.101#external-ip=60.70.80.92/172.17.19.102external-ip=47.92.119.215# Number of relay threads to handle the established connections# (in addition to authentication thread and the listener thread).# If set to 0 then application runs relay process in a single thread,# in the same thread with the listener process (the authentication thread will# still be a separate thread).# In the older systems (Linux kernel before 3.9),# the number of UDP threads is always one thread per network listening endpoint -# including the auxiliary endpoints - unless 0 (zero) or 1 (one) value is set.## 数量的中继线程处理建立连接(除了验证线程和侦听器线程)。# 如果设置为0,那么应用程序中继进程在一个线程中运行,在同一# 个线程中监听处理(身份验证线程仍然是一个单独的线程)。# 在旧系统(3.9 Linux内核之前),数量的UDP线程总是一个线程监听一个网络端点,包括辅助端点——除非设置0或1值。##relay-threads=0relay-threads=10# Lower and upper bounds of the UDP relay endpoints:# (default values are 49152 and 65535)## UDP中继端点的上下边界:# (默认是49152至65535)#min-port=49152max-port=65535 # Uncomment to run TURN server in 'normal' 'moderate' verbose mode.# By default the verbose mode is off.## 取消TURN服务器运行'normal' 'moderate'详细模式。# 默认情况下,详细模式是关闭的。##verbose # Uncomment to run TURN server in 'extra' verbose mode.# This mode is very annoying and produces lots of output.# Not recommended under any normal circumstances.## 取消TURN服务器运行'extra'详细模式。# 这种模式是非常恼人的,产生大量的输出。# 在任何正常情况下不建议。##Verbose# Uncomment to use fingerprints in the TURN messages.# By default the fingerprints are off.## 取消在TURN消息中使用指纹。# 默认情况下,指纹是关闭的。##fingerprint# Uncomment to use long-term credential mechanism.# By default no credentials mechanism is used (any user allowed).# This option can be used with either flat file user database or# PostgreSQL DB or MySQL DB or Redis DB for user keys storage.## 取消使用长期证书机制。# 默认情况下不使用凭证机制(允许任何用户)。# 这个选项可能使用用户数据文件或PostgreSQL或MySQL或Redis来存储用户密钥。##lt-cred-mechlt-cred-mech# Uncomment to use short-term credential mechanism.# By default no credentials mechanism is used (any user allowed).# For short-term credential mechanism you have to use PostgreSQL or# MySQL or Redis database for user password storage.## 取消使用短期证书机制。# 默认情况下不使用凭证机制(允许任何用户)。# 短期证书机制必须使用PostgreSQL或MySQL或Redis数据库来存储用户密码。##st-cred-mech# This option is opposite to lt-cred-mech or st-cred-mech.# (TURN Server with no-auth option allows anonymous access).# If neither option is defined, and no users are defined,# then no-auth is default. If at least one user is defined,# in this file or in command line or in usersdb file, then# lt-cred-mech is default.## 这个选项是lt-cred-mech或st-cred-mech相反。# (TURN服务器no-auth选项允许匿名访问)。# 如果没有选项定义,没有用户定义,那么no-auth默认。# 如果至少定义有一个用户,在这个文件中或在命令行或usersdb文件,# 那么lt-cred-mech默认。##no-auth# TURN REST API flag.# Flag that sets a special authorization option that is based upon authentication secret.# This feature can be used with the long-term authentication mechanism, only.# This feature purpose is to support "TURN Server REST API", see# "TURN REST API" link in the project's page# http://code.google.com/p/rfc5766-turn-server/.# This option is used with timestamp:# usercombo -&gt; "timestamp:userid"# turn user -&gt; usercombo# turn password -&gt; base64(hmac(secret key, usercombo))# This allows TURN credentials to be accounted for a specific user id.# If you don't have a suitable id, the timestamp alone can be used.# This option is just turning on secret-based authentication.# The actual value of the secret is defined either by option static-auth-secret,# or can be found in the turn_secret table in the database (see below).## TURN REST API标志。# 标志是设置一个特殊的授权选项,是基于身份验证的私密。# 这个功能可以用于长期验证机制。# 这个功能的目的是支持"TURN Server REST API",看到"TURN Server REST API"项目的页面的链接# http://code.google.com/p/rfc5766-turn-server/。# 这个选项是使用时间戳:# usercombo -&gt; "timestamp:userid"# turn user -&gt; usercombo# turn password -&gt; base64(hmac(secret key, usercombo))# 这允许TURN凭证占用一个特定的用户id。# 如果你没有一个合适的id,可以使用单独的时间戳。# 这个选项只是打开基于私密的身份验证。# 实际值定义的私密就是通过选择static-auth-secret,或可以在数据库中找到turn_secret表(见下文)。#use-auth-secret# 'Static' authentication secret value (a string) for TURN REST API only.# If not set, then the turn server# will try to use the 'dynamic' value in turn_secret table# in user database (if present). The database-stored value can be changed on-the-fly# by a separate program, so this is why that other mode is 'dynamic'.## TURN REST API的'Static'身份验证的私密值(字符串)# 如果没有设置，那么turn服务器将尝试使用'dynamic'值在用户数据库的turn_secret表(如果存在)。# 数据库存储的值可以随时改变，通过单独的程序，所以这就是'dynamic'模式。#static-auth-secret=ling # 'Static' user accounts for long term credentials mechanism, only.# This option cannot be used with TURN REST API or with short-term credentials# mechanism.# 'Static' user accounts are NOT dynamically checked by the turnserver process,# so that they can NOT be changed while the turnserver is running.## 'Static'用户长期占凭证机制。# 这个选项不能用于TURN REST API或短期凭证机制。# 'Static'用户帐户不是turnserver程序动态检查,所以他们不能改变在turnserver运行时。##user=username1:key1#user=username2:key2# OR:#user=username1:password1#user=username2:password2## Keys must be generated by turnadmin utility. The key value depends# on user name, realm, and password:## 钥匙必须由turnadmin实用程序生成。键值取决于用户名称、领域和密码:## Example:# 例子,使用以下命令:## $ turnadmin -k -u ninefingers -r north.gov -p youhavetoberealistic## Output: 0xbc807ee29df3c9ffa736523fb2c4e8ee# 输出是: 0xbc807ee29df3c9ffa736523fb2c4e8ee## ('0x' in the beginning of the key is what differentiates the key from# password. If it has 0x then it is a key, otherwise it is a password).# ('0x'开始的关键是区分从密码的关键。如果它有0x,那么它是一个关键,否则这是一个密码)。## The corresponding user account entry in the config file will be:# 相应的配置文件中的用户帐户条目将:##user=ninefingers:0xbc807ee29df3c9ffa736523fb2c4e8ee# Or, equivalently, with open clear password (less secure):#或者是这样，明文密码(不安全的):user=ling:0xc93be9d24fb0eab034f539c855528a26#user=ling:ling1234# 'Dynamic' user accounts database file name.# Only users for long-term mechanism can be stored in a flat file,# short-term mechanism will not work with option, the short-term# mechanism required PostgreSQL or MySQL or Redis database.# 'Dynamic' long-term user accounts are dynamically checked by the turnserver process,# so that they can be changed while the turnserver is running.# Default file name is turnuserdb.conf.## 'Dynamic'用户帐户数据库文件名。# 只有用户长期机制可以存储在一个文件,短期机制不会处理选项,短期机制需要PostgreSQL或MySQL或# Redis数据库。# 'Dynamic'的长期用户帐户在turnserver程序中动态检查的,这样他们可以改变的在turnserver运行时。# 默认文件名是turnuserdb.conf.##userdb=/usr/local/etc/turnuserdb.confuserdb=/etc/turnuserdb.conf# PostgreSQL database connection string in the case that we are using PostgreSQL# as the user database.# This database can be used for long-term and short-term credential mechanisms# and it can store the secret value for secret-based timed authentication in TURN RESP API.# See http://www.postgresql.org/docs/8.4/static/libpq-connect.html for 8.x PostgreSQL# versions connection string format, see# http://www.postgresql.org/docs/9.2/static/libpq-connect.html#LIBPQ-CONNSTRING# for 9.x and newer connection string formats.## PostgreSQL数据库连接字符串,使用PostgreSQL作为用户数据库。# 该数据库可用于长期和短期证书机制,它可以存储的私密值，为基于私密身份验证的在TURN RESP API中。# 8.x PostgreSQL版本请参见http://www.postgresql.org/docs/8.4/static/libpq-connect.html的连接字符串# 格式,9.x和更新的请参阅http://www.postgresql.org/docs/9.2/static/libpq-connect.html LIBPQ-CONNSTRING# 的连接字符串格式。##psql-userdb="host=&lt;host&gt; dbname=&lt;database-name&gt; user=&lt;database-user&gt; password=&lt;database-user-password&gt; connect_timeout=30"# MySQL database connection string in the case that we are using MySQL# as the user database.# This database can be used for long-term and short-term credential mechanisms# and it can store the secret value for secret-based timed authentication in TURN RESP API.# Use string format as below (space separated parameters, all optional):## MySQL数据库连接字符串,使用MySQL作为用户数据库。# 该数据库可用于长期和短期证书机制,它可以存储的私密值，为基于私密身份验证的在TURN RESP API中。# 使用字符串格式如下(空间分离参数,所有可选):##mysql-userdb="host=&lt;host&gt; dbname=&lt;database-name&gt; user=&lt;database-user&gt; password=&lt;database-user-password&gt; port=&lt;port&gt; connect_timeout=&lt;seconds&gt;"# Redis database connection string in the case that we are using Redis# as the user database.# This database can be used for long-term and short-term credential mechanisms# and it can store the secret value for secret-based timed authentication in TURN RESP API.# Use string format as below (space separated parameters, all optional):## Redis数据库连接字符串,使用Redis作为用户数据库。# 该数据库可用于长期和短期证书机制,它可以存储的私密值，为基于私密身份验证的在TURN RESP API中。# 使用字符串格式如下(空间分离参数,所有可选):##redis-userdb="ip=&lt;ip-address&gt; dbname=&lt;database-number&gt; password=&lt;database-user-password&gt; port=&lt;port&gt; connect_timeout=&lt;seconds&gt;"# Redis status and statistics database connection string, if used (default - empty, no Redis stats DB used).# This database keeps allocations status information, and it can be also used for publishing# and delivering traffic and allocation event notifications.# The connection string has the same parameters as redis-userdb connection string.# Use string format as below (space separated parameters, all optional):## Redis状态和统计数据库连接字符串,如果使用(默认空,没有Redis统计数据库使用)。# 这个数据库保持分配状态信息,它也可以用于发布和交付传输和分配事件通知。# 连接字符串有相同的参数作为redis-userdb连接字符串。# 使用字符串格式如下(空间分离参数,所有可选):##redis-statsdb="ip=&lt;ip-address&gt; dbname=&lt;database-number&gt; password=&lt;database-user-password&gt; port=&lt;port&gt; connect_timeout=&lt;seconds&gt;"# Realm for long-term credentials mechanism and for TURN REST API.## TURN REST API的长期凭证机制范围。##realm=mycompany.org# Per-user allocation quota.# default value is 0 (no quota, unlimited number of sessions per user).## 每个用户分配配额。# 默认值为0(没有配额,每个用户无限数量的会话)。##user-quota=0# Total allocation quota.# default value is 0 (no quota).## 总分配配额。# 默认值为0(无配额)。##total-quota=0# Max bytes-per-second bandwidth a TURN session is allowed to handle# (input and output network streams are treated separately). Anything above# that limit will be dropped or temporary suppressed (within# the available buffer limits).## TURN会话允许最大的传输占用带宽(输入和输出网络流分别处理)。# 高于限制将被删除或暂时抑制(在可用的缓冲区范围内)。##max-bps=0max-bps=1024# Uncomment if no UDP client listener is desired.# By default UDP client listener is always started.## 如果没有UDP客户端监听器需要取消。# 默认情况下UDP客户端监听器总是启动。##no-udp# Uncomment if no TCP client listener is desired.# By default TCP client listener is always started.## 如果没有TCPP客户端监听器需要取消。# 默认情况下TCPP客户端监听器总是启动。##no-tcp# Uncomment if no TLS client listener is desired.# By default TLS client listener is always started.## 如果没有TLS客户端监听器需要取消。# 默认情况下TLS客户端监听器总是启动。##no-tls# Uncomment if no DTLS client listener is desired.# By default DTLS client listener is always started.## 如果没有DTLS客户端监听器需要取消。# 默认情况下DTLS客户端监听器总是启动。##no-dtls# Uncomment if no UDP relay endpoints are allowed.# By default UDP relay endpoints are enabled (like in RFC 5766).## 如果不允许UDP中继端点需要取消。# 默认情况下启用UDP继电器端点(如在RFC 5766)。##no-udp-relay# Uncomment if no TCP relay endpoints are allowed.# By default TCP relay endpoints are enabled (like in RFC 6062).## 如果不允许TCP中继端点需要取消。# 默认情况下启用TCP继电器端点(如在RFC 5766)。##no-tcp-relay# Uncomment if extra security is desired,# with nonce value having limited lifetime (600 secs).# By default, the nonce value is unique for a session,# but it has unlimited lifetime. With this option,# the nonce lifetime is limited to 600 seconds, after that# the client will get 438 error and will have to re-authenticate itself.## 取消如果需要额外的安全,现时已有有限的生命周期(600秒)。# 默认情况下,一个会话的唯一临界值,但它一般拥有无限的生命周期。这个选项,临界值# 仅限于600秒,之后,客户端将得到438错误,将不得不重新认证。#stale-nonce# Certificate file.# Use an absolute path or path relative to the# configuration file.## 证书文件。# 使用绝对路径或路径相对于配置文件。#cert=/etc/cacert.pem# Private key file.# Use an absolute path or path relative to the# configuration file.# Use PEM file format.## 私钥文件。# 使用绝对路径或路径相对于配置文件。使用PEM文件格式。#pkey=/etc/cakey.pem# Private key file password, if it is in encoded format.# This option has no default value.## 私有密钥文件密码,如果是在编码格式。# 这个选项没有默认值。##pkey-pwd=...# Allowed OpenSSL cipher list for TLS/DTLS connections.# Default value is "DEFAULT".## 允许OpenSSL的密码列表为TLS/DTLS连接。# 默认值是"DEFAULT"##cipher-list="DEFAULT"# CA file in OpenSSL format.# Forces TURN server to verify the client SSL certificates.# By default it is not set: there is no default value and the client# certificate is not checked.## 在OpenSSL格式的CA文件。# 强制TURN服务器验证客户端SSL证书。# 默认情况下它没有设置:没有默认值,不检查的客户端证书。## Example:#CA-file=/etc/ca11111.crt# Curve name for EC ciphers, if supported by OpenSSL library (TLS and DTLS).# The default value is prime256v1.## 曲线名称的EC密码,如果由OpenSSL库支持(TLS和DTLS)。# 默认值是prime256v1。##ec-curve-name=prime256v1# Use 566 bits predefined DH TLS key. Default size of the key is 1066.## 使用566位预定义DH TLS键。默认键大小是1066##dh566# Use 2066 bits predefined DH TLS key. Default size of the key is 1066.## 使用2066位预定义DH TLS键。默认键大小是1066##dh2066# Use custom DH TLS key, stored in PEM format in the file.# Flags --dh566 and --dh2066 are ignored when the DH key is taken from a file.## 使用惯例的DH TLS键，使用PEM格式存储在文件里# 当DH键从文件里加载，将忽略标志--dh566和--dh2066##dh-file=&lt;DH-PEM-file-name&gt;# Flag to prevent stdout log messages.# By default, all log messages are going to both stdout and to# the configured log file. With this option everything will be# going to the configured log only (unless the log file itself is stdout).## 标志防止输出日志信息# 默认情况下,所有日志消息将输出到配置的日志文件。采用这一选项都将只配置日志# (除非日志文件本身是输出的)。##no-stdout-log# Option to set the log file name.# By default, the turnserver tries to open a log file in# /var/log, /var/tmp, /tmp and current directories directories# (which open operation succeeds first that file will be used).# With this option you can set the definite log file name.# The special names are "stdout" and "-" - they will force everything# to the stdout. Also, the "syslog" name will force everything to# the system log (syslog).# In the runtime, the logfile can be reset with the SIGHUP signal# to the turnserver process.## 设置日志文件# 默认情况下,turnserver尝试一个日志文件在/var/log,/var/tmp,/tmp和# 当前目录(那个文件先打开成功,文件将被使用)。# 采用这一选项可以设置明确的日志文件名。# 特殊的名字是"stdout"和"-"——他们将强制所有的输出。同时,"syslog"名称将强制所有的系统日志(syslog)。# 在运行时,日志文件可以重置通过SIGHUP信号在turnserver程序中。##log-file=/var/tmp/turn.log# Option to redirect all log output into system log (syslog).## 选择重定向所有日志输出到系统日志(syslog)。##syslog# This flag means that no log file rollover will be used, and the log file# name will be constructed as-is, without PID and date appendage.## 这个标志意味着没有日志文件将使用翻转,并按原样将创建日志文件名称,没有PID和日期的附加。##simple-log# Option to set the "redirection" mode. The value of this option# will be the address of the alternate server for UDP &amp; TCP service in form of# &lt;ip&gt;[:&lt;port&gt;]. The server will send this value in the attribute# ALTERNATE-SERVER, with error 300, on ALLOCATE request, to the client.# Client will receive only values with the same address family# as the client network endpoint address family.# See RFC 5389 and RFC 5766 for ALTERNATE-SERVER functionality description.# The client must use the obtained value for subsequent TURN communications.# If more than one --alternate-server options are provided, then the functionality# can be more accurately described as "load-balancing" than a mere "redirection".# If the port number is omitted, then the default port# number 3478 for the UDP/TCP protocols will be used.# Colon ( characters in IPv6 addresses may conflict with the syntax of# the option. To alleviate this conflict, literal IPv6 addresses are enclosed# in square brackets in such resource identifiers, for example:# [2001:db8:85a3:8d3:1319:8a2e:370:7348]:3478 .# Multiple alternate servers can be set. They will be used in the# round-robin manner. All servers in the pool are considered of equal weight and# the load will be distributed equally. For example, if we have 4 alternate servers,# then each server will receive 25% of ALLOCATE requests. A alternate TURN server# address can be used more than one time with the alternate-server option, so this# can emulate "weighting" of the servers.## 选项设置"redirection"模式。这个选项的值将备用服务器的地址UDP和TCP服务形式的&lt;ip&gt;[:&lt;port&gt;]。# 服务器将发送这个值属性ALTERNATE-SERVER,错误300,在ALLOCATE请求,客户端。# 客户端将只接收和自己相同的地址族的客户端的值。查看RFC 5389和RFC 5766为ALTERNATE-SERVER的功能描述。# 客户端必须使用获得的值为随后的TURN通信。如果不止一个——alternate-server选项提供,那么功能可以更准确# 地描述为"load-balancing",而不仅仅是一个"redirection"。如果端口号省略,那么为UDP/TCP协议，使用默认端# 口号是3478。冒号(在IPv6地址字符可能与选项的语法冲突。缓解这种冲突,文字IPv6地址包含在方括号在这种# 资源标识符,例如[2001:db8:85a3:8d3:1319:8a2e:370:7348]:3478 。# 可以设置多个备用服务器。他们将用于循环的方式。所有服务器池中被认为是平等的重量和载荷将平均分配的原则。# 例如,如果我们有4个备用服务器,每个服务器将获得25%的分配请求。备用TURN服务器地址可以使用超过一次# alternate-server选项,所以这可以效仿的"weighting"服务器。## Examples:#alternate-server=1.2.3.4:5678#alternate-server=11.22.33.44:56789#alternate-server=5.6.7.8#alternate-server=[2001:db8:85a3:8d3:1319:8a2e:370:7348]:3478 # Option to set alternative server for TLS &amp; DTLS services in form of# &lt;ip&gt;:&lt;port&gt;. If the port number is omitted, then the default port# number 5349 for the TLS/DTLS protocols will be used. See the previous# option for the functionality description.## 选项设置替代服务器TLS和DTLS服务形式的&lt;ip&gt;:&lt;port&gt;。# 如果省略的端口号,那么默认端口号5349将使用TLS/DTLS协议。看到前面选择的功能描述。## Examples:#tls-alternate-server=1.2.3.4:5678#tls-alternate-server=11.22.33.44:56789#tls-alternate-server=[2001:db8:85a3:8d3:1319:8a2e:370:7348]:3478# Option to suppress TURN functionality, only STUN requests will be processed.# Run as STUN server only, all TURN requests will be ignored.# By default, this option is NOT set.## 选择抑制TURN功能,只有STUN的请求将被处理。# 作为STUN服务器,所有TURN请求将被忽略。# 默认情况下,没有设置这个选项。##stun-only# Option to suppress STUN functionality, only TURN requests will be processed.# Run as TURN server only, all STUN requests will be ignored.# By default, this option is NOT set.## 选择抑制STUN功能,只有TURN的请求将被处理。# 作为TURN服务器,所有STUN请求将被忽略。# 默认情况下,没有设置这个选项。##no-stun# This is the timestamp/username separator symbol (character) in TURN REST API.# The default value is ':'.## 这是时间戳/用户名分离器符号(字符)在TURN REST API。# 默认是使用':'## rest-api-separator=: # Flag that can be used to disallow peers on the loopback addresses (127.x.x.x and ::1).# This is an extra security measure.## 标记用于不接受的端在环回地址(127.x.x.x 和 ::1)。# 这是一个额外的安全措施。##no-loopback-peers172.26.7.151# Flag that can be used to disallow peers on well-known broadcast addresses (224.0.0.0 and above, and FFXX:*).# This is an extra security measure.## 标记用于不接受的端在广播地址(224.0.0.0和以上的，和FFXX:*)。# 这是一个额外的安全措施。##no-multicast-peers# Option to set the max time, in seconds, allowed for full allocation establishment.# Default is 60 seconds.## 选项设置的最大时间,以秒为单位,允许完整的分配。# 默认60秒##max-allocate-timeout=60# Option to allow or ban specific ip addresses or ranges of ip addresses.# If an ip address is specified as both allowed and denied, then the ip address is# considered to be allowed. This is useful when you wish to ban a range of ip# addresses, except for a few specific ips within that range.# This can be used when you do not want users of the turn server to be able to access# machines reachable by the turn server, but would otherwise be unreachable from the# internet (e.g. when the turn server is sitting behind a NAT)## 选择允许或禁止特定的ip地址或ip地址范围。# 如果指定一个ip地址允许和拒绝,那么ip地址被认为是允许的。这是有用的,当你希望禁止一个范# 围的ip地址,除了一些特定的ip范围内。# 这可以使用当你不希望turn服务器的用户能够访问机器通过turn服务器,但可能是另一方面从互联# 网上不能到达(例如,当turn服务器是在一个NAT后)## Examples:# denied-peer-ip=83.166.64.0-83.166.95.255# allowed-peer-ip=83.166.68.45# File name to store the pid of the process.# Default is /var/run/turnserver.pid (if superuser account is used) or# /var/tmp/turnserver.pid .## 存储进程pid的文件名。# 默认是/var/run/turnserver.pid(超级用户使用)或者是/var/tmp/turnserver.pid##pidfile="/var/run/turnserver.pid"pidfile="/var/tmp/turnserver.pid"# Require authentication of the STUN Binding request.# By default, the clients are allowed anonymous access to the STUN Binding functionality.## 需要STUN绑定请求的身份验证。# 默认情况下,客户允许匿名访问STUN绑定功能。##secure-stun# Require SHA256 digest function to be used for the message integrity.# By default, the server uses SHA1 (as per TURN standard specs).# With this option, the server# always requires the stronger SHA256 function. The client application# must support SHA256 hash function if this option is used. If the server obtains# a message from the client with a weaker (SHA1) hash function then the# server returns error code 426.## 需要SHA256采摘功能用于消息的完整性。# 默认情况下,服务器使用SHA1(按标准规格)。# 采用这一选项,服务器总是需要更强的SHA256功能。客户端应用程序必须支持SHA256散列函数# 如果使用这个选项。如果服务器获得消息从客户端较弱(SHA1)散列函数那么服务器返回错误代码426。##sha256# Mobility with ICE (MICE) specs support.## 移动的ICE(MICE)的规范支持。##mobility# User name to run the process. After the initialization, the turnserver process# will make an attempt to change the current user ID to that user.## 用户名运行程序。初始化后,turnserver程序将试图改变当前用户的用户ID。##proc-user=&lt;user-name&gt;# Group name to run the process. After the initialization, the turnserver process# will make an attempt to change the current group ID to that group.## 组名运行程序。初始化后,turnserver程序将试图改变当前组的组ID。##proc-group=&lt;group-name&gt;# Turn OFF the CLI support.# By default it is always ON.# See also options cli-ip and cli-port.## 关掉CLI的支持。# 默认情况下它总是ON。# 参阅选项cli-ip和cli-port。##no-cli#Local system IP address to be used for CLI server endpoint. Default value# is 127.0.0.1.## 本地系统的IP地址将用于CLI服务器端点。默认值是127.0.0.1。##cli-ip=127.0.0.1# CLI server port. Default is 5766.## CLI服务器端口。默认是5766。##cli-port=5766# CLI access password. Default is empty (no password).## CLI访问密码。默认是空的(没有密码)。#cli-password=logen# Server relay. NON-STANDARD AND DANGEROUS OPTION.# Only for those applications when we want to run# server applications on the relay endpoints.# This option eliminates the IP permissions check on# the packets incoming to the relay endpoints.## 中继服务器。NON-STANDARD和DANGEROUS的选择。# 只对这些应用程序时,我们想在中继服务器上运行服务器应用程序端点。# 这个选项可以消除IP权限检查传递的数据包传入的端点。##server-relay# Maximum number of output sessions in ps CLI command.# This value can be changed on-the-fly in CLI. The default value is 256.## 最大数量的输出会议在ps CLI命令。# 这个值可以动态改变在CLI。默认值是256。##cli-max-output-sessions# Set network engine type for the process (for internal purposes).## 设置网络引擎类型(用于内部目的)的过程。##ne=[1|2|3]# Do not allow an SSL/TLS version of protocol## 不允许一个SSL/TLS版本的协议##no-sslv2#no-sslv3#no-tlsv1#no-tlsv1_1#no-tlsv1_2%]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC（一）]]></title>
    <url>%2F2019%2F05%2F14%2FWebRTC%2Fwebrtc-01%2F</url>
    <content type="text"><![CDATA[WebRTC API Node.js v10.15.3 文档 廖雪峰 - nodejs Webrtc笔记-获取源码 WebRTC音频引擎实现分析 实时通信RTC技术栈之：视频编解码 开源实时音视频技术WebRTC中RTP/RTCP数据传输协议的应用 WebRTC项目源码在国内的镜像 WebRTC 介绍 Google 开源 跨平台 用于浏览器 实时传输 100ms 延迟 通话质量非常好 200ms 延迟 通话质量比较优质 500ms 延迟 可以接受 超过1s 非常迟滞 音视频引擎 WebRTC 应用： WebRTC 愿景： 学习 WebRTC 的难点： 学习路线： 学习内容： 学习收获： WebRTC能做啥： 能学到什么： google webrtc 示例：https://appr.tc/ WebRTC 原理与架构WebRTC 整体架构： WebRTC 的目录结构图： WebRTC 两个基本概念：轨与流 Track MediaStream WebRTC重要类： MediaStream RTCPeerConnection RTCDataChannel PeerConnection调用过程： 调用时序图： 对于上图中描述的PeerConnection建立的完整流程进行以下说明（上图是以ClientA主动向ClientB发起连接为例）： 首先 ClientA 和 ClientB 均通过双向通信方式如 WebSocket 连接到 Signaling Server 上； ClientA 在本地首先通 GetMedia 访问本地的 media 接口和数据，并创建 PeerConnection 对象，调用其 AddStream 方法把本地的 Media 添加到 PeerConnection 对象中。对于 ClientA 而言，既可以在与 Signaling Server 建立连接之前就创建并初始化 PeerConnection 如阶段 1，也可以在建立 Signaling Server 连接之后创建并初始化 PeerConnection 如阶段 2；ClientB 既可以在上图的1阶段也可以在 2 阶段做同样的事情，访问自己的本地接口并创建自己的 PeerConnection 对象。 通信由 ClientA 发起，所以 ClientA 调用 PeerConnection 的 CreateOffer 接口创建自己的 SDP offer，然后把这个 SDP Offer 信息通过 Signaling Server 通道中转发给 ClientB； ClientB 收到 Signaling Server 中转过来的 ClientA 的 SDP 信息也就是 offer 后，调用 CreateAnswer 创建自己的 SDP 信息也就是 answer，然后把这个 answer 同样通过 Signaling server 转发给 ClientA； ClientA 收到转发的 answer 消息以后，两个 peers 就做好了建立连接并获取对方 media streaming 的准备； ClientA 通过自己 PeerConnection 创建时传递的参数等待来自于 ICE server 的通信，获取自己的 candidate，当 candidate available 的时候会自动回掉 PeerConnection 的 OnIceCandidate； ClientA 通过 Signling Server 发送自己的 Candidate 给 ClientB，ClientB 依据同样的逻辑把自己的 Candidate 通过 Signaling Server 中转发给 ClientA； 至此 ClientA 和 ClientB 均已经接收到对方的 Candidate，通过 PeerConnection 建立连接。至此 P2P 通道建立。 WebRTC之PeerConnection的建立过程 WebRTC系列（3）：PeerConnection通信建立流程 Web服务器原理与Nodejs搭建 node.js基本工作原理及流程 Nodejs的运行原理-架构篇 Node.js 原理简介 NodeJS 事件循环（第一部分）- 事件循环机制概述 Web服务器选型： Nodejs Nginx Apache Web服务工作原理： Nodejs工作原理： JavaScript解析： Nodejs 事件处理： 两个V8引擎： 最简单的http服务： require 引入http模块 创建http服务 侦听端口 启动Nodejs服务： node app.js nohub node app.js forever start app.js pm2 start app.js Https基本原理： Nodejs 搭建 https 服务： 生成 HTTPS证书 引入 HTTPS模块 指定证书位置，并创建 HTTPS 服务 真正的Web服务： 引用 express 模块 引入 server-index 模块 指定发布目录 JavaScript 必备知识回顾基础知识： 变量与类型 基本运算 if/else for循环 函数 日志打印 变量与类型： 基本运算： WebRTC设备管理enumerateDevices： JavaScript中的Promise： WebRTC音视频数据采集音视频采集API： getUserMedia的不同实现： 适配置不同浏览器的方法： https://webrtc.github.io/adapter/adapter-latest.js WebRTC音视频采集约束： 视频约束详解： width height 宽高比例：4:3 16:9 aspectRatio frameRate facingMode user - 前置摄像头 environment - 后置摄像头 left - 前置左侧摄像头 right - 前置右侧摄像头 resizeMode 音频约束详解： volume - 范围 0 - 1.0 sampleRate sampleSize - 一般16位 echoCancellation - 回音消除 autoGainControl - 是否在原有声音基础上增加音量 noiseSuppression - 降噪 latency - 延迟大小 channelCount - 声道 乐器一般是双声道 deviceID - 作用是多个设备切换 groupID WebRTC约束例子： 1234567891011121314151617&#123; audio: true, video: &#123; width: &#123; min: 300, max: 640, &#125;, height: &#123; min: 300, max: 480, &#125;, frameRate: &#123; min: 15, max: 30, &#125; &#125;&#125; 浏览器视频特效： CSS filter，-webkit-filter/filter 如何将 video 与 filter 关联 OpenGL/Metal/… 支持的特效种类： 保存图片是实现滤镜效果，可以对 canvas.data 进行数据修改。 MediaStream API 获取视频约束： WebRTC音视频录制实战WebRTC录制基本知识MediaRecoder类： WebRTC 捕获桌面 捕获桌面需要设置Chrome，具体 操作：chrome://flags/#enable-experimental-web-platform-features Experimental Web Platform features 设置为 enable WebRTC信令服务器实现如果没有信令服务器WebRTC之间是不能通信的。 两个client之间通信必须有两个信息通过信令服务器的： 媒体信息， SDP 网络信息 具体的业务 Socket.IO 发送消息： 给本次连接发送消息 1socket.emit() 给某个房间内所有人发送消息 1io.in(room).emit() 除本链接外，给某个房间内所有人发送消息 1socket.to(room).emit() 除本链接外，给所有人发送消息 1socket.broadcast.emit() Socket.IO 客户端处理消息： 发送 action 命令 12S: socket.emit('action');C: socket.on('action', function()&#123;...&#125;); 发送了一个 action 命令，还有 data 数据 12S: socket.emit('action', data);C: socket.on('action', function(data)&#123;...&#125;); 发送了 action 命令，还有两个数据 12S: socket.emit('action', arg1, arg2);C: socket.on('action', function(arg1, arg2)&#123;...&#125;); 发送了一个 action 命令，在 emit 方法中包含回调函数 12S: socket.emit('action', data, function(arg1, arg2)&#123;...&#125;;C: socket.on('action', function(data, fn)&#123;fn('a', 'b');&#125;); [实战] 通过 socket.io 实现信令服务器改造服务端的基本流程： 安装 socket.io 引入 socket.io 处理 connection 消息 WebRTC网络基础补充：P2P/STUN/TRUN/ICE知识 P2P通信原理与实现 WebRTC 网络传输基本知识WebRTC 传输基本知识： NAT（Network Address Translator） STUN（Simple Traversal of UDP Through NAT） TURN（Travelsal Using Relays around NAT） ICE（Interactive Connectivity Establishment） NAT 产生的原因： 由于IPv4的地址不够 处于网络安全的原因 NAT 的种类： 完全锥型 NAT（Full Cone NAT） 地址限制锥型 NAT（Address Restricted Cone NAT） 端口限制锥型 NAT（Port Restricted Cone NAT） 对称型 NAT（Symmetric NAT） NAT 打洞原理 NAT 穿越原理： C1，C2 向 STUN 发消息 交换公网 IP 及 端口 C1 -&gt; C2，C2 -&gt; C1，甚至是端口猜测 NAT 类型检测 公网 IP： 如果 Client 收到的 IP 和第一次发出去的 IP 是不一样的，则是对称型 NAT，如果是一样的需要进一步判断： Client 通过 Port2 发送消息到 STUN Port1，STUN Server 通过 Port2 给 Client 回消息，如果 Client 能收到消息，则说明是 IP 限制型的；如果不能收到，则说明是端口限制型的： 【协议规范】STUN 协议一STUN 介绍： STUN 存在的目的就是进行 NAT 穿越 STUN 是典型的客户端 / 服务器模式。客户端发送请求，服务端进行响应 RFC STUN 规范： RFC3489/STUN SImple Traversal of UDP Trough NAT RFC5389/STUN — 包含UDP和TCP Session Traversal Utilities for NAT STUN 协议： 包括 20 字节的 STUN header Body 中可以有 0 个或多个 Attribute STUN header（RFC3489）： 其中 2 个字节（16bit）类型 2 个字节（16bit）消息长度，不包括消息头 16 个字节（128bit）事物ID，请求与响应事物 ID 相同 STUN header（RFC5389）格式： M 代表请求值，C 代表分类： RFC5389 把私密类型去掉了： 【协议规范】STUN 协议二Inter 机子都是小端模式： 【协议规范】TURN 协议TURN 介绍： 其目的是解决对称 NAT 无法穿越的问题 其建立在 STUN 之上，消息格式使用 STUN 格式消息 TURN Client 要求服务端分配一个公共 IP 和 Port 用于接受 或 发送数据 TURN 发送机制： Send 和 Data Channel 【协议规范】ICE 框架 Candidate 类型： 主机候选者 反射侯选者 中继候选者 ICE 具体做些什么： 收集 Candidate 对 Candidate Pair 排序 连通性检查 收集 Candidate： Host Candidate：本机所有 IP 和指定端口 Reflexive Candidate：STUN/TURN Relay Candidate：TURN 什么是 SDP： SDP（Session Description Protocol） 它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。 形成 Candidate Pair： 一方收集到所有候选者后，通过信令传给对方 同样，另一方收到候选者后，也做收集工作 当双方拿到全部列表后，将侯选者形成匹配对儿 连通性检查： 对侯选者进行优先级排序 对每个侯选对进行发送检查 对每个侯选对进行接收检查 网络协议分析方法 tcpdump 与 wireshark讲解常用工具： Linux 服务端用 tcpdump 其它端 WireShark 网络协议分析方法 tcpdump 与 wireshark 实战vim 打开二进制数据： 1：%！xxd WireShark 中的逻辑运算： 与：and 或 &amp;&amp; 或：or 或 || 非：not 或 ！ WireShark 中判断语句： 等于：eq 或 == 小于：lt 或 &lt; 大于：gt 或 &gt; 小于等于：le 或 &lt;= 大于等于：ge 或 &gt;= 不等于：ne 或 != WireShark 按协议过滤： stun tcp udp 模拟STUN数据可以使用这个网站中的工具：https://webrtc.github.io/samples Wireshark 按 IP 过滤： 123ip.dst == 192.168.1.2ip.src == 192.168.1.2ip.addr == 192.168.1.2 WireShark 按 port 过滤： 1234tcp.port == 8080udp.port == 3478udp.dstport == 3478udp.srcport == 3478 WireShark 过滤长度： 123udp.length &lt; 30tcp.length &lt; 30http.content_length &lt; 30 WireShark 过滤内容： TODO]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg命令大全]]></title>
    <url>%2F2019%2F05%2F04%2FFFmpeg%2FFFmpeg%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1. 前言FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。 本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。 2. FFMPEG 目录及作用 libavcodec： 提供了一系列编码器的实现。 libavformat： 实现在流协议，容器格式及其本IO访问。 libavutil： 包括了hash器，解码器和各类工具函数。 libavfilter： 提供了各种音视频过滤器。 libavdevice： 提供了访问捕获设备和回放设备的接口。 libswresample： 实现了混音和重采样。 libswscale： 实现了色彩转换和缩放工能。 3. FFMPEG 基本概念在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。 音／视频流 在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。 容器 我们一般把 MP4､ FLV、MOV 等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。 channel channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。 4. FFMPEG 命令我们按使用目的可以将 FFMPEG 命令分成以下几类： 基本信息查询命令 录制 分解 / 复用 处理原始数据 滤镜 切割与合并 图／视互转 直播相关 除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。 然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。 默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。 您可以通过使用 -vn / -an / -sn / -dn 选项来禁用某些默认设置。 要进行全面的手动控制，请使用 -map选项，该选项禁用刚描述的默认设置。 下面我们就来详细介绍一下这些命令。 5. 基本信息查询命令FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 ffmpeg -filters 来查询。详细参数说明如下： 参数 说明 -version 显示版本。 -formats 显示可用的格式（包括设备）。 -demuxers 显示可用的demuxers。 -muxers 显示可用的muxers。 -devices 显示可用的设备。 -codecs 显示libavcodec已知的所有编解码器。 -decoders 显示可用的解码器。 -encoders 显示所有可用的编码器。 -bsfs 显示可用的比特流filter。 -protocols 显示可用的协议。 -filters 显示可用的libavfilter过滤器。 -pix_fmts 显示可用的像素格式。 -sample_fmts 显示可用的采样格式。 -layouts 显示channel名称和标准channel布局。 -colors 显示识别的颜色名称。 接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。 6. 命令基本格式及参数下面是 FFMPEG 的基本命令格式： 12$ ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ... &#123;[output_file_options] output_url&#125; ... ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等），并写入任意数量的输出“文件”。 原则上，每个输入 / 输出“文件”都可以包含任意数量的不同类型的视频流（视频 / 音频 / 字幕 / 附件 / 数据）。 流的数量和 / 或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。 要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如： 2：3 是指第三个输入文件中的第四个流。 上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数： 6.1 主要参数 参数 说明 -f fmt（输入/输出） 强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。 -i url（输入） 输入文件的网址 -y（全局参数） 覆盖输出文件而不询问。 -n（全局参数） 不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。 -c [：stream_specifier] codec（输入/输出，每个流） 选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT -codec [：stream_specifier]编解码器（输入/输出，每个流） 同 -c -t duration（输入/输出） 当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。 -ss位置（输入/输出） 当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。 -frames [：stream_specifier] framecount（output，per-stream） 停止在帧计数帧之后写入流。 -filter [：stream_specifier] filtergraph（output，per-stream） 创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。 6.2 视频参数 参数 说明 -vframes num（输出） 设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。 -r [：stream_specifier] fps（输入/输出，每个流） 设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。 -s [：stream_specifier]大小（输入/输出，每个流） 设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。 -aspect [：stream_specifier] 宽高比（输出，每个流） 设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。 -vn（输出） 禁用视频录制。 -vcodec编解码器（输出） 设置视频编解码器。这是 -codec：v 的别名。 -vf filtergraph（输出） 创建由filtergraph指定的过滤器图，并使用它来过滤流。 6.3 音频参数 参数 说明 -aframes（输出） 设置要输出的音频帧的数量。这是 -frames：a 的一个过时的别名。 -ar [：stream_specifier] freq（输入/输出，每个流） 设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。 -ac [：stream_specifier]通道（输入/输出，每个流） 设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。 -an（输出） 禁用录音。 -acodec编解码器（输入/输出） 设置音频编解码器。这是-codec的别名：a。 -sample_fmt [：stream_specifier] sample_fmt（输出，每个流） 设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。 -af filtergraph（输出） 创建由filtergraph指定的过滤器图，并使用它来过滤流。 了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。 7. 录制首先通过下面的命令查看一下 mac 上都有哪些设备。 1$ ffmpeg -f avfoundation -list_devices true -i "" 录屏 1$ ffmpeg -f avfoundation -i 1 -r 30 out.yuv -f 指定使用 avfoundation 采集数据。 -i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。 -r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而 -r 用于限制输出。 注意：桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。 录屏+声音 1$ ffmpeg -f avfoundation -i 1:0 -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.flv -i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。 -c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。 -crf 是 x264 的参数。 0 表式无损压缩。 -c:a 与参数 -acodec 一样，表示音频编码器。 -profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。 -b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。 录视频 1$ ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4 -framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。 -f 指定使用 avfoundation 采集数据。 -i 指定视频设备的索引号。 视频+音频 1$ ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4 录音 1$ ffmpeg -f avfoundation -i :0 out.wav 录制音频裸数据 1$ ffmpeg -f avfoundation -i :0 -ar 44100 -f s16le out.pcm 8. 分解与复用流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为： 由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。 抽取音频流 1$ ffmpeg -i input.mp4 -acodec copy -vn out.aac acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。 vn: v 代表视频，n 代表 no 也就是无视频的意思。 抽取视频流 1$ ffmpeg -i input.mp4 -vcodec copy -an out.h264 vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。 an: a 代表视频，n 代表 no 也就是无音频的意思。 转格式 1$ ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv 上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。 音视频合并 1$ ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4 9. 处理原始数据提取YUV数据 12$ ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv$ ffplay -s wxh out.yuv -c:v rawvideo 指定将视频转成原始数据 -pixel_format yuv420p 指定转换格式为 yuv420p YUV 转 H264 1$ ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264 提取 PCM 数据 12$ ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm$ ffplay -ar 44100 -ac 2 -f s16le -i out.pcm PCM 转 WAV 1$ ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav 10. 滤镜在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。 10.1 简单滤镜简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示： 简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用 -vf 和 -af 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子： 请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。 10.2 复杂滤镜复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示： 复杂的过滤器图使用 -filter_complex 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。 -lavfi 选项等同于 -filter_complex。 一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。 添加水印 1$ ffmpeg -i out.mp4 -vf "movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]" water.mp4 -vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。 删除水印 先通过 ffplay 找到要删除 LOGO 的位置 1$ ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1 使用 delogo 滤镜删除 LOGO 1$ ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv 视频缩小一倍 1$ ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4 -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。 视频裁剪 1$ ffmpeg -i VR.mov -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4 crop 格式：crop=out_w:out_h:x:y out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。 out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。 x : X坐标 y : Y坐标 如果 x 和 y 设置为 0, 说明从左上角开始裁剪。如果不写是从中心点裁剪。 倍速播放 1$ ffmpeg -i out.mp4 -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]" -map "[v]" -map "[a]" speed2.0.mp4 -filter_complex 复杂滤镜，[0:v] 表示第一个（文件索引号是 0）文件的视频作为输入。setpts=0.5*PTS 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。[v] 表示输出的别名。音频同理就不详述了。 map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。 对称视频 1$ ffmpeg -i out.mp4 -filter_complex "[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w" duicheng.mp4 hflip 水平翻转 如果要修改为垂直翻转可以用 vflip。 画中画 1$ ffmpeg -i out.mp4 -i out1.mp4 -filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]" -map "[out]" -movflags faststart new.mp4 录制画中画 12345$ ffmpeg -f avfoundation -i "1" -framerate 30 -f avfoundation -i "0:0" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex "[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]" -map "[out]" -movflags faststart -map 1:a b.mp4 多路视频拼接 1$ ffmpeg -f avfoundation -i "1" -framerate 30 -f avfoundation -i "0:0" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex "[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]" -map "[out]" -movflags faststart -map 1:a c.mp4 11. 音视频的拼接与裁剪裁剪 1$ ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4 -ss 指定裁剪的开始时间，精确到秒 -t 被裁剪后的时长。 合并 首先创建一个 inputs.txt 文件，文件内容如下： 123$ file '1.flv'$ file '2.flv'$ file '3.flv' 然后执行下面的命令： 1$ ffmpeg -f concat -i inputs.txt -c copy output.flv hls切片 1$ ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls out.m3u8 -strict -2 指明音频使有AAC。 -f hls 转成 m3u8 格式。 12. 视频图片互转视频转 JPEG 1$ ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg 视频转 gif 1$ ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif 图片转视频 1$ ffmpeg -f image2 -i image-%3d.jpeg images.mp4 13. 直播相关推流 1$ ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName 拉流保存 1$ ffmpeg -i rtmp://server/live/streamName -c copy dump.flv 转流 1$ ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream 实时推流 1$ ffmpeg -framerate 15 -f avfoundation -i "1" -s 1280x720 -c:v libx264 -f flv rtmp://localhost:1935/live/room 14. ffplay播放 YUV 数据 1$ ffplay -pix_fmt nv12 -s 192x144 1.yuv 播放 YUV 中的 Y 平面 1$ ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes='y' 1.yuv]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频核心技术]]></title>
    <url>%2F2019%2F04%2F30%2FFFmpeg%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[雷神 FFmpeg源代码结构图 - 解码 雷神 GitHub 雷神 FFmpeg blog ffmpeg filter过滤器 基础实例及全面解析 1. 学习大纲FFmpeg 常用命令： 视频录制命令 多媒体文件的分解/复用命令 裁剪与合并命令 图片/视频互转命令 直播相关命令 各种滤镜命令 FFmpeg 基本开发： C 语言回顾 FFmpeg 核心概念与常用结构体 实战 - 多媒体文件的分解与复用 实战 - 多媒体格式的互转 实战 - 从 MP4 裁剪一段视频 作业 - 实现一个简单的小咖秀 音视频编解码实战： 实战 - H264 解码 实战 - H264 编码 实战 - 音频 AAC 解码 实战 - 音频 AAC 编码 实战 - 视频转图片 音视频渲染实战： SDL 事件处理 SDL 视频文理渲染 SDL 音频渲染 实战1 - 实现 YUV 视频播放 实战2 - YUV 视频倍数播放 实战3 - 实现 PCM 播放器 FFmpeg 开发播放器核心功能： 实战 - 实现 MP4 文件的视频播放 实战 - 实现 MP4 文件的音频播放 实战 - 实现一个初级播放器 实战 - 音视频同步 实战 - 实现播放器内核 Android 中实战 FFmpeg： 编译 Android 端可以使用的 FFmpeg Java 与 C 语言相互调用 实战 - Android 调用 FFmpeg 学习建议： 牢牢抓住音视频的处理机制，了解其本质 勤加练习，熟能生巧 待着问题去学习，事半功倍 音视频的广泛应用： 直播类：音视频会议、教育直播、娱乐/游戏直播 短视频：抖音、快手、小咖秀 网络视频：优酷、腾讯视频、爱奇艺等 音视频通话：微信、QQ、Skype等 视频监控 人工智能：人脸识别，智能音箱等，更关注算法 播放器架构： 渲染流程： FFmpeg 都能做啥： FFmpeg 是一个非常优秀的多媒体框架 FFmpeg 可以运行在 Linux、Mac、Windows 等平台上 能够解码、编码、转码、复用、解复用、过滤音视频数据 FFmpeg 下载与安装： FFMpeg 下载与安装 123$ git clone https://git.ffmpeg.org/ffmpeg.git$ config -- help$ make &amp;&amp; make install 2. FFmpeg 常用命令实战我们按使用目的可以将 FFMPEG 命令分成以下几类： 基本信息查询命令 录制 分解 / 复用 处理原始数据 滤镜 切割与合并 图／视互转 直播相关 除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。 1$ ffplay -s 2560x1600 -pix_fmt uyvy422 out.yuv 3. 初级开发内容 FFmpeg 日志的使用及目录的操作 介绍 FFmpeg 的基本概念及常用的结构体 对复用/解复用及流程操作的各种实践 FFmpeg 代码结构： libavcodec： 提供了一系列编码器的实现。 libavformat： 实现在流协议，容器格式及其本IO访问。 libavutil： 包括了hash器，解码器和各类工具函数。 libavfilter： 提供了各种音视频过滤器。 libavdevice： 提供了访问捕获设备和回放设备的接口。 libswresample： 实现了混音和重采样。 libswscale： 实现了色彩转换和缩放工能。 3.1 FFmpeg 日志系统12345#include &lt;libavutil/log.h&gt;av_log_set_level(AV_LOG_DEBUG) av_log(NULL, AV_LOG_INFO, "...%s\n", op) AV_LOG_ERROR AV_LOG_WARNING AV_LOG_INFO FFmpeg日志系统使用 1234567891011#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;int main(int argc, char *argv[])&#123; av_log_set_level(AV_LOG_DEBUG); av_log(NULL, AV_LOG_INFO, "hello world: %s!\n", "aaa"); return 0;&#125; 3.2 FFmpeg 文件与目录操作文件的删除与重命名： 12345#include &lt;libavformat/avformat.h&gt;avpriv_io_delete() avpriv_io_move(src, dst) FFmpeg文件与目录操作 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; ret = avpriv_io_delete("./mytestfile.txt"); if(ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Failed to delete file mytestfile.txt\n"); return -1 &#125; ret = avpriv_io_move("111.txt", "222.txt"); if(ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Filed to rename\n"); return -1; &#125; return 0;&#125; 123456$ clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`# pkg-config --libs libavformat 指令可以搜索libavformat库所在路径$ pkg-config --libs libavformat-L/usr/local/ffmpeg/lib -lavformat 3.3 FFmpeg 操作目录重要函数123avio_open_dir()avio_read_dir()avio_close_dir() 操作目录重要结构体： AVIODirContext 操作目录的上下文 AVIODirEntry 目录项。用于存放文件名，文件大小等信息 FFmpeg操作目录 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; av_log_set_level(AV_LOG_INFO); int ret; AVIODirContext *ctx = NULL; AVIODirEntry *entry = NULL; ret = avio_open_dir(&amp;ctx, "./", NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Cant open dir:%s\n", av_err2str(ret)); return -1; &#125; while(1) &#123; ret = avio_read_dir(ctx, &amp;entry); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Cant read dir: %s\n", av_err2str(ret)); goto __fail; &#125; if (!entry) &#123; break; &#125; av_log(NULL, AV_LOG_INFO, "%l2"PRId64" %s\n", entry-&gt;size, entry-&gt;name); avio_free_directory_entry(&amp;entry); &#125;__fail: avio_close_dir(&amp;ctx); return 0;&#125; 1$ clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil` 3.4 多媒体文件的基本概念 多媒体文件其实是个容器 在容器里有很多流（Stream/Track) 每种流是由不同的编码器编码的 从流中读出的数据称为包 在一个包中包含着一个或多个帧 几个重要的结构体： AVFormatContext AVStream AVPacket FFmpeg 操作流数据的基本步骤： 解复用 —&gt; 获取流 —&gt; 读取数据包 —&gt; 释放资源 3.5 [实战] 打印音/视频信息123av_register_all()avformat_open_input() / avformat_close_input()av_dump_format() [实战] 打印音/视频信息 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; av_log_set_level(AV_LOG_INFO); AVFormatContext *fmt_ctx = NULL; av_register_all(); ret = avformat_open_input(&amp;fmt_ctx, "./test.mp4", NULL, NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Can't open file: %s\n", av_err2str(ret)); return -1; &#125; av_dump_format(fmt_ctx, 0, "./test.mp4", 0); avformat_close_input(&amp;fmt_ctx); return 0;&#125; 3.6 [实战] 抽取音频数据123av_init_packet()av_find_best_stream()av_read_frame() / av_packet_unref() [实战] 抽取音频数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;#include &lt;libavformat/avformat.h&gt;int main(int argc, char *argv[])&#123; int ret; int len; int audio_index; char *src = NULL; char *dst = NULL; av_log_set_level(AV_LOG_INFO); AVPacket pkt; AVFormatContext *fmt_ctx = NULL; av_register_all(); // 1. read two params form console if (argc &lt; 3) &#123; av_log(NULL, AV_LOG_ERROR, "eg: %s in_file out_file\n", argv[0]); return -1; &#125; src = argv[1]; dst = argv[2]; if (!src || !dst) &#123; av_log(NULL, AV_LOG_ERROR, "src or dst is null\n"); return -1; &#125; ret = avformat_open_input(&amp;fmt_ctx, src, NULL, NULL); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Can't open file: %s\n", av_err2str(ret)); return -1; &#125; FILE *dst_fd = fopen(dst, "wb"); if (dst_fd) &#123; av_log(NULL, AV_LOG_ERROR, "Can't open out file!\n"); avformat_close_input(&amp;fmt_ctx); return -1; &#125; av_dump_format(fmt_ctx, 0, src, 0); // 2. get stream ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, "Can't find the best stream!\n"); avformat_close_input(&amp;fmt_ctx); fclose(dst_fd); return -1; &#125; audio_index = ret; av_init_packet(&amp;pkt); while(av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123; if (pkt.stream_index == audio_index) &#123; // 3. write audio data to aac file. len = fwrite(pkt.data, 1, pkt.size, dst_fd); if (len != pkt.size) &#123; av_log(NULL, AV_LOG_WARNING, "warning, length of data is not equal size of pkt!\n"); &#125; &#125; av_packet_unref(&amp;pkt); &#125; avformat_close_input(&amp;fmt_ctx); if (dst_fd) &#123; fclose(dst_fd); &#125; return 0;&#125; 12$ lang -g -o extra_audio extra_audio.c `pkg-config --libs libavutil libavformat`$ ./extra_audio test.mp4 killer.aa 3.7 [实战] 抽取视频数据 Start code SPS/PPS codec -&gt; extradata 3.8 [实战] 将 MP4 转成 FLV 格式123456avformat_alloc_output_context2() / avformat_free_context();avformat_new_stream();avcodec_parameters_copy();avformat_write_header();av_write_frame() / av_interleaved_write_frame();av_write_trailer() 3.9 [实战] 从 MP4 截取一段视频1av_seek_frame() 从 MP4 截取一段视频代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdlib.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;static void log_packet(const AVFormatContext *fmt_ctx, const AVPacket *pkt, const char *tag)&#123; AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base; printf("%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n", tag, av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base), av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base), av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base), pkt-&gt;stream_index);&#125;int cut_video(double from_seconds, double end_seconds, const char* in_filename, const char* out_filename) &#123; AVOutputFormat *ofmt = NULL; AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVPacket pkt; int ret, i; av_register_all(); if ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0)) &lt; 0) &#123; fprintf(stderr, "Could not open input file '%s'", in_filename); goto end; &#125; if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &lt; 0) &#123; fprintf(stderr, "Failed to retrieve input stream information"); goto end; &#125; av_dump_format(ifmt_ctx, 0, in_filename, 0); avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, out_filename); if (!ofmt_ctx) &#123; fprintf(stderr, "Could not create output context\n"); ret = AVERROR_UNKNOWN; goto end; &#125; ofmt = ofmt_ctx-&gt;oformat; for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123; AVStream *in_stream = ifmt_ctx-&gt;streams[i]; AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec); if (!out_stream) &#123; fprintf(stderr, "Failed allocating output stream\n"); ret = AVERROR_UNKNOWN; goto end; &#125; ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec); if (ret &lt; 0) &#123; fprintf(stderr, "Failed to copy context from input to output stream codec context\n"); goto end; &#125; out_stream-&gt;codec-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER; &#125; av_dump_format(ofmt_ctx, 0, out_filename, 1); if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; fprintf(stderr, "Could not open output file '%s'", out_filename); goto end; &#125; &#125; ret = avformat_write_header(ofmt_ctx, NULL); if (ret &lt; 0) &#123; fprintf(stderr, "Error occurred when opening output file\n"); goto end; &#125; // int indexs[8] = &#123;0&#125;; // int64_t start_from = 8*AV_TIME_BASE; ret = av_seek_frame(ifmt_ctx, -1, from_seconds*AV_TIME_BASE, AVSEEK_FLAG_ANY); if (ret &lt; 0) &#123; fprintf(stderr, "Error seek\n"); goto end; &#125; int64_t *dts_start_from = malloc(sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); memset(dts_start_from, 0, sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); int64_t *pts_start_from = malloc(sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); memset(pts_start_from, 0, sizeof(int64_t) * ifmt_ctx-&gt;nb_streams); while (1) &#123; AVStream *in_stream, *out_stream; ret = av_read_frame(ifmt_ctx, &amp;pkt); if (ret &lt; 0) break; in_stream = ifmt_ctx-&gt;streams[pkt.stream_index]; out_stream = ofmt_ctx-&gt;streams[pkt.stream_index]; log_packet(ifmt_ctx, &amp;pkt, "in"); if (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123; av_free_packet(&amp;pkt); break; &#125; if (dts_start_from[pkt.stream_index] == 0) &#123; dts_start_from[pkt.stream_index] = pkt.dts; printf("dts_start_from: %s\n", av_ts2str(dts_start_from[pkt.stream_index])); &#125; if (pts_start_from[pkt.stream_index] == 0) &#123; pts_start_from[pkt.stream_index] = pkt.pts; printf("pts_start_from: %s\n", av_ts2str(pts_start_from[pkt.stream_index])); &#125; /* copy packet */ pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); if (pkt.pts &lt; 0) &#123; pkt.pts = 0; &#125; if (pkt.dts &lt; 0) &#123; pkt.dts = 0; &#125; pkt.duration = (int)av_rescale_q((int64_t)pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; log_packet(ofmt_ctx, &amp;pkt, "out"); printf("\n"); ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt); if (ret &lt; 0) &#123; fprintf(stderr, "Error muxing packet\n"); break; &#125; av_free_packet(&amp;pkt); &#125; free(dts_start_from); free(pts_start_from); av_write_trailer(ofmt_ctx); end: avformat_close_input(&amp;ifmt_ctx); /* close output */ if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) avio_closep(&amp;ofmt_ctx-&gt;pb); avformat_free_context(ofmt_ctx); if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123; fprintf(stderr, "Error occurred: %s\n", av_err2str(ret)); return 1; &#125; return 0;&#125;int main(int argc, char *argv[])&#123; if(argc &lt; 5)&#123; fprintf(stderr, "Usage: \ command startime, endtime, srcfile, outfile"); return -1; &#125; double startime = atoi(argv[1]); double endtime = atoi(argv[2]); cut_video(startime, endtime, argv[3], argv[4]); return 0;&#125; 3.10 [实战] 一个简单的小咖秀 将两个媒体文件中分别抽取音频与视频轨 将音频与视频轨合并成一个新文件 对音频与视频轨进行裁剪 4. FFmpeg 中级开发内容 FFmpeg H264 解码 FFmpeg H264 编码 FFmpeg AAC 解码 FFmpeg AAC 编码 4.1 FFmpeg H264 解码1#include &lt;libavcodec/avcodec.h&gt; 常用数据结构： AVCodec 编码器结构体 AVCodecContext 编码器上下文 AVFrame 解码后的帧 结构体内存的分配与释放： 123av_frame_alloc / av_frame_free();avcodec_alloc_context3();avcodec_free_context(); 解码步骤： 查找解码器（avcodec_find_decoder） 打开解码器（avcodec_open2） 解码（avcodec_decode_video2） 4.2 FFmpeg H264 编码H264编码流程： 查找编码器（avcodec_find_encoder_by_name） 设置参数，打开编码器（avcondec_open2） 编码（avcondec_encode_video2） 4.3 视频转图片TODO 4.4 FFmpeg AAC 编码 编码流程与视频相同 编码函数 avcodec_encodec_audio2 5. SDL 介绍 SDL 官网 SDL（Simple DirectMedia Layer） 是一套开放源代码的跨平台多媒体开发库 由 C 语言实现的跨平台的媒体开源库 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域 语法与子系统： SDL将功能分成下列数个子系统（subsystem）： Video（图像）—图像控制以及线程（thread）和事件管理（event）。 Audio（声音）—声音控制 Joystick（摇杆）—游戏摇杆控制 CD-ROM（光盘驱动器）—光盘媒体控制 Window Management（视窗管理）－与视窗程序设计集成 Event（事件驱动）－处理事件驱动 以下是一支用C语言写成、非常简单的SDL示例： 12345678910111213141516171819// Headers#include "SDL.h"// Main functionint main(int argc, char* argv[])&#123; // Initialize SDL if(SDL_Init(SDL_INIT_EVERYTHING) == -1) return(1); // Delay 2 seconds SDL_Delay(2000); // Quit SDL SDL_Quit(); // Return return 0;&#125; 上述程序会加载所有SDL子系统（出错则退出程序），然后暂停两秒，最后关闭SDL并退出程序。 5.1 SDL 编译与安装 下载 SDL 源码 生成Makefile configure –prefix=/usr/local 安装 sudo make -j 8 &amp;&amp; make install 5.2 使用 SDL 基本步骤 添加头文件 #include &lt;SDL.h&gt; 初始化 SDL 退出 SDL SDL 渲染窗口： 123SDL_Init() / SDL_Quit();SDL_CreateWindow() / SDL_DestoryWindow();SDL_CreateRender(); // 创建渲染器 1$ clang -g -o first_sdl first_sdl.c `pkg-config --libs sdl2` SDL 渲染窗口： 123SDL_CreateRender() / SDL_DestoryRenderer();SDL_RenderClear();SDL_RenderPresent(); 5.3 SDL 事件基本原理 SDL 将所有的事件都存放在一个队列中 所有对事件的操作，其实就是队列的操作 SDL 事件种类： SDL_WindowEvent：窗口事件 SDL_KeyboardEvent：键盘事件 SDL_MouseMotionEvent：鼠标事件 自定义事件 SDL 事件处理： 123SDL_PollEvent(); // 轮询检测SDL_WaitEvent(); // 常用的方式SDL_WaitEventTimeout(); 5.4 文理渲染SDL 渲染基本原理： SDL 文理相关 API： 12345SDL_CreateTexture();- format: YUV, RGB- access: Texture 类型， Target， StreamSDL_DestroyTexture(); SDL 渲染相关 API： 1234SDL_SetRenderTarget();SDL_RenderClear();SDL_RenderCopy();SDL_RenderPresent(); 5.5 [实战] YUV 视频播放器创建线程： 1234SDL_CreateThread();- fn: 线程执行函数- name: 线程名- data: 执行函数参数 SDL 更新文理： 12SDL_UpdateTexture();SDL_UpdateYUVTexture(); 5.6 SDL 播放音频播放音频基本流程： 播放音频的基本原则： 声卡向你要数据而不是你主动推给声卡 数据的多少由音频参数决定的 SDL 音频 API： 123SDL_OpenAudio() / SDL_CloseAudio();SDL_PauseAudio();SDL_MixAudio(); 5.7 实现 PCM 播放器TODO 6. 最简单的播放器 该播放器只实现视频播放 将 FFmpeg 与 SDL 结合到一起 通过 FFmpeg 解码视频数据 通过 SDL 进行渲染 1$ clang -g -o player2 player2.c `pkg-config --cflags --libs sdl2 libavformat libavutil libswscale libavcodec libswresample` 最简单的播放器之二： 可以同时播放音频与视频 使用队列存放音频包 6.1 多线程与锁为什么要用多线程： 多线程的好处 多线程带来的问题 线程的互斥与同步： 互斥 同步 大的任务分为很多小任务通过信号协调 锁与信号量： 锁的种类 通过信号进行同步 锁的中种类： 读写锁 自旋锁 可重入锁 SDL 线程的创建： 12SDL_CreateThread();SDL_WaitThread(); SDL 锁： 12SDL_CreateMutex() / SDL_DestroyMutex(); // 创建互斥量SDL_LockMutex() / SDL_UnlockMutex(); // 锁互斥量于解锁互斥量 SDL 条件变量： 12SDL_CreateCond() / SDL_DestroyCond();SDL_CondWait() / SDL_CondSignal(); 6.2 锁与条件变量的使用TODO 6.3 播放器线程模型 6.4 线程的退出机制 主线程接收到退出事件 解复用线程在循环分流时对 quit 进行判断 视频解码线程从视频流队列中取包时对 quit 进行判断 音视解码从音频流队列中取包时对 quit 进行判断 音视循环解码时对 quit 进行判断 在收到信号变量消息时对 quit 进行判断 6.5 音视频同步时间戳： PTS：Presentation timestamp 渲染时间戳 DTS：Decoding timestamp 解码时间戳 I（intra）/ B（bidirectional）/ P（predicted）帧 时间戳顺序： 实际帧顺序：I B B P 存放帧顺序：I P B B 解码时间戳：1 4 2 3 展示时间戳：1 2 3 4 由于有了 B 帧之后，它打乱了 PTS 时间戳，所以加了 DTS 解码时间戳。在大多数没有 B 帧的情况下 PTS 和 DTS 是一致的。 从哪儿获得 PTS： AVPacket 中的 PTS AVFrame 中的 PTS av_frame_get_best_effort_timestamp() 时间基： tbr：帧率 tbn：time base of stream 流的时间基 tbc：time base of codec 解码的时间基 计算当前帧的 PTS： PTS = PTS * av_q2d(video_stream-&gt;time_base) av_q2d(AVRotional a){ return a.num / (double)a.den; } 计算下一帧的 PTS： video_clock：预测的下一帧视频的 PTS frame_delay：1/tbr audio_clock：音频当前播放的时间戳 音视频同步的时候需要计算 audio_clock 和 video_clock，看视屏时间是在音频时间之前还是在音频时间之后，如果是在音频时间之前就立即播放，如果在音频时间之后需要 delay 一段时间播放（delay的时间计算：audio_clock - video_clock） 音视频同步方式： 视频同步到音频 音频同步到视频 音频和视频都同步到系统时钟 视频播放的基本思路： 一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的 PTS，然后设置一个定时器，当定时器超时时后，刷新新的视屏帧，如此反复操作。 最简单的播放器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;SDL.h&gt;#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libswresample/swresample.h&gt;// compatibility with newer API#if LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)#define av_frame_alloc avcodec_alloc_frame#define av_frame_free avcodec_free_frame#endif#define SDL_AUDIO_BUFFER_SIZE 1024#define MAX_AUDIO_FRAME_SIZE 192000 //channels(2) * data_size(2) * sample_rate(48000)#define MAX_AUDIOQ_SIZE (5 * 16 * 1024)#define MAX_VIDEOQ_SIZE (5 * 256 * 1024)#define AV_SYNC_THRESHOLD 0.01#define AV_NOSYNC_THRESHOLD 10.0#define SAMPLE_CORRECTION_PERCENT_MAX 10#define AUDIO_DIFF_AVG_NB 20#define FF_REFRESH_EVENT (SDL_USEREVENT)#define FF_QUIT_EVENT (SDL_USEREVENT + 1)#define VIDEO_PICTURE_QUEUE_SIZE 1#define DEFAULT_AV_SYNC_TYPE AV_SYNC_AUDIO_MASTER //AV_SYNC_VIDEO_MASTERtypedef struct PacketQueue &#123; AVPacketList *first_pkt, *last_pkt; int nb_packets; int size; SDL_mutex *mutex; SDL_cond *cond;&#125; PacketQueue;typedef struct VideoPicture &#123; AVPicture *bmp; int width, height; /* source height &amp; width */ int allocated; double pts;&#125; VideoPicture;typedef struct VideoState &#123; //multi-media file char filename[1024]; AVFormatContext *pFormatCtx; int videoStream, audioStream; //sync int av_sync_type; double external_clock; /* external clock base */ int64_t external_clock_time; double audio_diff_cum; /* used for AV difference average computation */ double audio_diff_avg_coef; double audio_diff_threshold; int audio_diff_avg_count; double audio_clock; double frame_timer; double frame_last_pts; double frame_last_delay; double video_clock; ///&lt;pts of last decoded frame / predicted pts of next decoded frame double video_current_pts; ///&lt;current displayed pts (different from video_clock if frame fifos are used) int64_t video_current_pts_time; ///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts //audio AVStream *audio_st; AVCodecContext *audio_ctx; PacketQueue audioq; uint8_t audio_buf[(MAX_AUDIO_FRAME_SIZE * 3) / 2]; unsigned int audio_buf_size; unsigned int audio_buf_index; AVFrame audio_frame; AVPacket audio_pkt; uint8_t *audio_pkt_data; int audio_pkt_size; int audio_hw_buf_size; //video AVStream *video_st; AVCodecContext *video_ctx; PacketQueue videoq; struct SwsContext *video_sws_ctx; struct SwrContext *audio_swr_ctx; VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE]; int pictq_size, pictq_rindex, pictq_windex; SDL_mutex *pictq_mutex; SDL_cond *pictq_cond; SDL_Thread *parse_tid; SDL_Thread *video_tid; int quit;&#125; VideoState;SDL_mutex *text_mutex;SDL_Window *win = NULL;SDL_Renderer *renderer;SDL_Texture *texture;enum &#123; AV_SYNC_AUDIO_MASTER, AV_SYNC_VIDEO_MASTER, AV_SYNC_EXTERNAL_MASTER,&#125;;FILE *yuvfd = NULL;FILE *audiofd = NULL;/* Since we only have one decoding thread, the Big Struct can be global in case we need it. */VideoState *global_video_state;void packet_queue_init(PacketQueue *q) &#123; memset(q, 0, sizeof(PacketQueue)); q-&gt;mutex = SDL_CreateMutex(); q-&gt;cond = SDL_CreateCond();&#125;int packet_queue_put(PacketQueue *q, AVPacket *pkt) &#123; AVPacketList *pkt1; if(av_dup_packet(pkt) &lt; 0) &#123; return -1; &#125; pkt1 = av_malloc(sizeof(AVPacketList)); if (!pkt1) return -1; pkt1-&gt;pkt = *pkt; pkt1-&gt;next = NULL; SDL_LockMutex(q-&gt;mutex); if (!q-&gt;last_pkt) q-&gt;first_pkt = pkt1; else q-&gt;last_pkt-&gt;next = pkt1; q-&gt;last_pkt = pkt1; q-&gt;nb_packets++; q-&gt;size += pkt1-&gt;pkt.size; SDL_CondSignal(q-&gt;cond); SDL_UnlockMutex(q-&gt;mutex); return 0;&#125;int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block)&#123; AVPacketList *pkt1; int ret; SDL_LockMutex(q-&gt;mutex); for(;;) &#123; if(global_video_state-&gt;quit) &#123; ret = -1; break; &#125; pkt1 = q-&gt;first_pkt; if (pkt1) &#123; q-&gt;first_pkt = pkt1-&gt;next; if (!q-&gt;first_pkt) q-&gt;last_pkt = NULL; q-&gt;nb_packets--; q-&gt;size -= pkt1-&gt;pkt.size; *pkt = pkt1-&gt;pkt; av_free(pkt1); ret = 1; break; &#125; else if (!block) &#123; ret = 0; break; &#125; else &#123; SDL_CondWait(q-&gt;cond, q-&gt;mutex); &#125; &#125; SDL_UnlockMutex(q-&gt;mutex); return ret;&#125;double get_audio_clock(VideoState *is) &#123; double pts; int hw_buf_size, bytes_per_sec, n; pts = is-&gt;audio_clock; /* maintained in the audio thread */ hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index; bytes_per_sec = 0; n = is-&gt;audio_ctx-&gt;channels * 2; if(is-&gt;audio_st) &#123; bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n; &#125; if(bytes_per_sec) &#123; pts -= (double)hw_buf_size / bytes_per_sec; &#125; return pts;&#125;double get_video_clock(VideoState *is) &#123; double delta; delta = (av_gettime() - is-&gt;video_current_pts_time) / 1000000.0; return is-&gt;video_current_pts + delta;&#125;double get_external_clock(VideoState *is) &#123; return av_gettime() / 1000000.0;&#125;double get_master_clock(VideoState *is) &#123; if(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) &#123; return get_video_clock(is); &#125; else if(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) &#123; return get_audio_clock(is); &#125; else &#123; return get_external_clock(is); &#125;&#125;/* Add or subtract samples to get a better sync, return new audio buffer size */int synchronize_audio(VideoState *is, short *samples, int samples_size, double pts) &#123; int n; double ref_clock; n = 2 * is-&gt;audio_ctx-&gt;channels; if(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) &#123; double diff, avg_diff; int wanted_size, min_size, max_size /*, nb_samples */; ref_clock = get_master_clock(is); diff = get_audio_clock(is) - ref_clock; if(diff &lt; AV_NOSYNC_THRESHOLD) &#123; // accumulate the diffs is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum; if(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123; is-&gt;audio_diff_avg_count++; &#125; else &#123; avg_diff = is-&gt;audio_diff_cum * (1.0 - is-&gt;audio_diff_avg_coef); if(fabs(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123; wanted_size = samples_size + ((int)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n); min_size = samples_size * ((100 - SAMPLE_CORRECTION_PERCENT_MAX) / 100); max_size = samples_size * ((100 + SAMPLE_CORRECTION_PERCENT_MAX) / 100); if(wanted_size &lt; min_size) &#123; wanted_size = min_size; &#125; else if (wanted_size &gt; max_size) &#123; wanted_size = max_size; &#125; if(wanted_size &lt; samples_size) &#123; /* remove samples */ samples_size = wanted_size; &#125; else if(wanted_size &gt; samples_size) &#123; uint8_t *samples_end, *q; int nb; /* add samples by copying final sample*/ nb = (samples_size - wanted_size); samples_end = (uint8_t *)samples + samples_size - n; q = samples_end + n; while(nb &gt; 0) &#123; memcpy(q, samples_end, n); q += n; nb -= n; &#125; samples_size = wanted_size; &#125; &#125; &#125; &#125; else &#123; /* difference is TOO big; reset diff stuff */ is-&gt;audio_diff_avg_count = 0; is-&gt;audio_diff_cum = 0; &#125; &#125; return samples_size;&#125;int audio_decode_frame(VideoState *is, uint8_t *audio_buf, int buf_size, double *pts_ptr) &#123; int len1, data_size = 0; AVPacket *pkt = &amp;is-&gt;audio_pkt; double pts; int n; for(;;) &#123; while(is-&gt;audio_pkt_size &gt; 0) &#123; int got_frame = 0; len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt); if(len1 &lt; 0) &#123; /* if error, skip frame */ is-&gt;audio_pkt_size = 0; break; &#125; data_size = 0; if(got_frame) &#123; /* data_size = av_samples_get_buffer_size(NULL, is-&gt;audio_ctx-&gt;channels, is-&gt;audio_frame.nb_samples, is-&gt;audio_ctx-&gt;sample_fmt, 1); */ data_size = 2 * is-&gt;audio_frame.nb_samples * 2; assert(data_size &lt;= buf_size); swr_convert(is-&gt;audio_swr_ctx, &amp;audio_buf, MAX_AUDIO_FRAME_SIZE*3/2, (const uint8_t **)is-&gt;audio_frame.data, is-&gt;audio_frame.nb_samples); fwrite(audio_buf, 1, data_size, audiofd); //memcpy(audio_buf, is-&gt;audio_frame.data[0], data_size); &#125; is-&gt;audio_pkt_data += len1; is-&gt;audio_pkt_size -= len1; if(data_size &lt;= 0) &#123; /* No data yet, get more frames */ continue; &#125; pts = is-&gt;audio_clock; *pts_ptr = pts; n = 2 * is-&gt;audio_ctx-&gt;channels; is-&gt;audio_clock += (double)data_size / (double)(n * is-&gt;audio_ctx-&gt;sample_rate); /* We have data, return it and come back for more later */ return data_size; &#125; if(pkt-&gt;data) av_free_packet(pkt); if(is-&gt;quit) &#123; return -1; &#125; /* next packet */ if(packet_queue_get(&amp;is-&gt;audioq, pkt, 1) &lt; 0) &#123; return -1; &#125; is-&gt;audio_pkt_data = pkt-&gt;data; is-&gt;audio_pkt_size = pkt-&gt;size; /* if update, update the audio clock w/pts */ if(pkt-&gt;pts != AV_NOPTS_VALUE) &#123; is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts; &#125; &#125;&#125;void audio_callback(void *userdata, Uint8 *stream, int len) &#123; VideoState *is = (VideoState *)userdata; int len1, audio_size; double pts; SDL_memset(stream, 0, len); while(len &gt; 0) &#123; if(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123; /* We have already sent all our data; get more */ audio_size = audio_decode_frame(is, is-&gt;audio_buf, sizeof(is-&gt;audio_buf), &amp;pts); if(audio_size &lt; 0) &#123; /* If error, output silence */ is-&gt;audio_buf_size = 1024 * 2 * 2; memset(is-&gt;audio_buf, 0, is-&gt;audio_buf_size); &#125; else &#123; audio_size = synchronize_audio(is, (int16_t *)is-&gt;audio_buf, audio_size, pts); is-&gt;audio_buf_size = audio_size; &#125; is-&gt;audio_buf_index = 0; &#125; len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index; if(len1 &gt; len) len1 = len; SDL_MixAudio(stream,(uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME); //memcpy(stream, (uint8_t *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1); len -= len1; stream += len1; is-&gt;audio_buf_index += len1; &#125;&#125;static Uint32 sdl_refresh_timer_cb(Uint32 interval, void *opaque) &#123; SDL_Event event; event.type = FF_REFRESH_EVENT; event.user.data1 = opaque; SDL_PushEvent(&amp;event); return 0; /* 0 means stop timer */&#125;/* schedule a video refresh in 'delay' ms */static void schedule_refresh(VideoState *is, int delay) &#123; SDL_AddTimer(delay, sdl_refresh_timer_cb, is);&#125;void video_display(VideoState *is) &#123; SDL_Rect rect; VideoPicture *vp; float aspect_ratio; int w, h, x, y; int i; vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex]; if(vp-&gt;bmp) &#123; SDL_UpdateYUVTexture(texture, NULL, vp-&gt;bmp-&gt;data[0], vp-&gt;bmp-&gt;linesize[0], vp-&gt;bmp-&gt;data[1], vp-&gt;bmp-&gt;linesize[1], vp-&gt;bmp-&gt;data[2], vp-&gt;bmp-&gt;linesize[2]); rect.x = 0; rect.y = 0; rect.w = is-&gt;video_ctx-&gt;width; rect.h = is-&gt;video_ctx-&gt;height; SDL_LockMutex(text_mutex); SDL_RenderClear( renderer ); SDL_RenderCopy( renderer, texture, NULL, &amp;rect); SDL_RenderPresent( renderer ); SDL_UnlockMutex(text_mutex); &#125;&#125;void video_refresh_timer(void *userdata) &#123; VideoState *is = (VideoState *)userdata; VideoPicture *vp; double actual_delay, delay, sync_threshold, ref_clock, diff; if(is-&gt;video_st) &#123; if(is-&gt;pictq_size == 0) &#123; schedule_refresh(is, 1); //fprintf(stderr, "no picture in the queue!!!\n"); &#125; else &#123; //fprintf(stderr, "get picture from queue!!!\n"); vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex]; is-&gt;video_current_pts = vp-&gt;pts; is-&gt;video_current_pts_time = av_gettime(); delay = vp-&gt;pts - is-&gt;frame_last_pts; /* the pts from last time */ if(delay &lt;= 0 || delay &gt;= 1.0) &#123; /* if incorrect delay, use previous one */ delay = is-&gt;frame_last_delay; &#125; /* save for next time */ is-&gt;frame_last_delay = delay; is-&gt;frame_last_pts = vp-&gt;pts; /* update delay to sync to audio if not master source */ if(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) &#123; ref_clock = get_master_clock(is); diff = vp-&gt;pts - ref_clock; /* Skip or repeat the frame. Take delay into account FFPlay still doesn't "know if this is the best guess." */ sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD; if(fabs(diff) &lt; AV_NOSYNC_THRESHOLD) &#123; if(diff &lt;= -sync_threshold) &#123; delay = 0; &#125; else if(diff &gt;= sync_threshold) &#123; delay = 2 * delay; &#125; &#125; &#125; is-&gt;frame_timer += delay; /* computer the REAL delay */ actual_delay = is-&gt;frame_timer - (av_gettime() / 1000000.0); if(actual_delay &lt; 0.010) &#123; /* Really it should skip the picture instead */ actual_delay = 0.010; &#125; schedule_refresh(is, (int)(actual_delay * 1000 + 0.5)); /* show the picture! */ video_display(is); /* update queue for next picture! */ if(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123; is-&gt;pictq_rindex = 0; &#125; SDL_LockMutex(is-&gt;pictq_mutex); is-&gt;pictq_size--; SDL_CondSignal(is-&gt;pictq_cond); SDL_UnlockMutex(is-&gt;pictq_mutex); &#125; &#125; else &#123; schedule_refresh(is, 100); &#125;&#125; void alloc_picture(void *userdata) &#123; int ret; VideoState *is = (VideoState *)userdata; VideoPicture *vp; vp = &amp;is-&gt;pictq[is-&gt;pictq_windex]; if(vp-&gt;bmp) &#123; // we already have one make another, bigger/smaller avpicture_free(vp-&gt;bmp); free(vp-&gt;bmp); vp-&gt;bmp = NULL; &#125; // Allocate a place to put our YUV image on that screen SDL_LockMutex(text_mutex); vp-&gt;bmp = (AVPicture*)malloc(sizeof(AVPicture)); ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height); if (ret &lt; 0) &#123; fprintf(stderr, "Could not allocate temporary picture: %s\n", av_err2str(ret)); &#125; SDL_UnlockMutex(text_mutex); vp-&gt;width = is-&gt;video_ctx-&gt;width; vp-&gt;height = is-&gt;video_ctx-&gt;height; vp-&gt;allocated = 1;&#125;int queue_picture(VideoState *is, AVFrame *pFrame, double pts) &#123; VideoPicture *vp; /* wait until we have space for a new pic */ SDL_LockMutex(is-&gt;pictq_mutex); while(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit) &#123; SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex); &#125; SDL_UnlockMutex(is-&gt;pictq_mutex); if(is-&gt;quit) return -1; // windex is set to 0 initially vp = &amp;is-&gt;pictq[is-&gt;pictq_windex]; /* allocate or resize the buffer! */ if(!vp-&gt;bmp || vp-&gt;width != is-&gt;video_ctx-&gt;width || vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123; vp-&gt;allocated = 0; alloc_picture(is); if(is-&gt;quit) &#123; return -1; &#125; &#125; /* We have a place to put our picture on the queue */ if(vp-&gt;bmp) &#123; vp-&gt;pts = pts; // Convert the image into YUV format that SDL uses sws_scale(is-&gt;video_sws_ctx, (uint8_t const * const *)pFrame-&gt;data, pFrame-&gt;linesize, 0, is-&gt;video_ctx-&gt;height, vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize); /* now we inform our display thread that we have a pic ready */ if(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123; is-&gt;pictq_windex = 0; &#125; SDL_LockMutex(is-&gt;pictq_mutex); is-&gt;pictq_size++; SDL_UnlockMutex(is-&gt;pictq_mutex); &#125; return 0;&#125;double synchronize_video(VideoState *is, AVFrame *src_frame, double pts) &#123; double frame_delay; if(pts != 0) &#123; /* if we have pts, set video clock to it */ is-&gt;video_clock = pts; &#125; else &#123; /* if we aren't given a pts, set it to the clock */ pts = is-&gt;video_clock; &#125; /* update the video clock */ frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base); /* if we are repeating a frame, adjust clock accordingly */ frame_delay += src_frame-&gt;repeat_pict * (frame_delay * 0.5); is-&gt;video_clock += frame_delay; return pts;&#125;int decode_video_thread(void *arg) &#123; VideoState *is = (VideoState *)arg; AVPacket pkt1, *packet = &amp;pkt1; int frameFinished; AVFrame *pFrame; double pts; pFrame = av_frame_alloc(); for(;;) &#123; if(packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0) &#123; // means we quit getting packets break; &#125; pts = 0; // Decode video frame avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet); if((pts = av_frame_get_best_effort_timestamp(pFrame)) != AV_NOPTS_VALUE) &#123; &#125; else &#123; pts = 0; &#125; pts *= av_q2d(is-&gt;video_st-&gt;time_base); // Did we get a video frame? if(frameFinished) &#123; pts = synchronize_video(is, pFrame, pts); if(queue_picture(is, pFrame, pts) &lt; 0) &#123; break; &#125; &#125; av_free_packet(packet); &#125; av_frame_free(&amp;pFrame); return 0;&#125;int stream_component_open(VideoState *is, int stream_index) &#123; AVFormatContext *pFormatCtx = is-&gt;pFormatCtx; AVCodecContext *codecCtx = NULL; AVCodec *codec = NULL; SDL_AudioSpec wanted_spec, spec; if(stream_index &lt; 0 || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123; return -1; &#125; codecCtx = avcodec_alloc_context3(NULL); int ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar); if (ret &lt; 0) return -1; codec = avcodec_find_decoder(codecCtx-&gt;codec_id); if(!codec) &#123; fprintf(stderr, "Unsupported codec!\n"); return -1; &#125; if(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; // Set audio settings from codec info wanted_spec.freq = codecCtx-&gt;sample_rate; wanted_spec.format = AUDIO_S16SYS; wanted_spec.channels = 2;//codecCtx-&gt;channels; wanted_spec.silence = 0; wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE; wanted_spec.callback = audio_callback; wanted_spec.userdata = is; fprintf(stderr, "wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \n", 2, AUDIO_S16SYS, codecCtx-&gt;sample_rate); if(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; 0) &#123; fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError()); return -1; &#125; is-&gt;audio_hw_buf_size = spec.size; &#125; if(avcodec_open2(codecCtx, codec, NULL) &lt; 0) &#123; fprintf(stderr, "Unsupported codec!\n"); return -1; &#125; switch(codecCtx-&gt;codec_type) &#123; case AVMEDIA_TYPE_AUDIO: is-&gt;audioStream = stream_index; is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index]; is-&gt;audio_ctx = codecCtx; is-&gt;audio_buf_size = 0; is-&gt;audio_buf_index = 0; memset(&amp;is-&gt;audio_pkt, 0, sizeof(is-&gt;audio_pkt)); packet_queue_init(&amp;is-&gt;audioq); //Out Audio Param uint64_t out_channel_layout=AV_CH_LAYOUT_STEREO; //AAC:1024 MP3:1152 int out_nb_samples= is-&gt;audio_ctx-&gt;frame_size; //AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; int out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate; int out_channels=av_get_channel_layout_nb_channels(out_channel_layout); //Out Buffer Size /* int out_buffer_size=av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, AV_SAMPLE_FMT_S16, 1); */ //uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2); int64_t in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels); struct SwrContext *audio_convert_ctx; audio_convert_ctx = swr_alloc(); swr_alloc_set_opts(audio_convert_ctx, out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate, 0, NULL); fprintf(stderr, "swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d", out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate); swr_init(audio_convert_ctx); is-&gt;audio_swr_ctx = audio_convert_ctx; SDL_PauseAudio(0); break; case AVMEDIA_TYPE_VIDEO: is-&gt;videoStream = stream_index; is-&gt;video_st = pFormatCtx-&gt;streams[stream_index]; is-&gt;video_ctx = codecCtx; is-&gt;frame_timer = (double)av_gettime() / 1000000.0; is-&gt;frame_last_delay = 40e-3; is-&gt;video_current_pts_time = av_gettime(); packet_queue_init(&amp;is-&gt;videoq); is-&gt;video_sws_ctx = sws_getContext( is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BILINEAR, NULL, NULL, NULL); is-&gt;video_tid = SDL_CreateThread(decode_video_thread, "decode_video_thread", is); break; default: break; &#125;&#125;int demux_thread(void *arg) &#123; int err_code; char errors[1024] = &#123;0,&#125;; VideoState *is = (VideoState *)arg; AVFormatContext *pFormatCtx; AVPacket pkt1, *packet = &amp;pkt1; int video_index = -1; int audio_index = -1; int i; is-&gt;videoStream=-1; is-&gt;audioStream=-1; global_video_state = is; /* open input file, and allocate format context */ if ((err_code=avformat_open_input(&amp;pFormatCtx, is-&gt;filename, NULL, NULL)) &lt; 0) &#123; av_strerror(err_code, errors, 1024); fprintf(stderr, "Could not open source file %s, %d(%s)\n", is-&gt;filename, err_code, errors); return -1; &#125; is-&gt;pFormatCtx = pFormatCtx; // Retrieve stream information if(avformat_find_stream_info(pFormatCtx, NULL)&lt;0) return -1; // Couldn't find stream information // Dump information about file onto standard error av_dump_format(pFormatCtx, 0, is-&gt;filename, 0); // Find the first video stream for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123; if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp; video_index &lt; 0) &#123; video_index=i; &#125; if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp; audio_index &lt; 0) &#123; audio_index=i; &#125; &#125; if(audio_index &gt;= 0) &#123; stream_component_open(is, audio_index); &#125; if(video_index &gt;= 0) &#123; stream_component_open(is, video_index); &#125; if(is-&gt;videoStream &lt; 0 || is-&gt;audioStream &lt; 0) &#123; fprintf(stderr, "%s: could not open codecs\n", is-&gt;filename); goto fail; &#125; //creat window from SDL win = SDL_CreateWindow("Media Player", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE); if(!win) &#123; fprintf(stderr, "SDL: could not set video mode - exiting\n"); exit(1); &#125; renderer = SDL_CreateRenderer(win, -1, 0); //IYUV: Y + U + V (3 planes) //YV12: Y + V + U (3 planes) Uint32 pixformat= SDL_PIXELFORMAT_IYUV; //create texture for render texture = SDL_CreateTexture(renderer, pixformat, SDL_TEXTUREACCESS_STREAMING, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height); // main decode loop for(;;) &#123; if(is-&gt;quit) &#123; break; &#125; // seek stuff goes here if(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123; SDL_Delay(10); continue; &#125; if(av_read_frame(is-&gt;pFormatCtx, packet) &lt; 0) &#123; if(is-&gt;pFormatCtx-&gt;pb-&gt;error == 0) &#123; SDL_Delay(100); /* no error; wait for user input */ continue; &#125; else &#123; break; &#125; &#125; // Is this a packet from the video stream? if(packet-&gt;stream_index == is-&gt;videoStream) &#123; packet_queue_put(&amp;is-&gt;videoq, packet); &#125; else if(packet-&gt;stream_index == is-&gt;audioStream) &#123; packet_queue_put(&amp;is-&gt;audioq, packet); &#125; else &#123; av_free_packet(packet); &#125; &#125; /* all done - wait for it */ while(!is-&gt;quit) &#123; SDL_Delay(100); &#125;fail: if(1)&#123; SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&amp;event); &#125; return 0;&#125;int main(int argc, char *argv[]) &#123; SDL_Event event; VideoState *is; is = av_mallocz(sizeof(VideoState)); if(argc &lt; 2) &#123; fprintf(stderr, "Usage: test &lt;file&gt;\n"); exit(1); &#125; yuvfd = fopen("testout.yuv", "wb+"); audiofd = fopen("testout.pcm", "wb+"); // Register all formats and codecs av_register_all(); if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; fprintf(stderr, "Could not initialize SDL - %s\n", SDL_GetError()); exit(1); &#125; text_mutex = SDL_CreateMutex(); av_strlcpy(is-&gt;filename, argv[1], sizeof(is-&gt;filename)); is-&gt;pictq_mutex = SDL_CreateMutex(); is-&gt;pictq_cond = SDL_CreateCond(); schedule_refresh(is, 40); is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE; is-&gt;parse_tid = SDL_CreateThread(demux_thread,"demux_thread", is); if(!is-&gt;parse_tid) &#123; av_free(is); return -1; &#125; for(;;) &#123; SDL_WaitEvent(&amp;event); switch(event.type) &#123; case FF_QUIT_EVENT: case SDL_QUIT: is-&gt;quit = 1; SDL_Quit(); return 0; break; case FF_REFRESH_EVENT: video_refresh_timer(event.user.data1); break; default: break; &#125; &#125; fclose(yuvfd); fclose(audiofd); return 0;&#125; 7. 如何在 Android 下使用 FFmpegAndroid 架构： 内容： Java 与 C 之间的相互调用 Android 下 FFmpeg 的编译 Android 下如何使用FFmpeg 第一个 JNI 程序： TODO JNI 基本概念： JNIEnv JavaVM 一个Android APP只有一个 JavaVM， 一个 JavaVM 可以有多个JNIEnv 线程 一个线程对应一个JNIEnv Java调用C/C++ 方法一： 在Java层定义 native 关键字函数 方法一：在C/C++层创建 Java_packname_classname_methodname 函数 Java调用C/C++方法二： 什么是Signature： Java与C/C++ 相互调用时，表式函数参数的描述符 输入参数放在（）内，输出参数放在（）外 多个参数之间顺序存放，且用 “；” 分割 C/C++ 调用 Java 方法： FindClass GetMethodID / GetFieldID NewObject Call&lt;TYPE&gt;Method / [G/S]et&lt;type&gt;Field 7.1 [实战] Android 下的播放器TODO 8. IOS 下使用 FFmpegTODO 9. 音视频进阶 FFmpeg Filter 的使用 FFmpeg 裁剪与优化 视频渲染（OpenGL / Metal） 声音的特效 网络传输 Webrtc - 实时互动、直播、P2P音视频传输 AR技术 OpenCV 行业痛点： 回音消除 降噪 视频秒开 多人多视频实时互动 PC端/APP/网页实时视频互通 实时互动与大并发负载 FFmpeg音视频同步原理与实现 音视频同步解决方案 一种基于FFMPEG的音视频同步算法 音视频同步原理如果简单的按照音频的采样率与视频的帧率去播放，由于机器运行速度，解码效率等种种造成时间差异的因素影响，很难同步，音视频时间差将会呈现线性增长。所以要做音视频的同步，有三种方式： 参考一个外部时钟，将音频与视频同步至此时间。我首先想到这种方式，但是并不好，由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以频繁的去调整声音的播放会有些刺耳或者杂音吧影响用户体验。（ps：顺便科普生物学知识，自我感觉好高大上_）。 以视频为基准，音频去同步视频的时间。不采用，理由同上。 以音频为基准，视频去同步音频的时间。 所以这个办法了。 所以，原理就是以音频时间为基准，判断视频快了还是慢了，从而调整视频速度。其实是一个动态的追赶与等待的过程。 一些概念音视频中都有 DTS 与 PTS。 DTS ，Decoding Time Stamp，解码时间戳，告诉解码器packet的解码顺序。 PTS ，Presentation Time Stamp，显示时间戳，指示从packet中解码出来的数据的显示顺序。 音频中二者是相同的，但是视频由于B帧（双向预测）的存在，会造成解码顺序与显示顺序并不相同，也就是视频中 DTS 与 PTS 不一定相同。 时间基 : 看 FFmpeg 源码 12345678AVRational time_base;/*** rational number numerator/denominator*/typedef struct AVRational&#123; int num; ///&lt; numerator int den; ///&lt; denominator&#125; AVRational; 个人理解，其实就是 ffmpeg中 的用分数表示时间单位，num 为分子，den 为分母。并且 ffmpeg 提供了计算方法： 12345678/*** Convert rational to double.* @param a rational to convert* @return (double) a*/static inline double av_q2d(AVRational a)&#123; return a.num / (double) a.den;&#125; 所以 视频中某帧的显示时间 计算方式为(单位为妙)： 1time = pts * av_q2d(time_base); 同步代码音频部分 clock 为音频的播放时长（从开始到当前的时间） 123if (packet-&gt;pts != AV_NOPTS_VALUE) &#123; audio-&gt;clock = av_q2d(audio-&gt;time_base) * packet-&gt;pts;&#125; 然后加上此 packet 中数据需要播放的时间 12double time = datalen/((double) 44100 *2 * 2);audio-&gt;clock = audio-&gt;clock +time; datalen 为数据长度。采样率为 44100，采样位数为 16，通道数为 2。所以 数据长度 / 每秒字节数。 ps：此处计算方式不是很完美，有很多问题，回头研究在再补上。 视频部分 先定义几个值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263double last_play //上一帧的播放时间 ,play //当前帧的播放时间 , last_delay // 上一次播放视频的两帧视频间隔时间 ,delay //两帧视频间隔时间 ,audio_clock //音频轨道 实际播放时间 ,diff //音频帧与视频帧相差时间 ,sync_threshold //合理的范围 ,start_time //从第一帧开始的绝对时间 ,pts ,actual_delay//真正需要延迟时间 start_time = av_gettime() / 1000000.0;// 获取pts if ((pts = av_frame_get_best_effort_timestamp(frame)) == AV_NOPTS_VALUE) &#123; pts = 0; &#125; play = pts * av_q2d(vedio-&gt;time_base);// 纠正时间 play = vedio-&gt;synchronize(frame, play); delay = play - last_play; if (delay &lt;= 0 || delay &gt; 1) &#123; delay = last_delay; &#125; audio_clock = vedio-&gt;audio-&gt;clock; last_delay = delay; last_play = play;//音频与视频的时间差 diff = vedio-&gt;clock - audio_clock;// 在合理范围外 才会延迟 加快 sync_threshold = (delay &gt; 0.01 ? 0.01 : delay); if (fabs(diff) &lt; 10) &#123; if (diff &lt;= -sync_threshold) &#123; delay = 0; &#125; else if (diff &gt;= sync_threshold) &#123; delay = 2 * delay; &#125; &#125; start_time += delay; actual_delay = start_time - av_gettime() / 1000000.0; if (actual_delay &lt; 0.01) &#123; actual_delay = 0.01; &#125;// 休眠时间 ffmpeg 建议这样写 为什么 要这样写 有待研究 av_usleep(actual_delay * 1000000.0 + 6000);纠正play （播放时间）的方法 repeat_pict / (2 * fps) 是ffmpeg注释里教的synchronize(AVFrame *frame, double play) &#123; //clock是当前播放的时间位置 if (play != 0) clock=play; else //pst为0 则先把pts设为上一帧时间 play = clock; //可能有pts为0 则主动增加clock //需要求出扩展延时： double repeat_pict = frame-&gt;repeat_pict; //使用AvCodecContext的而不是stream的 double frame_delay = av_q2d(codec-&gt;time_base); //fps double fps = 1 / frame_delay; //pts 加上 这个延迟 是显示时间 double extra_delay = repeat_pict / (2 * fps); double delay = extra_delay + frame_delay; clock += delay; return play;&#125; FFmpeg 痛点解决回音消除解决方案： 语音自适应回声消除（AEC）算法 回声消除(AEC)原理 音频降噪在 58 直播中的研究与实现 视频秒开： 直播视频秒开及视频优化 视频直播秒开背后的技术与优化经验 短视频“秒播”那点事 百度LSS 音视频直播 秒开 播放器的“妥协”造就了视频“秒开”的实现！ 多人视频实时互动： WebRTC现状以及多人视频通话分析 多人视频连麦——直播高效互动方式 实时互动与大并发负载： RTP直播分发服务器集群方案 海量用户实时互动直播架构探索 直播开发过程中关于直播技术的架构问题]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频入门知识]]></title>
    <url>%2F2019%2F04%2F23%2FFFmpeg%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[H264基本原理 1. 万人直播架构讲解直播产品的种类： 泛娱乐化直播 花椒、映客等娱乐直播，还有斗鱼、熊猫等游戏直播 实时互动直播 音视频会议、教育直播等，像 思科、全时、声网 泛娱乐化直播架构 信令服务器：创建房间、聊天、礼物。。。。 美女主播 –信令–&gt; 信令服务器 信令服务器–rtmp流地址–&gt;美女主播 美女主播 –推流–&gt; 流媒体云CDN 观众 –信令–&gt; 信令服务器：将观众加入到美女主播间 信令服务器–rmtp流地址–&gt; 观众 观众 &lt;–拉流–&gt; 流媒体云CDN 泛娱乐化直播架构 基于TCP协议实现 发送信令到信令服务器, 服务器收到\执行后, 返回给共享端一个流媒体云的地址 共享端采集自己音视频数据, 形成rtmp流, 推送到CDN网络(推流) 获取流媒体云地址 拉流 实时互动直播架构 基于UDP实现 自有网络: UDP没有自有网络, 需自己搭建 多个节点: 为了保障服务的稳定性以及负载均衡 控制中心: 每个节点定期(心跳)向控制中心报告健康程度, 控制中心根据响应的数据做出决策 内总线: 数据安全性\吞吐量等可靠性得以保障 媒体服务器: 将RTP协议的数据转换成RTMP协议的数据 CDN网络: 根据用户需求进行拉流 2. CDN网络介绍 CDN网络是为了解决什么问题而出现的？ 总结为一句话：CDN网络是为了解决用户访问网络资源慢而出现的一个技术，两个原因： 网络链路太长 人为因素（南电信北联通，利益相关） CDN构成： 边缘结点：用户从边缘节点上获取数据 二级节点：主干网节点，主要用于缓存、减转源站压力 源站：CP(内容提供方)将内容放到源站 查找顺序：边缘结点-&gt;二级节点-&gt;源站 3. 亲手搭建一套简单的直播系统安装nginx 配置rtmp 123456$ brew install nginx-full --with-rtmp-module#(这一步卡了我好久，安装nginx提示一直找不到nginx-full,网上相关的教程没更新，原因在于nginx仓库已搬迁)$ brew tap denji/nginx$ nginx -s reload 重启$ nginx 启动 1$ vi /usr/local/etc/nginx/nginx.conf 12345# 推流$ ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName# 拉流$ ffmpeg -i rtmp://server/live/streamName -c copy dump.flv 4. 音频基础知识 图一音量：甲乙的振动频率相同、振幅不同。图二音调：甲乙振幅相同、频率不同 5. 音频的量化与编码模拟信号进行采样，采样时分频率的从模拟信号获取数据波形值，采样后，进行数据量化，量化后进行编码，把采样的十进制转化为计算机的二进制，也就是数字信号。 模拟数据——》采样——》量化——》编码——》数字信号 采样大小决定了音频的振幅的高度，采样时指一个采样用多少bit存放，常用的是16bit 12345# bit：位 一个二进制数据0或1，是1bit# byte：字节 存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；# 1 Byte = 8 Bit = 1 字节# 2^8 = 256, 2^16 = 65535 aac通常44.1k采样率 采样率:采样频率8k/秒、16k/秒、32k/秒、44.1k/秒、48k/秒 什么是音频的采样率？采样率和音质有没有关系？ - 知乎 人能听到的声音范围是20hz-2whz 码率 = 采样率 x 采样大小 x 声道数 12# 宽带速率的单位用 bps(或b/s)表示# 1 B = 8 b 1 B/s = 8 b/s 原始的wav文件，大小是1411.2Kb/s 做完aaclc的编码，大小是128Kb/s 如果是aache-vr这种编码，大小是32Kb/s 6. 音频压缩技术讲解音频压缩技术 1、消除冗余数据（有损压缩技术）。 压缩的主要方法是去除采集到的音频冗余信息，所谓冗余信息包括人耳听觉范围外的音频信号以及被掩蔽掉的音频信号 信号的掩蔽可分为频域掩蔽和时域掩蔽 频域掩蔽：一个强纯音会掩蔽在其附近同时发声的弱纯音。也称同时掩蔽 时域掩蔽：在时间上相邻的声音之间也有掩蔽现象，主要原因是人的大脑处理信息需要花费时间。 同步掩蔽效应和不同频率声音的频率和相对竟是有关，而时间掩蔽则仅仅和时间有关。如果两个声音在时间上特别接近，分辨会有困难（如两个声音音量相差较大且两个声音间隔时间低于5毫秒，则其中弱的那个声音会听不到）。 2、哈夫曼无损编码 音频压缩：频域，时域。 频域: 截取人耳能听到的频率范围，滤掉响度低的声音，去掉某个高频周围低频的声音； 时域: 滤掉某个长时间说话中的低音 7. 音频编解码器选型网上测评结果：音频编解码器 opus &gt; aac &gt; vorbis 音频编解码器： 1：opus， 口模型：实时互动，对实时性要求非常高 耳模型：高保真，对质量要求非常高 至于什么时候使用那个模型，由opus自己内部来决定，同时，他是性能最好的，压缩率最好。 2：AAC，经常用于泛娱乐化直播，因为其对实时性要求不是很高但是对音质要求可能较高，所以，选用AAC，当然也可以选用opus的耳模型 3：sppex，最大的特点就是不仅可以编码音频，还可以对音频进行降噪，优化，尽可能的获取原音频数据 4：G.711(722)，主要用于音视频会议，为了和固话进行相应的融合 8. AAC 讲解cdn，rtmp 支持 aac AAC 产生的目的是取代 MP3 格式： AAC 相对优点：压缩率高，损耗低 aac 三种类型aacaacv1: aac+sbr(频率复用-高频部分采样率高，低频部分采样率低)aacv2: aac+sbr+ps(声道关联，一个声道采集全部，一个声道只采集相对不同的声音) AAC规格描述（AAC、AAC HE、AAC HE V2）–&gt; AAC+SBR=AAC HE V1, AAC + SBR + PS = AAC HE V2 AAC格式： 1、ADIF(Audio Data Interchange Format):只能从头开始解码，常用在磁盘文件中。 2、ADTS(Audio Data Transport Stream)：这种格式每一帧都有一个同步字，可以在音频流的任何位置开始解码，它似于数据流格式（缺点：文件比ADIF大，优点:每个帧都可以被单独解码播放） aac 编码库 ffmpeg AAC，libfdk AAC 9. 视频基本知识I帧：关键帧，采用帧内压缩技术 P帧：向前参考帧，压缩时只参考前一个帧，属于帧间压缩技术 B帧：双向参考帧，压缩时即参考前一帧也参考后一帧，属于帧间压缩技术 一般实时互动都不会使用 B 帧 GOF(group of frame): 一组帧，可以将一段时间内画面变化不大的所有帧划为一组帧 SPS与PPS（这两种都划为 I 帧）： SPS(Sequence Parameter Set): 序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。 PPS(Picture Parameter Set): 图像参数集，存放熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系统数调整标识等 视频花屏/卡顿原因： 1、如果 GOP 分组中的 P 帧丢失会造成解码端的图像发生错误（于是形成了花屏）。 2、为了避免花屏问题的发生，一般如果发现 P 帧或者I帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像（因为丢了一组数据，所以形成了卡顿） 视频编码器： 1、x264/x265。 2、openH264(支持 SVC（分层传输） 技术)。 3、vp8/vp9 10. H264 宏块的划分与帧分组H264压缩技术 帧内预测压缩，解决的是空域数据冗余问题（将一幅图里的人眼不是很敏感的色彩、光亮等数据剔除） 帧间预测压缩，解决的是时域数据冗余问题（将一组图里面连续的重复性高的帧剔除） 整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化 CABAC压缩，也叫上下文适应无损压缩 宏块的划分与分组： H264宏块划分与子块划分：宏块里面可以再包含很多子块 子块划分： 帧分组(一组连续的图片，一幅图片为一帧) 11. 视频压缩技术详解 帧间预测: 解决时间数据冗余，比较相邻两帧不同给出运动矢量 + 残差值 帧内预测: 解决空间数据冗余，每一个宏块有一个预测模式，然后讲预测后的图像与原图比较算差值，最后存储预测模式和差值即可。帧内压缩是针对于 I 帧的 11.1 帧间预测组内宏块查找： 11.2 帧内预测 11.3 DCT 压缩 11.4 VLC 压缩 11.5 CABAC 压缩 12. H264 结构与码流H264编码分层： 1、NAL层（Network Abstraction Layer）, 视频数据网络抽象层。 2、VCL层（Video Coding Layer），视频数据编码层，对原始数据进行压缩 码流基本概念： 1、SODB（String Of Data Bits）,原始数据比特流，长度不一定是8的倍数，它是由VCL层产生的。 2、RBSP（Raw Byte Sequence Payload,SODB+trailing bits），算法是在SODB最后一位补1，不按字节对齐则补0。 3、EBSP(Encapsulate Byte Sequence Payload)，需到两个连续的0x00就增加一个0x03。 4、NALU，NAL Header(1B)+EBSP 以太网最大传输字节 1500 字节。 一个H264帧最少要有一个切片(NAL Unit) 切片与宏块的关系： 每个切片都包括切片头和切片数据， 每个切片数据又包括了很多宏块， 每个宏块又包括了宏块的类型、宏块的预测、编码的残渣数据等 13. NAL 单元详解 5 - 关键帧 7- SPS 序列参数集 8- PPS 图像参数集 如： P帧B帧很多都是单一类型。 SPS和PPS这两个NAL单元一般放在同一个RTP包里头 14. YUV 讲解 YUV常见格式：YUV4:2:0、YUV4:2:2、YUV4:4:4 RGB8:8:8 UV 混存则为packed(打包存储)， UV分开存则为planar(平面存储) 15. 总结 rtmp 实时消息传输: tcp/ip 应用层协议 推送/直播 基本数据单元为消息 1B 消息类型 2B 长度 3B 时间 4B 流id 消息体 传输时 消息回被拆分成消息块 chunk chunk header + chunk data flv: 大块音视频 加入标记头信息 延迟表现和大规模并发成熟 HLS：分成5-10s 用m3u8索引管理 用于朋友圈分享 m3u8索引： 直播信号源–视频编码器（后台视频处理）–流切片器–各种ts媒体文件（分发模块）–索引文件（数据库）–客户端 cdn网络 为了解决用户访问资源慢出现的技术 边缘节点 二级节点（大城市） 源站 搭建流媒体服务： 准备流媒体服务器 linux max 编译安装nginx服务 配置rtmp服务并启动nginx服务 声音三要素：音调 音量 音色 音频量化(模数转换)：模拟数据 采样 量化 编码 数字信号 == 0101001110 码率 = 采样率（1.6w/44.1/48k）x 采样大小(8位-电话/16位-常见) x 声道数（单/双） 音频压缩： 有损消除冗余数据 哈夫曼无损编码 音频编码： 时域转频域—心里声学模型—量化编码—比特流格式化—比特流 音频编解码 ： opus（口 耳 实时互动 最快） aac(直播用 次快) speed(回音 降噪等) g.711（固话） aac : 取代mp3 加入 sir ps 技术 aac lc 128k / aac he v2 64k / aac he v2 32k/ aac 格式 ： adif 从头开始解码，用在磁盘文件中 adts 每一帧都有一个同步字，可以在任何位置解码 aac 编码库 ： libfdk_aac &gt; ffmpeg aac &gt;libfaac&gt; libvo_aacenc H264： I帧 关键 帧内压缩 / p帧 向前参考1帧 / B帧 双向参考帧 sps: 序列参数集/pps:图像参数集 GOF： 一组帧数 p帧丢失 会花屏卡顿 视频编码器： x264/x265 /open h264(svc)/vp8/vp9 h264 压缩技术-编码原理： 帧内预测压缩，空域冗余数据/帧间预测压缩，时域冗余数据/dcp整数离散余炫变换，傅立叶变换/cabac压缩 h264结构：视频序列–图像–片–宏块–子快 h264编码分层：nal 视频数据网络抽象层–vcl 视频数据编码层 码率：sodb 原始比特流 / rbsp sodb最后补1 / ebsp 起始码增加一个起始位0x03 / nalu nal+ebsp nal unit = nalu 头部 + 一个切片（头/数据） 切片 yuv格式：4：4:4/4:4:2/4：2:0 （平坦编码 /半平坦编码）]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg入门]]></title>
    <url>%2F2019%2F04%2F20%2FFFmpeg%2FFFmpeg%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文以文档的形式来描述FFmpeg怎么入门，这也是为以后写文档做的一个大题框架格式。 文档介绍文档目的整理出开源代码 ffmpeg 的资料，方便公司同事后续使用。 文档范围较为详细的介绍 ffmpeg 的功能、使用以及二次开发。 读者对象希望了解 ffmpeg 知识，从事 USM 及 IPTV 的同事。 参考文献TODO 术语与缩写解释 缩略语/术语 全 称 说 明 ffmpeg Fast forword mpeg 音视频转换器 ffplay Fast forword play 用 ffmpeg 实现的播放器 ffserver Fast forword server 用 ffmpeg 实现的 rstp 服务器 ffprobe Fast forword probe 用来输入分析输入流。 FFmpeg 支持能力说明FFmpeg 介绍及安装FFmpeg 简介FFmpeg 是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用 LGPL 或 GPL 许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库 libavcodec，为了保证高可移植性和编解码质量，libavcodec 里很多 codec 都是从头开发的。 FFmpeg 项目由以下几部分组成: （1）ffmpeg 视频文件转换命令行工具, 也支持经过实时电视卡抓取和编码成视频文件. （2）ffserver 基于 HTTP、RTSP 用于实时广播的多媒体服务器. 也支持时间平移 （3）ffplay 用 SDL 和 FFmpeg 库开发的一个简单的媒体播放器 （4）libavcodec 一个包含了所有 FFmpeg 音视频编解码器的库. 为了保证最优性能和高可复用性, 大多数编解码器从头开发的. （5）libavformat 一个包含了所有的普通音视格式的解析器和产生器的库 FFmpeg 安装将所有源代码压缩在一个文件夹中，例如 /绝对路径/ffmpeg。 在终端输入以下指令： 123$ cd /绝对路径/ffmpeg$ ./configure #(此时，会出现问题。然后重新输入./configure –disable-yasm-)$ Make 至此，ffmpeg 安装编译通过，可以进行对音视频的操作。 ffplay 的编译需要依赖于 SDL 库，所以要想编译成功 ffplay，必须先安装 SDL 库， 安装方法：下载最新版本的 SDL 相应版本的 SDL 源码，编译，即可生成 SDL 库。 123# 首先下载 SDL 软件包$ configure --prefix=/usr/local$ make &amp;&amp; make install FFmpeg 参数说明通用选项1234567891011121314151617-L license-h 帮助-fromats 显示可用的格式，编解码的，协议的。-f fmt 强迫采用格式 fmt-i filename 输入文件-y 覆盖输出文件-t duration 设置纪录时间 hh:mm:ss[.xxx]格式的记录时间也支持-ss position 搜索到指定的时间 [-]hh:mm:ss[.xxx]的格式也支持-title string 设置标题-author string 设置作者-copyright string 设置版权-comment string 设置评论-target type 设置目标文件类型(vcd，svcd，dvd) 所有的格式选项（比特率，编解码以及缓冲区 大小）自动设置 ，只需要输入如下的就可以了： ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg-hq 激活高质量设置-itsoffset offset 设置以秒为基准的时间偏移，该选项影响所有后面的输入文件。该偏移被加到输 入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset 秒。 [-]hh:mm:ss[.xxx] 的格式也支持 视频选项12345678910111213141516171819-b bitrate 设置比特率，缺省 200kb/s-r fps 设置帧频 缺省 25-s size 设置帧大小 格式为 WXH 缺省 160X128.下面的简写也可以直接使用： Sqcif 128X96 qcif 176X144 cif 252X288 4cif 704X576-aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777-croptop size 设置顶部切除带大小 像素单位-cropbottom size –cropleft size –cropright size 底部，左边，右边切除带大小。-padtop size 设置顶部补齐的大小 像素单位-padbottom size –padleft size –padright size –padcolor color 设置补齐条大小 和颜色(hex，6 个 16 进制的数，红:绿:兰排列，比如 000000 代表黑色)-vn 不做视频记录-bt tolerance 设置视频码率容忍度 kbit/s-maxrate bitrate 设置最大视频码率容忍度-minrate bitreate 设置最小视频码率容忍度-bufsize size 设置码率控制缓冲区大小-vcodec codec 强制使用 codec 编解码方式。 如果用 copy 表示原始编解码数据必须被拷贝。-sameq 使用同样视频质量作为源（VBR）-pass n 选择处理遍数（1 或者 2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率-passlogfile file 选择两遍的纪录文件名为 file 高级视频选项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-g gop_size 设置图像组大小-intra 仅适用帧内编码-qscale q 使用固定的视频量化标度(VBR)-qmin q 最小视频量化标度(VBR)-qmax q 最大视频量化标度(VBR)-qdiff q 量化标度间最大偏差 (VBR)-qblur blur 视频量化标度柔化(VBR)-qcomp compression 视频量化标度压缩(VBR)-rc_init_cplx complexity 一遍编码的初始复杂度-b_qfactor factor 在 p 和 b 帧间的 qp 因子-i_qfactor factor 在 p 和 i 帧间的 qp 因子-b_qoffset offset 在 p 和 b 帧间的 qp 偏差-i_qoffset offset 在 p 和 i 帧间的 qp 偏差-rc_eq equation 设置码率控制方程 默认 tex^qComp-rc_override override 特定间隔下的速率控制重载-me method 设置运动估计的方法 可用方法有 zero phods log x1 epzs(缺省) full-dct_algo algo 设置 dct 的算法可用的有 0 FF_DCT_AUTO 缺省的 DCT 1 FF_DCT_FASTINT 2 FF_DCT_INT 3 FF_DCT_MMX 4 FF_DCT_MLIB 5 FF_DCT_ALTIVEC-idct_algo algo 设置 idct 算法。可用的有 0 FF_IDCT_AUTO 缺省的 IDCT 1 FF_IDCT_INT 2 FF_IDCT_SIMPLE 3 FF_IDCT_SIMPLEMMX 4 FF_IDCT_LIBMPEG2MMX 5 FF_IDCT_PS2 6 FF_IDCT_MLIB 7 FF_IDCT_ARM 8 FF_IDCT_ALTIVEC 9 FF_IDCT_SH4 10 FF_IDCT_SIMPLEARM-er n 设置错误残留为 n 1 FF_ER_CAREFULL 缺省 2 FF_ER_COMPLIANT 3 FF_ER_AGGRESSIVE 4 FF_ER_VERY_AGGRESSIVE-ec bit_mask 设置错误掩蔽为 bit_mask ， 该值为如下值的位掩码 1 FF_EC_GUESS_MVS (default=enabled) 2 FF_EC_DEBLOCK (default=enabled)-bf frames 使用 frames B 帧，支持 mpeg1，mpeg2，mpeg4-mbd mode 宏块决策 0 FF_MB_DECISION_SIMPLE 使 用 mb_cmp 1 FF_MB_DECISION_BITS 2 FF_MB_DECISION_RD-4mv 使用 4 个运动矢量 仅用于 mpeg4-part 使用数据划分 仅用于 mpeg4-bug param 绕过没有被自动监测到编码器的问题-strict strictness 跟标准的严格性-aic 使能高级帧内编码 h263+-umv 使能无限运动矢量 h263+-deinterlace 不采用交织方法-interlace 强迫交织法编码 仅对 mpeg2 和 mpeg4 有效。当你的输入是交织的并且你想要保持交 织以最小图像损失的时候采用该选项。可选的方法是不交织，但是损失更大-psnr 计算压缩帧的 psnr-vstats 输出视频编码统计到 vstats_hhmmss.log-vhook module 插入视频处理模块 module 包括了模块名和参数，用空格分开 音频选项12345-ab bitrate 设置音频码率-ar freq 设置音频采样率-ac channels 设置通道 缺省为 1-an 不使能音频纪录-acodec codec 使用 codec 编解码 音频/视频捕获选项12345-vd device 设置视频捕获设备。比如/dev/video0-vc channel 设置视频捕获通道 DV1394 专用-tvstd standard 设置电视标准 NTSC PAL(SECAM)-dv1394 设置 DV1394 捕获-av device 设置音频设备 比如/dev/dsp 高级选项12345678-map file:stream 设置输入流映射-debug 打印特定调试信息-benchmark 为基准测试加入时间-hex 倾倒每一个输入包-bitexact 仅使用位精确算法 用于编解码测试-ps size 设置包大小，以 bits 为单位-re 以本地帧频读数据，主要用于模拟捕获设备-loop 循环输入流。只工作于图像流，用于 ffserver 测试 FFmpeg 参数实例12345678910111213141516171819202122$ ./ffmpeg -y -i /rootVideoConverter/123.avi -ab 56 -ar 22050 -b 1500 -r 15 -qscale 10 –s 480x350 /root/VideoConverter/234.flv============================================================-y （覆盖输出文件，即如果 1.***文件已经存在的话，不经提示就覆盖掉了）-i "1.avi"（输入文件是和 ffmpeg 在同一目录下的 1.avi 文件，可以自己加路径，改名字）-s （输出的分辨率，注意片源一定要是 16:9 的不然会变形）-r （帧数，一般就用这个吧）-b 1500（视频数据流量，用-b xxxx 的指令则使用固定码率，数字随便改，1500 以上没效果； 还可以用动态码率如：-qscale 4 和-qscale 6，4 的质量比 6 高）-acodec aac（音频编码用 AAC）-ac 2 （声道数 1 或 2）-ar 24000（声音的采样频率，好像 PSP 只能支持 24000Hz）-ab 128 （ 音频数据流量，一般选择 32、64、96、128）-vol 200（200%的音量，自己改）-f psp （输出 psp 专用格式）-muxvb 768（给 PSP 机器识别的码率，一般选择 384、512 和 768）-ab bitrate 设置音频码率-ar freq 设置音频采样率-ss 指定时间点开始转换任务，(time_off set the start time offset)，-ss 后跟的时间单位为秒 .-s 320x240 指定分辨率-r 29.97 桢速率-bitexact 使用标准比特率-vcodec xvid 使用 xvid 压缩 FFmpeg 支持能力说明FFmpeg 对编码解码器的支持ffmpeg 支持的编解码器种类共有 280 多种，涵盖了几乎所有常见音视频编码格式，能解码几乎所有的音视频，每种音视频编解码器的实现都在 libavcodec 目录下有具体的C 语言实现，具体的支持情况参见： ffmpeg支持的编解码器 注：编码器和解码器的名称不是完全匹配的，因此有些编码器没有对应相同名称的解码器，反之，解码器也一样。即使编码和解码都支持也不一定是完全对应的，例如 h263 解码器对应有 h263p 和 h263 编码器。 FFmpeg 对容器格式的支持ffmpeg 支持对绝大多数的容器格式的读写操作，共计 190 多种，涵盖了互联网上各种常见媒体格式及日常生活中及专业应用中的各种媒体格式。详细的支持情况参见： FFmpeg支持的媒体文件格式 FFmpeg 对过滤器的支持 Filters 说明 aformat Convert the input audio to one of the specified formats. anull Pass the source unchanged to the output. aresample Resample audio data. ashowinfo Show textual information for each audio frame. abuffer Buffer audio frames， and make them accessible to the filterchain. anullsrc Null audio source， never return audio frames. abuffersink Buffer audio frames， and make them available to the end of the filter graph. anullsink Do absolutely nothing with the input audio. copy Copy the input video unchanged to the output. crop Crop the input video to width:height:x:y. drawbox Draw a colored box on the input video. fade Fade in/out input video fieldorder Set the field order. fifo Buffer input images and send them when they are requested. format Convert the input video to one of the specified pixel formats. gradfun Debands video quickly using gradients. hflip Horizontally flip the input video. lut Compute and apply a lookup table to the RGB/YUV input video. lutrgb Compute and apply a lookup table to the RGB input video. lutyuv Compute and apply a lookup table to the YUV input video. negate Negate input video. noformat Force libavfilter not to use any of the specified pixel formats for the input to the next filter. null Pass the source unchanged to the output. overlay Overlay a video source on top of the input. pad Pad input image to width:height[:x:y[:color]] (default x and y: 0， default color: black). pixdesctest Test pixel format definitions. scale Scale the input video to width:height size and/or convert the image format. select Select frames to pass in output. setdar Set the frame display aspect ratio. setpts Set PTS for the output video frame. setsar Set the pixel sample aspect ratio. settb Set timebase for the output link. showinfo Show textual information for each video frame. slicify Pass the images of input video on to next video filter as multiple slices. split Pass on the input to two outputs. transpose Transpose input video. unsharp Sharpen or blur the input video. vflip Flip the input video vertically. buffer Buffer video frames， and make them accessible to the filterchain. color Provide an uniformly colored input， syntax is: [color[:size[:rate]]] movie Read from a movie source. nullsrc Null video source， never return images. rgbtestsrc Generate RGB test pattern. testsrc Generate test pattern. buffersink Buffer video frames， and make them available to the end of the filter graph. nullsink Do absolutely nothing with the input video. FFmpeg 对图像颜色空间的支持ffmpeg 支持常见的图像颜色空间，并且在 libavswcale 中定义了颜色空间转换的相关函数实现各种颜色模式的互转。具体的支持情况见: FFmpeg支持的图像颜色空间 FFmpeg 功能及使用说明ffplay 对多媒体的支持能力验证一、视频 3gp 177X144 支持播放，在 windows 下播放正常，但是在 linux 下面偶有 BUG 如果发现画面无法显示而声音可以播放的情况下 可以试着切换全屏或者切换分辨率。 12345678910111213141516171819202122AVI 208X176 支持 320X240 支持 720X400 支持 720X576 支持DAT 3 52X288 支持DiVX 720X576 支持MKV 320X240 支持 352X288 支持 704X304 支持 720X576 支持MP4 320X240 支持 352X288 支持 720X400 支持MPG 320X240 支持 352X288 支持 480X576 支持 720X576 支持 720X480 支持VOB 352X288 支持XVID 720X576 支持MOV 支持RMVB 支持 二、音频 1234567891011121314151617181920212223242526272829303132333435363738AC3 48KHZ 支持APE 11KHZ 支持 22KHZ 支持 44KHZ 支持 48KHZ 支持MP3 32KHZ 64Kbps 支持 32KHZ 128KbpS 支持 32KHZ 160Kbps 支持 32KHZ 192Kbps 支持 32KHZ 320Kbps 支持 44KHZ 64Kbps 支持 44KHZ 128Kbps 支持 44KHZ 160Kbps 支持 44KHZ 192Kbps 支持 44KHZ 320Kbps 支持 48KHZ 64Kbps 支持 48KHZ 128Kbps 支持 48KHZ 160Kbps 支持 48KHZ 192Kbps 支持 48KHZ 320Kbps 支持OGG 32KHZ 128Kbps 支持 32KHZ 192Kbps 支持 44KHZ 64Kbps 支持 44KHZ 128Kbps 支持 44KHZ 192Kbps 支持 48KHZ 64Kbps 支持 44KHZ 128Kbps 支持 44KHZ 192Kbps 支持WAV 11KHZ 支持 22KHZ 16Kbps 支持 44KHZ 16Kbps 支持 48KHZ 16Kbps 支持WMA 8KHZ 16Kbps 支持 11KHZ 16Kbps 支持 16KHZ 16Kbps 支持 22KHZ 16Kbps 支持 44KHZ 16Kbps 支持 48KHZ 16Kbps 支持 三、图像 12345PNG 支持JPG 支持JPEG 支持GIF 支持BMP 支持 FFmpeg 格式转换第一步：准备媒体 前面已经讲的很清楚了，ffmpeg 如何安装不在赘述。准备好相应的文件，如图 2-1所示。 第二步：启动 ffmpeg 由于做的是格式转换，在 ffserver 上不能直观的看见结果，故我是在 linux 下进行的。打开终端，值得一提的是格式转换需要超级用户才能进行，故在命令行输入：su，&lt;回车&gt;，输入密码进入超级用户，本例中，以 FFmpeg 将 test.avi 转换为 test.mpg。在命令行中输入： 1$ ./ffmpeg –i test.avi –r 25 –s 720x400 test.mpg 其中原格式分辨率为 320x240，将转为 720x400，-r 前面已经解释其含义，表示设置帧频为 25。转换成功后如图 2-2 所示，前后两种格式播放效果如图 2-3 所示。相应的，转换为其他格式做相应的变化即可。 同时还可以在转换格式时进行强制的音视频转换，如 –vcodec + 格式，将会强制将视频按指定格式编码，-acodec +格式，将会强制按指定格式编码音频信息。在转换中有很多其他参数可以指定，如码率、分辨率、帧率等，具体按照 ffmpeg 的参数说明指定参数即可。但有一条转低不转高的原则需要注意，即品质差的音视频转换不建议转换到品质好的音视频。 再说说如何在转换视频的时候将音频合成到视频中，且覆盖其原来的音频。这个现在摸索出两种方法。 方法一：需要两条命令实现，先在命令行中输入： 1$ ./ffmpeg –i test.avi -an –r 25 test.mpg 此时将生成一个没有声音的 test.mpg 视频，再在命令行中输入： 1$ ./ffmpeg –i test.mpg –i test.mp3 –r 25 test1.mpg 此时将会生成一个名为 test1.mpg 的视频。该视频播放时视频为 test.avi 的视频，但音频变为了 test.mp3 的音频了。 方法二：只要一条指令即可实现。在命令行中输入： 1$ ./ffmpeg –i test.avi –i test.mp3 –vcodec copy –acodec copy –r 25 test2.mpg 此时将会生成一个名为 test2.mpg 的视频，播放时其视频为 test.avi 的视频，音频为 test.mp3。–vcodec copy 为 force video codec(‘copy’ to copy stream)。 有一点需要注意，文件命名不能有空格，否则会导致编译时不能通过。另外，-an 为不能使音频记录。 第三步：播放媒体 播放我们转换的媒体，看看是否满足我们当初的愿望，不出什么差错的话，是完全能够满足我们的要求的。 FFmpeg 视频截图截取一张 300x200 尺寸大小的格式为 jpg 的一张图片： 1$ ./ffmpeg –i test.avi –y –f image2 –t 0.001 –s 300x200 test.jpg 要截取指定时间的图片，如 5 秒之后的： 1$ ./ffmpeg –i test.avi –y –f image2 –ss 5 –t 0.001 –s 300x200 test.jpg 其中，-ss 后的单位为秒，也可写成：-ss 00:00:05。 把视频的前 30 帧转换为一个动态的 gif 图。需要说明的是，转换成功之后，如果用 ffplay 播放是看不出效果的，建议换成其他图片播放器播放。其转换命令为： 1$ ./ffmpeg –i test.avi –vframes 30 –pix_fmt rgb24–y –f gif test.gif 也可以从视频中的第 10 秒开始截取后面的 5 秒内容转换为一个无限重播的动态 gif 图。其命令为： 1$ ./ffmpeg –i test.avi –pix_fmt rgb24 –ss 10 –t 5 –y –f gif test.gif 上面两种动态 gif 都是只播一次，想让其一直播，可再加一个参数：-loop_output 0。 FFmpeg 屏幕录制屏幕录制其命令为： 1$ ./ffmpeg -f x11grab -r 25 -s wxga -i :0.0 /tmp/outputFile.mpg 其他相关参数可自行添加。需要说明的是，各个版本的 ffmpeg 对屏幕录制的命令不一。如果你只想录制一个应用程序窗口或者桌面上的一个固定区域，那么可以指定偏移位置和区域大小。使用 xwininfo -frame 命令可以完成查找上述参数。 注：ffmpeg 的屏幕录制功能只能在 Linux 环境下有效。并且在配置时需要添加 –enable-x11grub 指令，默认关闭。 FFmpeg 音视频采集把摄像头的实时视频录制下来，存储为文件 1$ ./ffmpeg -f video4linux -s 320x240 -r 10 -i /dev/video0 test.asf 录音，其命令为： 1$ ./ffmpeg –i /dev/dsp -f oss test.mp3 FFmpeg 应用实例用 FFserver 从文件生成流媒体一、安装 ffmpeg 在 ubuntu 下，运行 sudo apt-get ffmpeg 安装 ffmpeg，在其他 linux 操作系统下，见 ffmpeg 的编译过程（编译完成后可执行自动安装）。 二、准备预播放的媒体文件 如 test.Mp3，在本文档中，默认放入用户文件夹下得 Music 文件夹内.(直接从设备采集不在本文档叙述范围之内) 三、修改 ffserver 配置信息 ffserver 配置文件为: /etc/ffserver.conf 打开，填写配置信息.配置信息包括三方面: （1）端口绑定等基本信息，在 ·/etc/ffserver.conf· 中有详细注释，在此不再重复，最终配置信息为： 12345Port 8090BindAddress 0.0.0.0MaxHTTPConnections 2000MaxClients 1000MaxBandwidth 1000 （2）媒体文件配置信息.本信息根据具体的媒体文件类型直接在配置文件中取消注释掉相应文件类型的配置信息，然后填写文件路径即可: 123456# MP3 audio&lt;Stream test.mp3&gt;File "/home/xiaoma/Music/test.mp3"Format mp2NoVideo&lt;/Stream&gt; 四、启动 ffserver 在终端中运行: sudo ffserver -f /etc/ffserver.conf 启动 ffserver. 五、播放流媒体 在浏览器中输入 http://127.0.0.1:8090/test.mp3 即可播放音乐. 在终端中输入 ffplay http://localhost:8090/test.mp3 可播放流媒体. 用 FFserver 从设备生成实时流一、准备媒体 按照上节步骤安装 ffmpeg，保证摄像头和声卡可用，将从摄像头和声卡获取音视频信息。 二、修改 ffserver 配置信息 ffserver 配置文件为: /etc/ffserver.conf 打开，填写配置信息.配置信息包括三方面: （1）端口绑定等基本信息，在 /etc/ffserver.conf 中有详细注释，在此不再重复，最终配置信息为: 12345Port 8090BindAddress 0.0.0.0MaxHTTPConnections 2000MaxClients 1000MaxBandwidth 1000 （2）fend(传冲信息)，在文件播放中，基本不用动本配置信息，只需要根据具体情况分配缓冲文件.最终配置信息如下: 12345&lt;Feed feed1.ffm&gt;File /tmp/feed1.ffmFileMaxSize 2MACL allow 127.0.0.1&lt;/Feed&gt; （3）媒体文件配置信息.本信息根据具体的媒体文件类型直接在配置文件中取消注释掉相应文件类型的配置信息，然后填写文件路径即可: (中间会有很多很多配置信息，都是关于音视频的，有些配置还不懂，慢慢摸索吧) 1234567891011121314151617181920&lt;Stream test1.mpg&gt;Feed feed1.ffmFormat mpegAudioBitRate 32AudioChannels 1AudioSampleRate 44100VideoBitRate 64VideoBufferSize 40VideoFrameRate 3VideoSize 160x128VideoGopSize 12&lt;/Stream&gt;# Flash&lt;Stream test.swf&gt;Feed feed1.ffmFormat swfVideoFrameRate 2VideoIntraOnlyNoAudio&lt;/Stream&gt; 三、启动 FFserver 在终端中运行: sudo ffserver -f /etc/ffserver.conf 启动 ffserver. 四、启动 ffmpeg 本例中，以 ffmpeg 作为实时摄像头采集输入.在命令行中输入: 1$ ./ffmpeg -f video4linux2 -r 25 -i /dev/video0 /tmp/feed1.ffm 如果有音频设备，则采集音频的命令如下: 1$ ./ffmpeg -f oss -i /dev/dsp -f video4linux2 -r 25 -i /dev/video0 /tmp/feed1.ffm (音频格式参数自己配置) 五、播放流媒体 在浏览器中输入 http://127.0.0.1:8090/test1.mpg 即可播放音乐. 在终端中输入 ffplay http://localhost:8090/test.swf 可播放流媒体. FFmpeg 架构FFmpeg 文件结构 目录 文件 简要说明 libavformat 主要存放ffmpeg 支持的各种编解码 器的实现及ffmpeg 编解码功能相关的 数据结构定义及函 数定义和声明 allcodecs.c 简单的注册类函数 avcodec.h 编解码相关结构体定义和函数原型声明 dsputil.c 限幅数组初始化 dsputil.h 限幅数组声明 imgconvert.c 颜色空间转换相关函数实现 imgconvert_template.h 颜色空间转换相关结构体定义和函数声明 utils_codec.c 一些解码相关的工具类函数的实现 mpeg4audio.c mpeg4 音频编解码器的函数实现 mpeg4audio.h mpeg4 音频编解码器的函数声明 mpeg4data.h mpeg4 音视频编解码器的公用的函数声明及数据结构定义 mpeg4video.c mpeg4 视频编解码器的函数实现 mpeg4video.h mpeg4 视频编解码器的函数的声明及先关数据结构的定义 mpeg4videodec.c mpeg4 视频解码器的函数实现 mpeg4videoenc.c mpeg4 视频编码器的函数实现 libavformat 主要存放ffmpeg支 持的各种媒体格式 MUXER/DEMUXER 和数据流协议的定 义和实现文件以及 ffmpeg解复用相 关的数据结构及 函数定 allformats.c 简单注册类函数 avformat.h 文件和媒体格式相关函数声明和数据结构定义 avio.c 无缓冲 IO 相关函数实现 avio.h 无缓冲 IO 相关结构定义和函数声明 aviobuf.c 有缓冲数据 IO 相关函数实现 cutils.c 简单的字符串操作函数 utils_format.c 文件和媒体格式相关的工具函数的实现 file.c 文件 io 相关函数 ...... 其他相关媒体流 IO 的函数和数据结构实现文件。如：rtsp、http 等。 avi.c AVI 格式的相关函数定西 avi.h AVI 格式的相关函数声明及数据结构定义 avidec.c AVI 格式 DEMUXER 相关函数定义 avienc.c AVI 格式 MUXER 相关函数定义 ...... 其他媒体格式的 muxer/demuxer 相关函数及数据结构定义和声明文件 libavutil 主要存放ffmpeg 工具类函数的定义 avutil.h 简单的像素格式宏定义 bswap.h 简单的大小端转换函数的实现 commom.h 公共的宏定义和简单函数的实现 mathematics.c 数学运算函数实现 rational.h 分数相关表示的函数实现 I\O 模块分析概述ffmpeg 项目的数据 IO 部分主要是在 libavformat 库中实现，某些对于内存的操作部分在 libavutil 库中。数据 IO 是基于文件格式（Format）以及文件传输协议(Protocol)的，与具体的编解码标准无关。 ffmpeg 工程转码时数据 IO 层次关系如图所示： 对于上面的数据 IO 流程，具体可以用下面的例子来说明，我们从一个 http 服务器获取音视频数据，格式是 flv 的，需要通过转码后变成 avi 格式，然后通过 udp 协议进行发布。其过程就如下所示： 读入 http 协议数据流，根据 http 协议获取真正的文件数据（去除无关报文信息）； 根据 flv 格式对数据进行解封装； 读取帧进行转码操作； 按照目标格式 avi 进行封装； 通过 udp 协议发送出去。 相关数据结构介绍在 libavformat 库中与数据 IO 相关的数据结构主要有 URLProtocol、URLContext、ByteIOContext、AVFormatContext 等，各结构之间的关系如图所示。 1、URLProtocol 结构 表示广义的输入文件，该结构体提供了很多的功能函数，每一种广义的输入文件（如：file、pipe、tcp、rtp 等等）对应着一个 URLProtocol 结构，在 av_register_all() 中将该结构体初始化为一个链表，表头为 avio.c 里的 URLProtocol *first_protocol = NULL; 保存所有支持的输入文件协议，该结构体的定义如下： 123456789101112131415161718typedef struct URLProtocol&#123; const char *name; int (*url_open)(URLContext *h， const char *url， int flags); int (*url_read)(URLContext *h， unsigned char *buf， int size); int (*url_write)(URLContext *h， const unsigned char *buf， int size); int64_t (*url_seek)(URLContext *h， int64_t pos， int whence); int (*url_close)(URLContext *h); struct URLProtocol *next; int (*url_read_pause)(URLContext *h， int pause); int64_t (*url_read_seek)(URLContext *h， int stream_index， int64_t timestamp， int flags); int (*url_get_file_handle)(URLContext *h); int priv_data_size; const AVClass *priv_data_class; int flags; int (*url_check)(URLContext *h， int mask);&#125; URLProtocol; 注意到，URLProtocol 是一个链表结构，这是为了协议的统一管理，ffmpeg 项目中将所有的用到的协议都存放在一个全局变量 first_protocol 中，协议的注册是在 av_register_all 中完成的，新添加单个协议可以调用 av_register_protocol2 函数实现。而协议的注册就是将具体的协议对象添加至 first_protocol 链表的末尾。 URLProtocol 在各个具体的文件协议中有一个具体的实例，如在 file 协议中定义为： 12345678910URLProtocol ff_file_protocol = &#123; .name = "file"， .url_open = file_open， .url_read = file_read， .url_write = file_write， .url_seek = file_seek， .url_close = file_close， .url_get_file_handle = file_get_handle， .url_check = file_check，&#125;; 2、URLContext 结构 URLContext 提供了与当前打开的具体的文件协议（URL）相关数据的描述，在该结构中定义了指定当前 URL（即 filename 项）所要用到的具体的 URLProtocol，即：提供了一个在 URLprotocol 链表中找到具体项的依据，此外还有一些其它的标志性的信息，如 flags， is_streamed 等。它可以看成某一种协议的载体。其结构定义如下： 12345678910typedef struct URLContext&#123; const AVClass *av_class; ///&lt; information for av_log(). Set by url_open(). struct URLProtocol *prot; int flags; int is_streamed; /**&lt; true if streamed (no seek possible)， default = false */ int max_packet_size; void *priv_data; char *filename; /**&lt; specified URL */ int is_connected;&#125; URLContext; 那么 ffmpeg 依据什么信息初始化 URLContext？然后又是如何初始化 URLContext的呢？ 在打开一个 URL 时，全局函数 ffurl_open 会根据 filename 的前缀信息来确定 URL所使用的具体协议，并为该协议分配好资源，再调用 ffurl_connect 函数打开具体协议，即调用协议的 url_open，调用关系如下： 1234567891011int av_open_input_file(AVFormatContext **ic_ptr， const char *filename， AVInputFormat *fmt，int buf_size，AVFormatParameters *ap)int avformat_open_input(AVFormatContext **ps ， const char *filename ， AVInputFormat *fmt， AVDictionary **options)static int init_input(AVFormatContext *s， const char *filename)int avio_open(AVIOContext **s， const char *filename， int flags)int ffurl_open(URLContext **puc， const char *filename， int flags)int ffurl_alloc(URLContext **puc， const char *filename， int flags)static int url_alloc_for_protocol(URLContext **puc， struct URLProtocol *up， const char *filename， int flags) 浅蓝色部分的函数完成了 URLContext 函数的初始化，URLContext 使 ffmpeg 外所暴露的接口是统一的，而不是对于不同的协议用不同的函数，这也是面向对象思维的体现。在此结构中还有一个值得说的是 priv_data 项，这是结构的一个可扩展项，具体协议可以根据需要添加相应的结构，将指针保存在这就行。 3、AVIOContext 结构 AVIOContext（即：ByteIOContext）是由 URLProtocol 和 URLContext 结构扩展而来，也是 ffmpeg 提供给用户的接口，它将以上两种不带缓冲的读取文件抽象为带缓冲的读取和写入，为用户提供带缓冲的读取和写入操作。数据结构定义如下： 123456789101112131415161718192021222324typedef struct&#123; unsigned char *buffer; /**&lt; Start of the buffer. */ int buffer_size; /**&lt; Maximum buffer size */ unsigned char *buf_ptr; /**&lt; Current position in the buffer */ unsigned char *buf_end; void *opaque; //关联 URLContext int (*read_packet)(void *opaque， uint8_t *buf， int buf_size); int (*write_packet)(void *opaque， uint8_t *buf， int buf_size); int64_t (*seek)(void *opaque， int64_t offset， int whence); int64_t pos; int must_flush; int eof_reached; /**&lt; true if eof reached */ int write_flag; /**&lt; true if open for writing */ int max_packet_size; unsigned long checksum; unsigned char *checksum_ptr; unsigned long (*update_checksum)(unsigned long checksum， const uint8_t *buf， unsigned int size); int error; int (*read_pause)(void *opaque， int pause); int64_t (*read_seek)(void *opaque， int stream_index，int64_t timestamp，int flags); int seekable;&#125; AVIOContext; 结构简单的为用户提供读写容易实现的四个操作，read_packet write_packet read_pause read_seek，极大的方便了文件的读取，四个函数在加了缓冲机制后被中转到，URLContext 指向的实际的文件协议读写函数中。 下面给出 0.8 版本中是如何将 AVIOContext 的读写操作中转到实际文件中的。 在 avio_open（）函数中调用了 ffio_fdopen（）函数完成了对 AVIOContex 的初始化，其调用过程如下： 1234int avio_open(AVIOContext **s， const char *filename， int flags)ffio_fdopen(s， h); //h 是 URLContext 指针ffio_init_context(*s， buffer， buffer_size，h-&gt;flags &amp; AVIO_FLAG_WRITE， h， (void*)ffurl_read，(void*)ffurl_write，(void*)ffurl_seek) 函数调用完成了对 AVIOContext 的初始化，在初始化的过程中，将AVIOContext 的 read_packet 、 write_packet 、 seek 分别初始化为： ffurl_read ffurl_write ffurl_seek ， 而这三个函数又将具体的读写操作中转为： h-&gt;prot-&gt;url_read、h-&gt;prot-&gt;url_write、h-&gt;prot-&gt;url_seek，另外两个变量初始化时也被相应的中转，如下： 12(*s)-&gt;read_pause = (int (*)(void *， int))h-&gt;prot-&gt;url_read_pause;(*s)-&gt;read_seek = (int64_t (*)(void *， int， int64_t， int))h-&gt;prot-&gt;url_read_seek; 所以，可以简要的描述为：AVIOContext 的接口口是加了缓冲后的 URLProtocol 的函数接口。 在 aviobuf.c 中定义了一系列关于 ByteIOContext 这个结构体的函数，如下 put_xxx 系列： 1234567891011void put_byte(ByteIOContext *s， int b);void put_buffer(ByteIOContext *s， const unsigned char *buf， int size);void put_le64(ByteIOContext *s， uint64_t val);void put_be64(ByteIOContext *s， uint64_t val);void put_le32(ByteIOContext *s， unsigned int val);void put_be32(ByteIOContext *s， unsigned int val);void put_le24(ByteIOContext *s， unsigned int val);void put_be24(ByteIOContext *s， unsigned int val);void put_le16(ByteIOContext *s， unsigned int val);void put_be16(ByteIOContext *s， unsigned int val);void put_tag(ByteIOContext *s， const char *tag); get_xxx 系列： 123456789101112int get_buffer(ByteIOContext *s， unsigned char *buf， int size);int get_partial_buffer(ByteIOContext *s， unsigned char *buf， int size);int get_byte(ByteIOContext *s);unsigned int get_le24(ByteIOContext *s);unsigned int get_le32(ByteIOContext *s);uint64_t get_le64(ByteIOContext *s);unsigned int get_le16(ByteIOContext *s);char *get_strz(ByteIOContext *s， char *buf， int maxlen);unsigned int get_be16(ByteIOContext *s);unsigned int get_be24(ByteIOContext *s);unsigned int get_be32(ByteIOContext *s);uint64_t get_be64(ByteIOContext *s); 这些 put_xxx 及 get_xxx 函数是用于从缓冲区 buffer 中写入或者读取若干个字节，对于读写整型数据，分别实现了大端和小端字节序的版本。而缓冲区 buffer 中的数据又是从何而来呢，有一个 fill_buffer 的函数，在 fill_buffer 函数中调用了ByteIOContext 结构的 read_packet 接口。在调用 put_xxx 函数时，并没有直接进行真正写入操作，而是先缓存起来，直到缓存达到最大限制或调用 flush_buffer 函数对缓冲区进行刷新，才使用 write_packet 函数进行写入操作。 Demuxer 和 muxer 模块分析概述ffmpeg 的 demuxer 和 muxer 接口分别在 AVInputFormat 和 AVOutputFormat 两个结构体中实现，在 av_register_all()函数中将两个结构分别静态初始化为两个链表，保存在全局变量：first_iformat 和 first_oformat 两个变量中。在 FFmpeg 的文件转换或者打开过程中，首先要做的就是根据传入文件和传出文件的后缀名匹配合适的 demuxer和 muxer，得到合适的信息后保存在 AVFormatContext 中。 相关数据结构介绍1、AVInputFormat 该结构被称为 demuxer，是音视频文件的一个解封装器，它的定义如下： 1234567891011121314151617181920212223242526272829typedef struct AVInputFormat&#123; const char *name; const char *long_name; int priv_data_size; //具体文件容器格式对应的 Context 的大小，如：avicontext int (*read_probe)(AVProbeData *); int (*read_header)(struct AVFormatContext *，AVFormatParameters *ap); int (*read_packet)(struct AVFormatContext *， AVPacket *pkt); int (*read_close)(struct AVFormatContext *);#if FF_API_READ_SEEK attribute_deprecated int (*read_seek)(struct AVFormatContext *， int stream_index，int64_t timestamp，int flags);#endif int64_t (*read_timestamp)(struct AVFormatContext *s， int stream_index， int64_t *pos， int64_t pos_limit); int flags; const char *extensions; int value; int (*read_play)(struct AVFormatContext *); int (*read_pause)(struct AVFormatContext *); const struct AVCodecTag * const *codec_tag; int (*read_seek2)(struct AVFormatContext *s， int stream_index， int64_t min_ts， int64_t ts， int64_t max_ts， int flags);#if FF_API_OLD_METADATA2 const AVMetadataConv *metadata_conv;#endif const AVClass *priv_class; ///&lt; AVClass for the private context struct AVInputFormat *next;&#125; AVInputFormat; 对于不同的文件格式要实现相应的函数接口，这样每一种格式都有一个对应的demuxer，所有的 demuxer 都保存在全局变量 first_iformat 中。红色表示提供的接口。 2、AVOutputFormat 该结构与 AVInputFormat 类似也是在编译时静态初始化，组织为一个链表结构，提供了多个 muxer 的函数接口。 123int (*write_header)(struct AVFormatContext *);int (*write_packet)(struct AVFormatContext *， AVPacket *pkt);int (*write_trailer)(struct AVFormatContext *); 对于不同的文件格式要实现相应的函数接口，这样每一种格式都有一个对应的 muxer，所有的 muxer 都保存在全局变量 first_oformat 中。 3、AVFormatContext 该结构表示与程序当前运行的文件容器格式使用的上下文，着重于所有文件容器共有的属性，在运行时动态的确定其值，是 AVInputFormat 和 AVOutputFormat 的载体，但同一个结构对象只能使 AVInputFormat 和 AVOutputFormat 中的某一个有效。每一个输入和输出文件，都在 12static AVFormatContext *output_files[MAX_FILES] 和static AVFormatContext *input_files[MAX_FILES]; 定义的指针数组全局变量中有对应的实体。对于输入和输出，因为共用的是同一个结构体，所以需要分别对该结构中如下定义的 iformat 或 oformat 成员赋值。在转码时读写数据是通过 AVFormatContext 结构进行的。定义如下： 12345678910111213141516171819202122232425typedef struct AVFormatContext&#123; const AVClass *av_class; struct AVInputFormat *iformat; //指向具体的 demuxer struct AVOutputFormat *oformat; //指向具体的 muxer void *priv_data; //具体文件容器格式的 Context 如：avicontext AVIOContext *pb; //广义的输入输出； unsigned int nb_streams; //本次打开的文件容器中流的数量 AVStream **streams; //每个流的相关描述 char filename[1024]; // input or output filename */ int64_t timestamp; int ctx_flags; struct AVPacketList *packet_buffer; ...... enum CodecID video_codec_id; enum CodecID audio_codec_id; enum CodecID subtitle_codec_id; unsigned int max_index_size; unsigned int max_picture_buffer; ...... struct AVPacketList *raw_packet_buffer; struct AVPacketList *raw_packet_buffer_end; struct AVPacketList *packet_buffer_end; ......&#125; AVFormatContext; 注释部分的成员是 AVFormatContext 中最为重要的成员变量，这些变量的初始化是ffmpeg 能正常工作的必要条件，那么，AVFormatContext 是如何被初始化的呢？文件的格式是如何被探测到的呢？ 首先我们来探讨： 123struct AVInputFormat *iformat; //指向具体的 demuxerstruct AVOutputFormat *oformat; //指向具体的 muxervoid *priv_data; //具体文件容器格式的 Context 如：avicontext 三个成员的初始化。 在 avformat_open_input() 函数中调用了 init_input() 函数，然后用调用了av_probe_input_format（）函数实现了对 AVFormatContext 的初始化。其调用关系如下： 123456int av_open_input_file(AVFormatContext **ic_ptr， const char *filename， AVInputFormat *fmt，int buf_size，AVFormatParameters *ap)；int avformat_open_input(ic_ptr， filename， fmt， &amp;opts)；static int init_input(s， filename)；av_probe_input_format(&amp;pd， 0)；av_probe_input_format (AVProbeData *pd， int is_opened， int *score_max) 函数用途是根据传入的 probe data 数据，依次调用每个 demuxer 的 read_probe 接口，来进行该 demuxer 是否和传入的文件内容匹配的判断。与 demuxer 的匹配不同，muxer的匹配是调用 guess_format 函数，根据 main( ) 函数的 argv 里的输出文件后缀名来进行的。至此完成了前三个重要成员的初始化，具体的做法就不在深入分析。 下面分别给出 av_read_frame 函数以及 av_write_frame 函数的基本流程。 12345678910int av_read_frame(AVFormatContext *s， AVPacket *pkt); -&gt; av_read_frame_internel -&gt; av_read_packet -&gt; iformat-&gt;read_packet（在实现中会丢弃多余信息） -&gt; av_get_packet -&gt; get_xxx int av_write_frame(AVFormatContext *s， AVPacket *pkt); -&gt; oformat-&gt;write_packet -&gt; put_xxx 由上可见，对 AVFormatContext 的读写操作最终是通过 ByteIOContext 来实现的，这样，AVFormatContext 与 URLContext 就由 ByteIOContext 结构联系到一起了。在AVFormat 结构体中有一个 packet 的缓冲区 raw_packet_buffer，是 AVPackList 的指针类型，av_read_packet 函数将读到的包添加至 raw_packet_buffer 链表末尾。 Decoder/Encoder 模块概述编解码模块主要包含的数据结构为：AVCodec、AVCodecContext 每一个解码类型都会有自己的 Codec 静态对像，Codec 的 int priv_data_size 记录该解码器上下文的结构大小，如 MsrleContext 。这些都是编译时确定的，程序运行时通过avcodec_register_all()将所有的解码器注册成一个链表。在 av_open_input_stream()函数中调用 AVInputFormat 的 read_header()中读文件头信息时，会读出数据流的CodecID，即确定了他的解码器 Codec。 在 main()函数中除了解析传入参数并初始化 demuxer 与 muxer 的 parse_options( )函数以外，其他的功能都是在 av_encode( )函数里完成的。在 libavcodec\utils.c 中有如下二个函数 : AVCodec *avcodec_find_encoder(enum CodecID id) 和 AVCodec *avcodec_find_decoder(enum CodecID id) 他们的功能就是根据传入的 CodecID，找到匹配的 encoder 和 decoder。在 av_encode( )函数的开头，首先初始化各个 AVInputStream和 AVOutputStream，然后分别调用上述二个函数，并将匹配上的 encoder 与 decoder 分别保存在: 12AVInputStream-&gt;AVStream *st-&gt;AVCodecContext *codec-&gt;struct AVCodec *codec与 AVOutputStream-&gt;AVStream *st-&gt;AVCodecContext *codec-&gt;struct AVCodec *codec 变量。 相关数据结构的初始化AVCodecContext 结构 AVCodecContext 保存 AVCodec 指针和与 codec 相关数据，如 video 的 width、height，audio 的 sample rate 等。 AVCodecContext 中的 codec_type，codec_id 二个变量对于 encoder/decoder 的匹配来说，最为重要。 12enum CodecType codec_type; /* see CODEC_TYPE_xxx */enum CodecID codec_id; /* see CODEC_ID_xxx */ 如上所示，codec_type 保存的是 CODEC_TYPE_VIDEO，CODEC_TYPE_AUDIO 等媒体类型，codec_id 保存的是 CODEC_ID_FLV1，CODEC_ID_VP6F 等编码方式。 以支持 flv 格式为例，在前述的 av_open_input_file(…… ) 函数中，匹配到正确的 AVInputFormat demuxer 后，通过 av_open_input_stream( )函数中调用 AVInputFormat的 read_header 接口来执行 flvdec.c 中的 flv_read_header( )函数。flv_read_header( )函数内，根据文件头中的数据，创建相应的视频或音频 AVStream，并设置 AVStream 中AVCodecContext 的正确的 codec_type 值。codec_id 值是在解码过程。flv_read_packet( )函数执行时根据每一个 packet 头中的数据来设置的。 以 avidec 为例 有如下初始化，我们主要知道的就是 code_id 和 code_type 该字段关联具体的解码器，和解码类型（音视频或 subtitle） 1234567891011121314151617181920if (st-&gt;codec-&gt;stream_codec_tag == AV_RL32("Axan"))&#123; st-&gt;codec-&gt;codec_id = CODEC_ID_XAN_DPCM; st-&gt;codec-&gt;codec_tag = 0;&#125;if (amv_file_format)&#123; st-&gt;codec-&gt;codec_id = CODEC_ID_ADPCM_IMA_AMV; ast-&gt;dshow_block_align = 0;&#125; break; case AVMEDIA_TYPE_SUBTITLE: st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_SUBTITLE; st-&gt;request_probe= 1; break; default: st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_DATA; st-&gt;codec-&gt;codec_id= CODEC_ID_NONE; st-&gt;codec-&gt;codec_tag= 0; avio_skip(pb， size); 其他重要数据结构的初始化AVStreamAVStream 结构保存与数据流相关的编解码器，数据段等信息。比较重要的有如下二个成员： 12AVCodecContext *codec; /**&lt; codec context */void *priv_data; 其中 codec 指针保存的就是上节所述的 encoder 或 decoder 结构。priv_data 指针保存的是和具体编解码流相关的数据，如下代码所示，在 ASF 的解码过程中，priv_data保存的就是 ASFStream 结构的数据。 1234AVStream *st;ASFStream *asf_st;......st-&gt;priv_data = asf_st; AVInputStream/ AVOutputStream根据输入和输出流的不同，前述的 AVStream 结构都是封装在 AVInputStream 和AVOutputStream 结构中，在 av_encode( )函数中使用。AVInputStream 中还保存的有与时间有关的信息。AVOutputStream 中还保存有与音视频同步等相关的信息。 AVPacketAVPacket 结构定义如下，其是用于保存读取的 packet 数据。 12345678910111213typedef struct AVPacket&#123; int64_t pts; ///&lt; presentation time stamp in time_base units int64_t dts; ///&lt; decompression time stamp in time_base units uint8_t *data; int size; int stream_index; int flags; int duration; ///&lt; presentation duration in time_base units void (*destruct)(struct AVPacket *); void *priv; int64_t pos; ///&lt; byte position in stream， -1 if unknown&#125; AVPacket; 在 av_encode() 函数中，调用 AVInputFormat 的 (*read_packet)(struct AVFormatContext *， AVPacket *pkt) 接口，读取输入文件的一帧数据保存在当前输入 AVFormatContext 的 AVPacket 成员中。 FFmpeg 裁剪说明本文对 ffmpeg 进行裁剪采用的是配置所需的接口，不需要的不配置，而不是采用修改源代码的方式。 configure 参数通用选项在 linux 下进入终端，找到 ffmpeg 解压位置，输入如下命令： 1$ ./configure –help 得到 configure 的基本选项参数，其并没有中文解释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889--help 显示此帮助信息|print this message--log[=FILE|yes|no] 记录测试并输出到 config.err 文件|log tests and output to FILE [config.err]--prefix=PREFIX 安装程序到指定目录（默认/usr/local）|install in PREFIX [/usr/local]--libdir=DIR 安装库到指定目录（默认 prefix/lib）|install libs in DIR [PREFIX/lib]--shlibdir=DIR 指定共享库路径（默认 prefix/lib）|install shared libs in DIR [PREFIX/lib]--incdir=DIR 指定 includes 路径（默认 prefix/include/ffmpeg）|install includes in DIR[PREFIX/include/ffmpeg]--mandir=DIR 指定 man page 路径（默认 prefix/man）install man page in DIR [PREFIX/man]--enable-mp3lame 启用 mp3 编码 libmp3lame（默认关闭）enable MP3 encoding via libmp3lame[default=no]--enable-libogg 启用 ogg 支持 libogg（默认关闭）enable Ogg support via libogg [default=no]--enable-vorbis 启用 Vorbis 支持 libvorbis（默认关闭）enable Vorbis support via libvorbis [default=no]--enable-faad 启用 faad 支持 libfaad（默认关闭）enable FAAD support via libfaad [default=no]--enable-faadbin 启用 faad 运行时链接支持（默认关闭）build FAAD support with runtime linking[default=no]--enable-faac 启用 faac 支持 libfaac（默认关闭）enable FAAC support via libfaac [default=no]--enable-libgsm 启用 GSM 支持 libgsm（默认关闭）enable GSM support via libgsm [default=no]--enable-xvid 启用 xvid 支持 xvidcore（默认关闭）enable XviD support via xvidcore [default=no]--enable-x264 启 用 H.264 编码（默认关闭） enable H.264 encoding via x264 [default=no]--enable-mingw32 启用 MinGW 本地/交叉 win 环境编译|enable MinGW native/cross Windows compile--enable-mingwce 启用 MinGW 本地/交叉 winCE 环境编译 enable MinGW native/cross WinCE compile--enable-a52 启用 A52 支持（默认关闭）enable GPLed A52 support [default=no]--enable-a52bin 启用运行时打开 liba52.so.0（默认关闭）open liba52.so.0 at runtime [default=no]--enable-dts 启用 DTS 支持（默认关闭）enable GPLed DTS support [default=no]--enable-pp 启用后加工支持（默认关闭）enable GPLed postprocessing support [default=no]--enable-static 构建静态库（默认启用）build static libraries [default=yes]--disable-static 禁止构建静态库（默认关闭）do not build static libraries [default=no]--enable-shared 构建共享库（默认关闭）build shared libraries [default=no]--disable-shared 禁止构建共享库（默认启用）do not build shared libraries [default=yes]--enable-amr_nb 启用 amr_nb float 音频编解码器|enable amr_nb float audio codec--enable-amr_nb-fixed 启用 fixed amr_nb codec | use fixed point for amr-nb codec--enable-amr_wb 启用 amr_wb float 音频编解码器|enable amr_wb float audio codec--enable-amr_if2 启用 amr_wb IF2 音频编解码器|enable amr_wb IF2 audio codec--enable-sunmlib 启用 Sun medialib（默认关闭） | use Sun medialib [default=no]--enable-pthreads 启用 pthreads（多线程）（默认关闭）use pthreads [default=no]--enable-dc1394 启用 libdc1394、libraw1394 抓取 IIDC-1394（默认关闭）enable IIDC-1394 grabbing using libdc1394 and libraw1394 [default=no]--enable-swscaler 启用计数器支持？（默认关闭）software scaler support [default=no]--enable-avisynth 允许读取 AVISynth 脚本本件（默认关闭）allow reading AVISynth script files [default=no]--enable-gpl 允许使用 GPL（默认关闭）allow use of GPL code， the resulting libav* and ffmpeg will be under GPL [default=no] Advanced options (experts only): 高级选项参数（供专业人员使用）--source-path=PATH 源码的路径（当前为/root/flv/ffmpeg）| path to source code [/root/flv/ffmpeg]--cross-prefix=PREFIX 为编译工具指定路径 | use PREFIX for compilation tools []--cross-compile 假定使用了交叉编译 | assume a cross-compiler is used--cc=CC 指定使用何种 C 编译器（默认 gcc）use C compiler CC [gcc]--make=MAKE 使用特定的 make | use specified make [make]--extra-cflags=ECFLAGS 添加 ECFLAGS 到 CFLAGS | add ECFLAGS to CFLAGS []--extra-ldflags=ELDFLAGS 添加 ELDFLAGS 到 LDFLAGS（默认-Wl，--as-needed）| add ELDFLAGS to LDFLAGS [ -Wl，--as-needed]--extra-libs=ELIBS 添加 ELIBS | add ELIBS []--build-suffix=SUFFIX 为专用程序添加后缀 | suffix for application specific build []--arch=ARCH 选择机器架构（默认 x86）select architecture [x86]--cpu=CPU 选用最低的 cpu（影响指令的选择，可以在老 CPU 上出错） | selects the minimum cpu required (affects instruction selection， may crash on older CPUs)--powerpc-perf-enable 启用 PPC 上面的性能报告（需要启用 PMC）enable performance report on PPC (requires enabling PMC)--disable-mmx 禁用 MMX | disable MMX usage--disable-armv5te 禁用 armv5te | disable armv5te usage--disable-iwmmxt 禁用 iwmmxt | disable iwmmxt usage--disable-altivec 禁用 AltiVec | disable AltiVec usage--disable-audio-oss 禁用 OSS 音频支持（默认启用）disable OSS audio support [default=no]--disable-audio-beos 禁用 BeOS 音频支持（默认启用）disable BeOS audio support [default=no]--disable-v4l 禁用 video4linux 提取（默认启用）disable video4linux grabbing [default=no]--disable-v4l2 禁用 video4linux2 提取（默认启用）disable video4linux2 grabbing [default=no]--disable-bktr 禁用 bktr 视频提取（默认启用）disable bktr video grabbing [default=no]--disable-dv1394 禁用 DV1394 提取（默认启用）disable DV1394 grabbing [default=no]--disable-network 禁用网络支持（默认支持）disable network support [default=no]--disable-ipv6 禁用 ipv6 支持（默认支持）disable ipv6 support [default=no]--disable-zlib 禁用 zlib（默认支持）disable zlib [default=no]--disable-simple_idct 禁用 simple IDCT 例程（默认启用）disable simple IDCT routines [default=no]--disable-vhook 禁用 video hooking 支持 | disable video hooking support--enable-gprof enable profiling with gprof [no]--disable-debug 禁用调试符号 | disable debugging symbols--disable-opts 禁用编译器最优化 | disable compiler optimizations--disable-mpegaudio-hp 启用更快的解码 MPEG 音频（但精确度较低）（默认禁用）faster (but less accurate) MPEG audio decoding [default=no]--disable-protocols 禁用 I/O 协议支持（默认启用）disable I/O protocols support [default=no]--disable-ffserver 禁用生成 ffserver | disable ffserver build--disable-ffplay 禁用生成 ffplay | disable ffplay build--enable-small 启用优化文件尺寸大小（牺牲速度）optimize for size instead of speed--enable-memalign-hack 启用模拟内存排列，由内存调试器干涉？ | emulate memalign，interferes with memory debuggers--disable-strip 禁用剥离可执行程序和共享库 | disable stripping of executables and shared libraries--disable-encoder=NAME 禁用 XX 编码器 | disables encoder NAME--enable-encoder=NAME 启用 XX 编码器 | enables encoder NAME--disable-decoder=NAME 禁用 XX 解码器 | disables decoder NAME--enable-decoder=NAME 启用 XX 解码器 | enables decoder NAME--disable-encoders 禁用所有编码器 | disables all encoders--disable-decoders 禁用所有解码器 | disables all decoders--disable-muxer=NAME 禁用 XX 混音器 | disables muxer NAME--enable-muxer=NAME 启用 XX 混音器 | enables muxer NAME--disable-muxers 禁用所有混音器 | disables all muxers--disable-demuxer=NAME 禁用 XX 解轨器 | disables demuxer NAME--enable-demuxer=NAME 启用 XX 解轨器 | enables demuxer NAME--disable-demuxers 禁用所有解轨器 | disables all demuxers--enable-parser=NAME 启用 XX 剖析器 | enables parser NAME--disable-parser=NAME 禁用 XX 剖析器 | disables parser NAME--disable-parsers 禁用所有剖析器 | disables all parsers 基本选项介绍以下为配置 ffmpeg 的基本选项，其含义如下： 1--cache-file=FILE configure 会在你的系统上测试存在的特性(或者 bug!)。为了加速随后进行的配置，测试的结果会存储在一个 cache file 里。当 configure 到每个子树里都有 configure 脚本的复杂的源码树时，一个很好的 cache file 的存在会有很大帮助。 1--help 输出帮助信息。即使是有经验的用户也偶尔需要使用使用 --help 选项，因为一个复杂的项目会包含附加的选项。例如，GCC 包里的 configure 脚本就包含了允许你控制是否生成和在 GCC 中使用 GNU 汇编器的选项。 1--no-create configure 中的一个主要函数会制作输出文件。此选项阻止 configure 生成这个文件。你可以认为这是一种演习(dry run)，尽管缓存(cache)仍然被改写了。 12--quiet--silent 当 configure 进行他的测试时，会输出简要的信息来告诉用户正在作什么。这样做是因为 configure 可能会比较慢，没有这种输出的话用户将会被扔在一旁疑惑正在发生什么。使用这两个选项中的任何一个都会把你扔到一旁。(译注：这两句话比较有意思，原文是这样的：If there was no such output， the user would be left wondering what is happening. By using this option， you too can be left wondering!) 1--version 打印用来产生 ‘configure’ 脚本的 Autoconf 的版本号。 1--prefix=PEWFIX --prefix 是最常用的选项。制作出的 Makefile 会查看随此选项传递的参数，当一个包在安装时可以彻底的重新安置他的结构独立部分。举一个例子，当安装一个包，例如说Emacs，下面的命令将会使 Emacs Lisp file 被安装到”/opt/gnu/share”： 1$ ./configure --prefix=/opt/gnu 1--exec-prefix=EPREFIX 与 --prefix 选项类似，但是他是用来设置结构倚赖的文件的安装位置。编译好的 emacs 二进制文件就是这样一个问件。如果没有设置这个选项的话，默认使用的选项值将被设为和 --prefix 选项值一样。 1--bindir=DIR 指定二进制文件的安装位置。这里的二进制文件定义为可以被用户直接执行的程序。 1--sbindir=DIR 指定超级二进制文件的安装位置。这是一些通常只能由超级用户执行的程序。 1--libexecdir=DIR 指定可执行支持文件的安装位置。与二进制文件相反，这些文件从来不直接由用户执行，但是可以被上面提到的二进制文件所执行。 1--datadir=DIR 指定通用数据文件的安装位置。 1--sysconfdir=DIR 指定在单个机器上使用的只读数据的安装位置。 1--sharedstatedir=DIR 指定可以在多个机器上共享的可写数据的安装位置。 1--localstatedir=DIR 指定只能单机使用的可写数据的安装位置。 1--libdir=DIR 指定库文件的安装位置。 1--includedir=DIR 指定 C 头文件的安装位置。其他语言如 C++的头文件也可以使用此选项。 1--oldincludedir=DIR 指定为除 GCC 外编译器安装的 C 头文件的安装位置。 1--infodir=DIR 指定 Info 格式文档的安装位置。Info 是被 GNU 工程所使用的文档格式。 1--mandir=DIR 指定手册页的安装位置。 1--srcdir=DIR 这个选项对安装没有作用。他会告诉 configure 源码的位置。一般来说不用指定此选项，因为 configure 脚本一般和源码文件在同一个目录下。 1--program-prefix=PREFIX 指定将被加到所安装程序的名字上的前缀。例如，使用 --program-prefix=g 来 configure一个名为 tar 的程序将会使安装的程序被命名为 gtar。当和其他的安装选项一起使用时，这个选项只有当他被 Makefile.in 文件使用时才会工作。 1--program-suffix=SUFFIX 指定将被加到所安装程序的名字上的后缀。 1--program-transform-name=PROGRAM 这里的 PROGRAM 是一个 sed 脚本。当一个程序被安装时，他的名字将经过 sed -e PROGRAM 来产生安装的名字。 1--build=BUILD 指定软件包安装的系统平台。如果没有指定，默认值将是 --host 选项的值。 1--host=HOST 指定软件运行的系统平台。如果没有指定，将会运行 config.guess 来检测。 1--target=GARGET 指定软件面向(target to)的系统平台。这主要在程序语言工具如编译器和汇编器上下文中起作用。如果没有指定，默认将使用 --host 选项的值。 1--disable-FEATURE 一些软件包可以选择这个选项来提供为大型选项的编译时配置，例如使用 Kerberos认证系统或者一个实验性的编译器最优配置。如果默认是提供这些特性，可以使用 --disable-FEATURE 来禁用它，这里 FEATURE 是特性的名字。例如： 1$ ./configure --disable-gui 1--enable-FEATURE[=ARG] 相反的，一些软件包可能提供了一些默认被禁止的特性，可以使用 --enable-FEATURE 来起用它。这里 FEATURE 是特性的名字。一个特性可能会接受一个可选的参数。例如： 1$ ./configure --enable-buffers=128 --enable-FEATURE=no 与上面提到的 --disable-FEATURE 是同义的。 1--with-PACKAGE[=ARG] 在自由软件社区里，有使用已有软件包和库的优秀传统。当用 configure 来配置一个源码树时，可以提供其他已经安装的软件包的信息。例如，倚赖于 Tcl 和 Tk 的 BLT 器件工具包。要配置 BLT，可能需要给 configure 提供一些关于我们把 Tcl 和 Tk 装的何处的信息： 1$ ./configure --with-tcl=/usr/local --with-tk=/usr/local --with-PACKAGE=no 与下面将提到的 --without-PACKAGE 是同义的。 1--without-PACKAGE 有时候你可能不想让你的软件包与系统已有的软件包交互。例如，你可能不想让你的新编译器使用 GNU ld。通过使用这个选项可以做到这一点： 1$ ./configure --without-gnu-ld 1--x-includes=DIR 这个选项是 --with-PACKAGE 选项的一个特例。在 Autoconf 最初被开发出来时，流行使用 configure 来作为 Imake 的一个变通方法来制作运行于 X 的软件。–x-includes 选项提供了向 configure 脚本指明包含 X11 头文件的目录的方法。 1--x-libraries=DIR 类似的，--x-libraries 选项提供了向 configure 脚本指明包含 X11 库的目录的方法。 FFmpeg 裁剪优化实例对 ffmpeg 的裁剪优化主要是对 ffplay 的裁剪优化，我们制定的需求是能播放测试文件（视频为 mpeg4 编码、音频为 mp2 编码，且为 AVI 复用），根据需求，找到相应的选项，或禁用或启用，最后的命令如下： 1234$ ./configure --disable-yasm --disable-parsers --disable-decoders--disable-encoders --enable-decoder=mpeg4 --disable-muxers--disable-demuxers --enable-demuxer=avi --enable-decoder=mp2--disable-protocols --enable-protocol=file --disable-filters --disable-bsfs 其中针对需求， --disable-parsers 为禁用所有解析器， --disable-decoders 为禁用所有解码器， --disable-encoders 为禁用所有编码器， --enable-decoder=mpeg4 为启用 mpeg4 的编码器 ， --disable-muxers 为禁用所有复用， --disable-demuxers 为禁用所有解复用， --enable-demuxer=avi 为启用 AVI 复用， --enable-decoder=mp2 为启用 mp2 编码， --disable-protocols 为禁用所有协议， --enable-protocol=file 为启用文件协议， --disable-filters 为禁用所有过滤器， --disable-bsfs 为禁用所有码流过滤器。 通过以上配置之后，编译，安装，就生成了我们要求的 ffplay，其大小为 1.8M（1864012 字节）。此次是在 linux 环境下进行的，在以后的配置中，如果需要其他的什么编码器或什么的，按照选项要求进行配置即可。 裁剪优化前后文件比较前面已经提到本次裁剪优化的内容。经过裁剪优化之后，对其文件夹进行比较，主要有 3 个地方不同，分别是 config.fate、config.h 和 config.mak。在 config.fate 中，其记录的是配置命令，由于前后两次配置命令不同，故相应内容也不同。在config.h 中，其主要是根据配置命令来改变相应预定义的值，达到裁剪优化之效果。在 config.mak 中，改变的也是配置命令中需要改变的选项。 FFmpeg SDKFFMpeg 中比较重要的函数以及数据结构如下： 1、数据结构： (1) AVFormatContext (2) AVOutputFormat (3) AVInputFormat (4) AVCodecContext (5) AVCodec (6) AVFrame (7) AVPacket (8) AVPicture (9) AVStream 2、初始化函数： (1) av_register_all() (2) avcodec_open() (3) avcodec_close() (4) av_open_input_file() (5) av_find_input_format() (6) av_find_stream_info() (7) av_close_input_file() 3、音视频编解码函数： (1) avcodec_find_decoder() (2) avcodec_alloc_frame() (3) avpicture_get_size() (4) avpicture_fill() (5) img_convert() (6) avcodec_alloc_context() (7) avcodec_decode_video() (8) av_free_packet() (9) av_free() 4、文件操作： (1) avnew_steam() (2) av_read_frame() (3) av_write_frame() (4) dump_format() 5、其他函数： (1) avpicture_deinterlace() (2) ImgReSampleContext() FFmpeg 编译12345678$ git clone http://source.ffmpeg.org/git/ffmpeg.git ffmpeg$ cd ffmpeg$ ./configure --prefix=./install --enable-gpl --enable-nonfree \--enable-libass --enable-libfdk-aac --enable-libfreetype \--enable-libmp3lame --enable-libopus --enable-libtheora \--enable-libvorbis --enable-libvpx --enable-libx264 --enable-libxvid \--enable-shared --enable-static$ make &amp;&amp; sudo make install 注意：在执行各自的 configure 创建编译配置文件时，最好都强制带上 –enable-static 和 –enable-shared 参数以确保生成静态库和动态库。另外因为是在 Mac OS X 环境下编译，因此在各自编译完后，都要执行 sudo make install，安装到默认的 /usr/local 目录下相应位置（Mac OS X 下不推荐 /usr），因此不要在 configure 时指定 –prefix，就用默认的 /usr/local 目录前缀即可。完成编译安装后，FFmpeg 的头文件将会复制到 /usr/local/include 下面相应位置，静态库及动态库会被复制到 /usr/local/lib 目录下，FFmpeg 的可执行程序（ffmpeg、ffprobe、ffserver）会被复制到 /usr/local/bin 目录下，这样 FFmpeg 的开发环境就构建好了。]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC机制以及原理]]></title>
    <url>%2F2018%2F06%2F15%2FRPC%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[RPC详解 远程过程调用(RPC)详解 RPC原理详解 RPC入门总结（一）RPC定义和原理 RPC框架设计和调用详解 TODO]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得推荐的C/C++框架和库]]></title>
    <url>%2F2018%2F06%2F08%2FProgram-C%2Fc-open-project%2F</url>
    <content type="text"><![CDATA[值得学习的C语言开源项目Libev libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。 下载链接：http://software.schmorp.de/pkg/libev.html Memcached Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。 下载地址：http://memcached.org/ Redis Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;&lt;Redis设计与实现&gt;&gt;一书。 下载地址：http://redis.io/ Webbench Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。 下载链接：https://github.com/LippiOuYang/WebBenchl APR（Apache Portable Runtime） 这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。 APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。主页：https://apr.apache.org Tinyhttpd tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。 下载链接：https://github.com/LippiOuYang/Tinyhttpd cJSON cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。 cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。 项目主页:http://sourceforge.net/projects/cjson/ CMockery cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。 主要特点： 免费且开源，google提供技术支持； 轻量级的框架，使测试更加快速简单； 避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好; 并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用 下载链接：http://code.google.com/p/cmockery/downloads/list Lua Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。 让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。 下载地址：http://www.lua.org/ SQLite SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。 下载地址：http://www.sqlite.org/ 。 UNIX v6 UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？ 另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。 下载地址：http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6 NETBSD NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。 下载地址：http://www.netbsd.org/ C++ 资源大全关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。 &nbsp; 标准库 C++标准库，包括了STL容器，算法和函数等。 C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。 Standard Template Library：标准模板库 C POSIX library ： POSIX系统的C标准库规范 ISO C++ Standards Committee ：C++标准委员会 &nbsp; 框架 C++通用框架和库 Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合 ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。 Boost ：大量通用C++库的集合。 BDE ：来自于彭博资讯实验室的开发环境。 Cinder：提供专业品质创造性编码的开源开发社区。 Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。 Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。 EASTL ：EA-STL公共部分 ffead-cpp ：企业应用程序开发框架 Folly：由Facebook开发和使用的开源C++库 JUCE ：包罗万象的C++类库，用于开发跨平台软件 libPhenom：用于构建高性能和高度可扩展性系统的事件框架。 LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO LibU ： C语言写的多平台工具库 Loki ：C++库的设计，包括常见的设计模式和习语的实现。 MiLi ：只含头文件的小型C++库 openFrameworks ：开发C++工具包，用于创意性编码。 Qt ：跨平台的应用程序和用户界面框架 Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。 ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。 STLport：是STL具有代表性的版本 STXXL：用于额外的大型数据集的标准模板库。 Ultimate++ ：C++跨平台快速应用程序开发框架 Windows Template Library：用于开发Windows应用程序和UI组件的C++库 Yomm11 ：C++11的开放multi-methods. &nbsp; 人工智能 btsk ：游戏行为树启动器工具 Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。 Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。 &nbsp; 异步事件循环 Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。 libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。 libevent ：事件通知库 libuv ：跨平台异步I/O。 &nbsp; 音频 音频，声音，音乐，数字化音乐库 FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。 Maximilian ：C++音频和音乐数字信号处理库 OpenAL ：开源音频库&#8212;跨平台的音频API Opus：一个完全开放的，免版税的，高度通用的音频编解码器 Speex：免费编解码器，为Opus所废弃 Tonic： C++易用和高效的音频合成 Vorbis： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。 &nbsp; 生态学 生物信息，基因组学和生物技术 libsequence：用于表示和分析群体遗传学数据的C++库。 SeqAn：专注于生物数据序列分析的算法和数据结构。 Vcflib ：用于解析和处理VCF文件的C++库 Wham：直接把联想测试应用到BAM文件的基因结构变异。 &nbsp; 压缩 压缩和归档库 bzip2：一个完全免费，免费专利和高质量的数据压缩 doboz：能够快速解压缩的压缩库 PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。 KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。 LZ4 ：非常快速的压缩算法 LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。 LZMA ：7z格式默认和通用的压缩方法。 LZMAT ：及其快速的实时无损数据压缩库 miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。 Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。 Snappy ：快速压缩和解压缩 ZLib ：非常紧凑的数据流压缩库 ZZIPlib：提供ZIP归档的读权限。 &nbsp; 并发性 并发执行和多线程 Boost.Compute ：用于OpenCL的C++GPU计算库 Bolt ：针对GPU进行优化的C++模板库 C++React ：用于C++11的反应性编程库 Intel TBB ：Intel线程构件块 Libclsph：基于OpenCL的GPU加速SPH流体仿真库 OpenCL ：并行编程的异构系统的开放标准 OpenMP：OpenMP API Thrust ：类似于C++标准模板库的并行算法库 HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统 VexCL ：用于OpenCL/CUDA 的C++向量表达式模板库。 &nbsp; 容器 C++ B-tree ：基于B树数据结构，实现命令内存容器的模板库 Hashmaps： C++中开放寻址哈希表算法的实现 &nbsp; 密码学 Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。 BeeCrypt： Botan： C++加密库 Crypto++：一个有关加密方案的免费的C++库 GnuPG： OpenPGP标准的完整实现 GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库 Libgcrypt libmcrypt LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支 LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具 libsodium：基于NaCI的加密库，固执己见，容易使用 Nettle 底层的加密库 OpenSSL ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。 Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法 &nbsp; 数据库 数据库，SQL服务器，ODBC驱动程序和工具 hiberlite ：用于Sqlite3的C++对象关系映射 Hiredis： 用于Redis数据库的很简单的C客户端库 LevelDB： 快速键值存储库 LMDB：符合数据库四大基本元素的嵌入键值存储 MySQL++：封装了MySql的C API的C++ 包装器 RocksDB：来自Facebook的嵌入键值的快速存储 SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。 &nbsp; 调试 调试库， 内存和资源泄露检测，单元测试 Boost.Test：Boost测试库 Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。 CppUnit：由JUnit移植过来的C++测试框架 CTest：CMake测试驱动程序 googletest：谷歌C++测试框架 ig-debugheap：用于跟踪内存错误的多平台调试堆 libtap：用C语言编写测试 MemTrack —用于C++跟踪内存分配 microprofile- 跨平台的网络试图分析器 minUnit ：使用C写的迷你单元测试框架，只使用了两个宏 Remotery：用于web视图的单一C文件分析器 UnitTest++：轻量级的C++单元测试框架 &nbsp; 游戏引擎 Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。 Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。 Irrlicht ：C++语言编写的开源高性能的实时#D引擎 Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。 &nbsp; 图形用户界面 CEGUI ： 很灵活的跨平台GUI库 FLTK ：快速，轻量级的跨平台的C++GUI工具包。 GTK+： 用于创建图形用户界面的跨平台工具包 gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。 imgui：拥有最小依赖关系的立即模式图形用户界面 libRocket ：libRocket 是一个C++ HTML/CSS 游戏接口中间件 MyGUI ：快速，灵活，简单的GUI Ncurses：终端用户界面 QCustomPlot ：没有更多依赖关系的Qt绘图控件 Qwt ：用户与技术应用的Qt 控件 QwtPlot3D ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件 OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案 PDCurses 包含源代码和预编译库的公共图形函数库 wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序 &nbsp; 图形 bgfx：跨平台的渲染库 Cairo：支持多种输出设备的2D图形库 Horde3D 一个小型的3D渲染和动画引擎 magnum C++11和OpenGL 2D/3D 图形引擎 Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎） OpenSceneGraph 具有高性能的开源3D图形工具包 Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。 Skia 用于绘制文字，图形和图像的完整的2D图形库 urho3d 跨平台的渲染和游戏引擎。 &nbsp; 图像处理 Boost.GIL：通用图像库 CImg ：用于图像处理的小型开源C++工具包 CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。 FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。 GDCM：Grassroots DICOM 库 ITK：跨平台的开源图像分析系统 Magick++：ImageMagick程序的C++接口 MagickWnd：ImageMagick程序的C++接口 OpenCV ： 开源计算机视觉类库 tesseract-ocr：OCR引擎 VIGRA ：用于图像分析通用C++计算机视觉库 VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。 &nbsp; 国际化 gettext ：GNU `gettext&#8217; IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库 libiconv ：用于不同字符编码之间的编码转换库 &nbsp; Jason frozen ： C/C++的Jason解析生成器 Jansson ：进行编解码和处理Jason数据的C语言库 jbson ：C++14中构建和迭代BSON data,和Json 文档的库 JeayeSON：非常健全的C++ JSON库，只包含头文件 JSON++ ： C++ JSON 解析器 json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少 json11 ：一个迷你的C++11 JSON库 jute ：非常简单的C++ JSON解析器 ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。 libjson：轻量级的JSON库 PicoJSON：C++中JSON解析序列化，只包含头文件 qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类 QJson：将JSON数据映射到QVariant对象的基于Qt的库 RapidJSON： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API YAJL ：C语言中快速流JSON解析库 &nbsp; 日志 Boost.Log ：设计非常模块化，并且具有扩展性 easyloggingpp：C++日志库，只包含单一的头文件。 Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。 templog：轻量级C++库，可以添加日志到你的C++应用程序中 &nbsp; 机器学习 Caffe ：快速的神经网络框架 CCV ：以C语言为核心的现代计算机视觉库 mlpack ：可扩展的C++机器学习库 OpenCV：开源计算机视觉库 Recommender：使用协同过滤进行产品推荐/建议的C语言库。 SHOGUN：Shogun 机器学习工具 sofia-ml ：用于机器学习的快速增量算法套件 &nbsp; 数学 Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似 blaze：高性能的C++数学库，用于密集和稀疏算法。 ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。 CGal： 高效，可靠的集合算法集合 cml ：用于游戏和图形的免费C++数学库 Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。 GMTL：数学图形模板库是一组广泛实现基本图形的工具。 GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。 &nbsp; 多媒体 GStreamer ：构建媒体处理组件图形的库 LIVE555 Streaming Media ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库 libVLC ：libVLC (VLC SDK)媒体框架 QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器 SDL ：简单直控媒体层 SFML ：快速，简单的多媒体库 &nbsp; 网络 ACE：C++面向对象网络变成工具包 Boost.Asio：用于网络和底层I/O编程的跨平台的C++库 Casablanca：C++ REST SDK cpp-netlib：高级网络编程的开源库集合 Dyad.c：C语言的异步网络 libcurl :多协议文件传输库 Mongoose：非常轻量级的网络服务器 Muduo ：用于Linux多线程服务器的C++非阻塞网络库 net_skeleton ：C/C++的TCP 客户端/服务器库 nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js Onion :C语言HTTP服务器库，其设计为轻量级，易使用。 POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。 RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。 Tuf o ：用于Qt之上的C++构建的异步Web框架。 WebSocket++ ：基于C++/Boost Aiso的websocket 客户端/服务器库 ZeroMQ ：高速，模块化的异步通信库 &nbsp; 物理学 动力学仿真引擎 Box2D：2D的游戏物理引擎。 Bullet ：3D的游戏物理引擎。 Chipmunk ：快速，轻量级的2D游戏物理库 LiquidFun：2D的游戏物理引擎 ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。 ofxBox2d：Box2D开源框架包装器。 Simbody ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。 &nbsp; 机器人学 MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。 MRPT：移动机器人编程工具包 PCL ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。 Robotics Library (RL)： 一个独立的C++库，包括机器人动力学，运动规划和控制。 RobWork：一组C++库的集合，用于机器人系统的仿真和控制。 ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。 &nbsp; 科学计算 FFTW :用一维或者多维计算DFT的C语言库。 GSL：GNU科学库。 &nbsp; 脚本 ChaiScript ：用于C++的易于使用的嵌入式脚本语言。 Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。 luacxx：用于创建Lua绑定的C++ 11 API SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器 V7：嵌入式的JavaScript 引擎。 V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。 &nbsp; 序列化 Cap&#8217;n Proto ：快速数据交换格式和RPC系统。 cereal ：C++11 序列化库 FlatBuffers ：内存高效的序列化库 MessagePack ：C/C++的高效二进制序列化库，例如 JSON protobuf ：协议缓冲，谷歌的数据交换格式。 protobuf-c ：C语言的协议缓冲实现 SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。 Thrift ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。 &nbsp; 视频 libvpx ：VP8/VP9编码解码SDK FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。 libde265 ：开放的h.265视频编解码器的实现。 OpenH264：开源H.364 编解码器。 Theora ：免费开源的视频压缩格式。 &nbsp; 虚拟机 CarpVM：C中有趣的VM，让我们一起来看看这个。 MicroPython ：旨在实现单片机上Python3.x的实现 TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。 &nbsp; Web应用框架 Civetweb ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。 CppCMS ：免费高性能的Web开发框架（不是 CMS）. Crow ：一个C++微型web框架（灵感来自于Python Flask） Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。 libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。 QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。 Wt ：开发Web应用的C++库。 &nbsp; XML XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds Expat ：用C语言编写的xml解析库 Libxml2 ：Gnome的xml C解析器和工具包 libxml++ ：C++的xml解析器 PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。 RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。 TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。 TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。 TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。 Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。 &nbsp; 多项混杂 一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。 C++ Format ：C++的小型，安全和快速格式化库 casacore ：从aips++ 派生的一系列C++核心库 cxx-prettyprint：用于C++容器的打印库 DynaPDF ：易于使用的PDF生成库 gcc-poison ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。 googlemock：编写和使用C++模拟类的库 HTTP Parser ：C的http请求/响应解析器 libcpuid ：用于x86 CPU检测盒特征提取的小型C库 libevil ：许可证管理器 libusb：允许移动访问USB设备的通用USB库 PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。 Remote Call Framework ：C++的进程间通信框架。 Scintilla ：开源的代码编辑控件 Serial Communication Library ：C++语言编写的跨平台，串口库。 SDS：C的简单动态字符串库 SLDR ：超轻的DNS解析器 SLRE： 超轻的正则表达式库 Stage ：移动机器人模拟器 VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。 ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。 CppVerbalExpressions ：易于使用的C++正则表达式 QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库 PHP-CPP：使用C++来构建PHP扩展的库 Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。 &nbsp; 软件 用于创建开发环境的软件 编译器 C/C++编译器列表 Clang :由苹果公司开发的 GCC：GNU编译器集合 Intel C++ Compiler ：由英特尔公司开发 LLVM ：模块化和可重用编译器和工具链技术的集合 Microsoft Visual C++ ：MSVC，由微软公司开发 Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具 TCC ：轻量级的C语言编译器 &nbsp; 在线编译器 在线C/C++编译器列表 codepad ：在线编译器/解释器，一个简单的协作工具 CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果 coliru ：在线编译器/shell， 支持各种C++编译器 Compiler Explorer：交互式编译器，可以进行汇编输出 CompileOnline：Linux上在线编译和执行C++程序 Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。 &nbsp; 调试器 C/C++调试器列表 Comparison of debuggers ：来自维基百科的调试器列表 GDB ：GNU调试器 Valgrind：内存调试，内存泄露检测，性能分析工具。 &nbsp; 集成开发环境（IDE） C/C++集成开发环境列表 AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境 CLion：来自JetBrains的跨平台的C/C++的集成开发环境 Code::Blocks ：免费C，C++和Fortran的集成开发环境 CodeLite ：另一个跨平台的免费的C/C++集成开发环境 Dev-C++：可移植的C/C++/C++11集成开发环境 Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境 Geany ：轻量级的快速，跨平台的集成开发环境。 IBM VisualAge ：来自IBM的家庭计算机集成开发环境。 Irony-mode：由libclang驱动的用于Emacs的C/C++微模式 KDevelop：免费开源集成开发环境 Microsoft Visual Studio ：来自微软的集成开发环境 NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。 Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。 rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成 Xcode ：由苹果公司开发 YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。 &nbsp; 构建系统 Bear ：用于为clang工具生成编译数据库的工具 Biicode：基于文件的简单依赖管理器。 CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。 CPM：基于CMake和Git的C++包管理器 FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。 Ninja ：专注于速度的小型构建系统 Scons ：使用Python scipt 配置的软件构建工具 tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。 tup：基于文件的构建系统，用于后台监控变化的文件。 &nbsp; 静态代码分析 提高质量，减少瑕疵的代码分析工具列表 Cppcheck ：静态C/C++代码分析工具 include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。 OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。 Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具 List of tools for static code analysis ：来自维基百科的静态代码分析工具列表 感谢平凡之路和fffaraz 的整理，转载请注明出处。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机相关技术资料整理]]></title>
    <url>%2F2018%2F05%2F13%2Fpractical-programming-books%2FREADME%2F</url>
    <content type="text"><![CDATA[文章来源 这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。 CSDN 免费下载csdn免积分下载器 其实csdn上资源还是挺多的，如何免积分下载是一个很大的问题 但是有了 http://www.itziy.com/ csdn免积分下载器 工具之后，一切问题迎刃而解 有了 http://www.itziy.com/ csdn免积分下载器 不再为csdn免积分下载而烦恼 http://www.itziy.com/ csdn免积分下载器 专为需要csdn免积分下载的朋友开设 程序员必读书籍 目录 语言相关类 Android AWK SED C/C++ CSS/HTML Dart Erlang Fortran Go Groovy Haskell iOS Java JavaScript LaTeX LISP Lua Perl PHP Prolog Python R Ruby Scala Scheme Shell Swift WebAssembly 语言无关类 操作系统 版本控制 分布式系统 编辑器 NoSQL MySQL PostgreSQL 项目相关 设计模式 Web 大数据 编程艺术 函数式编程 运维监控 WEB服务器 语言无关类操作系统 开源世界旅行手册 鸟哥的Linux私房菜 Linux 系统高级编程 Zephyr OS 中文文档(v1.6.0) The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.org 中文版) 理解Linux进程 Linux From Scratch systemd 中文翻译 55分钟学会正则表达式 每个Linux用户都应该知道的命令行技巧 每个程序员都应该了解的内存知识 每个程序员都应该了解的CPU缓存知识 每个程序员都应该了解的虚拟内存知识 shell脚本教程 查找命令行的网站 正则表达式在线测试 科学上网 分布式系统 走向分布式 函数式编程 傻瓜函数编程 web服务器 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) OpenResty最佳实践 Apache 中文手册 Elasticsearch权威指南 25 台服务器是怎样支撑 StackOverflow 的？ 图片服务架构演进（孔凡勇） 最佳日志实践（王健） 版本控制 Git教程 git简易指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git Pro Git 中文版 (整理在gitbook上) Git Magic GotGitHub Git权威指南 Git Community Book 中文版 Mercurial 使用教程 HgInit (中文版) 沉浸式学 Git Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） GitHub秘籍 Github帮助文档 git-flow 备忘清单 svn 手册 GitHub漫游指南 编辑器 vimplus exvim–vim 改良成IDE项目 笨方法学Vimscript 中译本 Vim中文文档 所需即所获：像 IDE 一样使用 vim 在线MarkDown编辑 简明VIM练级攻略 MySQL MySQL中文手册 十步完全理解SQL MySQL索引背后的数据结构及算法原理 21分钟MySQL入门教程 NoSQL NoSQL数据库笔谈 Redis 设计与实现 Redis 命令参考 带有详细注释的 Redis 3.0 代码 带有详细注释的 Redis 2.6 代码 The Little MongoDB Book The Little Redis Book Neo4j 简体中文手册 v1.8 Neo4j .rb 中文資源 Disque 使用教程 Apache Spark 设计与实现 8种Nosql数据库系统对比 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.5.3 中文文档 运维监控 ELKstack 中文指南 Mastering Elasticsearch(中文版) ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） Logstash 最佳实践 Puppet 2.7 Cookbook 中文版 项目相关 Gradle实战 持续集成（第二版） (译言网) 让开发自动化系列专栏 追求代码质量 selenium 中文文档 Joel谈软件 約耳談軟體(Joel on Software) Gradle 2 用户指南 编码规范 开源软件架构 GNU make 指南 GNU make 中文手册 The Twelve-Factor App 设计模式 图说设计模式 史上最全设计模式导学目录 design pattern 包教不包会 设计模式 Java 版 Web 网络传输基础 关于浏览器和网络的 20 项须知 前端知识体系 浏览器开发工具的秘密 Chrome 开发者工具中文手册 Chrome扩展开发文档 Grunt中文文档 Yeoman中文文档 移动Web前端知识库 正则表达式30分钟入门教程 前端开发体系建设日记 移动前端开发收藏夹 JSON风格指南 HTTP 接口设计指北 前端资源分享（一） 前端资源分享（二） 前端代码规范 及 最佳实践 前端开发者手册 前端工程师手册 w3school教程整理 Wireshark用户手册 一站式学习Wireshark HTTP 下午茶 HTTP/2.0 中文翻译 RFC 7540 - HTTP/2 中文翻译版 http2讲解 3 Web Designs in 3 Weeks 站点可靠性工程 大数据 大数据/数据挖掘/推荐系统/机器学习相关资源 面向程序员的数据挖掘指南 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 Spark 编程指南简体中文版 编程艺术 程序员编程艺术 每个程序员都应该了解的内存知识(译)【第一部分】 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 编程技巧总汇 语言相关类AWK awk程序设计语言 awk教程 SED sed教程 SED简明教程 Java Apache Shiro 用户指南 Jersey 2.x 用户指南 Spring Framework 4.x参考文档 Spring Boot参考指南 (翻译中) MyBatis中文文档 用jersey构建REST服务 Activiti 5.x 用户指南 Google Java编程风格指南 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Java 编码规范 Apache MINA 2 用户指南 JVM必备指南 Java入门教程 javarevisited博客 journaldev教程 Android 开发工具下载 CodePath Android教程 Android Design(中文版) Google Material Design 正體中文版 (译本一 译本二) Google Android官方培训课程中文版 Android学习之路 Android构建工具 Android开发技术前线(android-tech-frontier) Android内存优化(上) Android内存优化(中) Android内存优化(全) 查找代码的一个网站 Android开源库汇总 查找示例代码的网站 Android SDK使用教程 Android最佳实践 Android Material icons C/C++ C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对) C 语言编程透视 C++ 并发编程指南 Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心) CGDB中文手册 100个gdb小技巧 100个gcc小技巧 学习gdb调试技巧 ZMQ 指南 How to Think Like a Computer Scientist (中英文版) 跟我一起写Makefile(PDF) GNU make中文手册 GNU make 指南 Google C++ 风格指南 C/C++ Primer (by @andycai) 简单易懂的C魔法 Cmake 实践 (PDF版) C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ 并发编程(基于C++11) QT 教程 C进阶指南（1) libuv中文教程 Boost 库中文教程 笨办法学C C进阶指南（2) C进阶指南（3) C语言全局变量那些事儿 如何实现一个malloc 在线编程和调试的网站 CSS 学习CSS布局 通用 CSS 笔记、建议与指导 CSS参考手册 Emmet 文档 前端代码规范 (腾讯alloyteam团队) HTML和CSS编码规范 Sass Guidelines 中文 CSS3 Tutorial 《CSS3 教程》 MDN HTML 中文文档 MDN CSS 中文文档 Go Go编程基础 Go入门指南 学习Go语言 (PDF) Go Web 编程 (此书已经出版，希望开发者们去购买，支持作者的创作) Go实战开发 (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者捐赠，以鼓励作者的继续创作) Network programming with Go 中文翻译版本 Effective Go Go 语言标准库 Golang标准库文档 Revel 框架手册 Java程序员的Golang入门指南 Go命令教程 Go语言博客实践 Go 官方文档翻译 深入解析Go Go语言圣经(中文版) (GitBook) Go语言高级编程 Groovy 实战 Groovy 系列 Haskell Real World Haskell 中文版 Haskell趣学指南 Learn You a Haskell for Great Good!(质量不错的一个网书) iOS iOS开发60分钟入门 iOS7人机界面指南 Google Objective-C Style Guide 中文版 iPhone 6 屏幕揭秘 Apple Watch开发初探 马上着手开发 iOS 应用程序 网易斯坦福大学公开课：iOS 7应用开发字幕文件 JavaScript Google JavaScript 代码风格指南 Google JSON 风格指南 Airbnb JavaScript 规范 JavaScript 标准参考教程（alpha） Javascript编程指南 (源码) javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) 《JavaScript 模式》 “JavaScript patterns”中译本 命名函数表达式探秘 (注:原文由为之漫笔翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 ECMAScript 6 入门 (作者：阮一峰) JavaScript Promise迷你书 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) JavaScript 教程 廖雪峰 MDN JavaScript 中文文档 jQuery jQuery 解构 简单易懂的JQuery魔法 How to write jQuery plugin Node.js Node入门 七天学会NodeJS Nodejs Wiki Book (繁体中文) express.js 中文文档 koa 中文文档 一起学koa 使用 Express + MongoDB 搭建多人博客 Express框架 Node.js 包教不包会 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 nodejs中文文档 orm2 中文文档 underscore.js Underscore.js中文文档 backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) AngularJS AngularJS最佳实践和风格指南 AngularJS中译本 AngularJS入门教程 构建自己的AngularJS 在Windows环境下用Yeoman构建AngularJS项目 Zepto.js Zepto.js 中文文档 Sea.js Hello Sea.js React.js React.js 中文文档 React webpack-cookbook React 入门教程 React Native 中文文档(含最新Android内容) Learn React &amp; Webpack by building the Hacker News front page impress.js impress.js的中文教程 CoffeeScript CoffeeScript Cookbook The Little Book on CoffeeScript中文版 CoffeeScript 编码风格指南 TypeScipt TypeScript Handbook ExtJS Ext4.1.0 中文文档 Meteor Discover Meteor Meteor 中文文档 Angular-Meteor 中文教程 Chrome扩展及应用开发 LaTeX 一份其实很短的 LaTeX 入门文档 一份不太简短的 LATEX 2ε 介绍 （PDF版） LISP Common Lisp ANSI Common Lisp 中文翻譯版 On Lisp 中文翻译版本 Scheme Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Racket Racket book Lua Lua编程入门 Lua 5.1 参考手册 中文翻译 Lua 5.3 参考手册 中文翻译 Lua源码欣赏 Perl Modern Perl 中文版 Perl 程序员应该知道的事 PHP PHP 官方手册 PHP调试技术手册(PDF) XDebug 2中文手册(译) (CHM) PHP之道 PHP 最佳实践 PHP 开发者实践 深入理解PHP内核 PHP扩展开发及内核应用 CodeIgniter 用户指南 Laravel4 中文文档 Laravel 入门 Symfony2中文文档 (未译完) Phalcon中文文档（翻译进行中） YiiBook几本Yii框架的在线教程 深入理解 Yii 2.0 Yii 框架中文文檔 简单易懂的PHP魔法 swoole文档及入门教程 Composer 中文网 Slim 中文文档 Lumen 中文文档 PHPUnit 中文文档 Prolog 笨办法学Prolog Python 廖雪峰 Python 2.7 中文教程 廖雪峰 Python 3 中文教程 简明Python教程 零基础学 Python 第一版 零基础学 Python 第二版 可爱的 Python Python 2.7 官方教程中文版 Python 3.3 官方教程中文版 Python Cookbook 中文版 Python3 Cookbook 中文版 深入 Python 深入 Python 3 PEP8 Python代码风格规范 Google Python 风格指南 中文版 Python入门教程 (PDF) Python的神奇方法指南 笨办法学 Python （PDF版下载） The Django Book 中文版 web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Dive Into Python 中文版 Bottle 文档中文版 (需翻墙) Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Introduction to Tornado 中文翻译 Python自然语言处理中文版 （感谢陈涛同学的翻译，也谢谢 @shwley 联系了作者） Python 绘图库 matplotlib 官方指南中文翻译 Scrapy 0.25 文档 ThinkPython Python快速教程 Python 正则表达式操作指南 python初级教程：入门详解 Python Cookbook 第3版 中文版 Twisted 与异步编程入门 TextGrocery 中文 API ( 基于svm算法的一个短文本分类 Python 库 ) Requests: HTTP for Humans Pillow 中文文档 PyMOTW 中文版 Python 官方文档中文版 Fabric 中文文档 Beautiful Soup 4.2.0 中文文档 用Python做科学计算 Sphinx 中文文档 精通 Python 设计模式 python 安全编程教程 程序设计思想与方法 知乎周刊·编程小白学Python Scipy 讲义 Python 学习笔记 基础篇 Python 学习笔记 模块篇 Python 标准库 中文版 Python进阶 Python 核心编程 第二版 CPyUG译 Python最佳实践指南 Python 精要教程 Python 量化交易教程 Django Django 1.5 文档中文版 正在翻译中 Diango 1.7 文档中文版 正在翻译中，目前只翻译了目录 Django 1.8.2 文档中文版正在翻译中 Django 最佳实践 Django搭建简易博客教程 The Django Book 中文版 Django 设计模式与最佳实践 Django 网站开发 Cookbook Django Girls 學習指南 Flask Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Flask 扩展文档汇总 Flask 大型教程 SQLAlchemy 中文文档 web.py web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Tornado Introduction to Tornado 中文翻译 Tornado源码解析 Tornado 4.3 文档中文版 R R语言忍者秘笈 Ruby Ruby 风格指南 Rails 风格指南 笨方法學 Ruby Ruby on Rails 指南 Ruby on Rails 實戰聖經 Ruby on Rails Tutorial 原书第 3 版 (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元) Rails 实践 Rails 5 开发进阶(Beta) Rails 102 编写Ruby的C拓展 Ruby 源码解读 Ruby中的元编程 Scala Scala课堂 (Twitter的Scala中文教程) Effective Scala(Twitter的Scala最佳实践的中文翻译) Scala指南 Scala-for-the-impatient-2nd(自行购买或pdf) Scala|写点什么(国人的一个很好的关于Scala的博客) Scheme Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Shell Shell脚本编程30分钟入门 Bash脚本15分钟进阶教程 Linux工具快速教程 shell十三问 Swift The Swift Programming Language 中文版 Swift 语言指南 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件 WebAssembly C/C++面向WebAssembly编程 计算机原理 视频地址 Github地址]]></content>
      <categories>
        <category>计算机相关技术资料整理</category>
      </categories>
      <tags>
        <tag>计算机相关技术资料整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 精简常用快捷键]]></title>
    <url>%2F2018%2F03%2F24%2FVim%2Fvim%E7%BC%96%E8%BE%91%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Vim 编辑常用快捷键 快捷键 说明 , Leader Key 函数跳转 &lt;leader&gt;n 打开/关闭代码资源管理器 &lt;leader&gt;t 打开/关闭函数列表 &lt;leader&gt;a .h .cpp 文件切换 &lt;leader&gt;u 转到函数声明 &lt;leader&gt;U 转到函数实现 g] 声明/定义跳转 &lt;leader&gt;o 打开include文件 &lt;leader&gt;y 拷贝函数声明 &lt;leader&gt;p 生成函数实现 &lt;c-p&gt; 切换到上一个buffer &lt;c-n&gt; 切换到下一个buffer :e &lt;filename&gt; 新建buffer打开文件 Ctrl + ] 找到光标所在位置的标签定义的地方 Ctrl + t 回到跳转之前的标签处 Ctrl + o 退回原来的地方 辅助操作 gcc 注释代码 gcap 注释段落 za 打开或关闭当前折叠 zM 关闭所有折叠 zR 打开所有折叠 &lt;c-w&gt;h 跳到左边的窗口 &lt;c-w&gt;j 跳到下边的窗口 &lt;c-w&gt;k 跳到上边的窗口 &lt;c-w&gt;l 跳到右边的窗口 &lt;c-w&gt;c 关闭当前窗口 &lt;c-w&gt;o 关闭其他窗口 :only 关闭其他窗口 快捷键 说明 &lt;leader&gt;f 搜索~目录下的文件 &lt;leader&gt;F 搜索当前目录下的文本 &lt;leader&gt;g 显示git仓库提交记录 &lt;leader&gt;G 显示当前文件提交记录 &lt;leader&gt;gg 显示当前文件在某个commit下的完整内容 &lt;leader&gt;d 删除当前buffer &lt;leader&gt;D 删除当前buffer外的所有buffer Ya 复制行文本到字母a Da 剪切行文本到字母a Ca 改写行文本到字母a rr 替换文本 &lt;leader&gt;r 全局替换，目前只支持单个文件 vif 选中函数内容 dif 删除函数内容 cif 改写函数内容 vaf 选中函数内容（包括函数名 花括号） daf 删除函数内容（包括函数名 花括号） caf 改写函数内容（包括函数名 花括号） :sp &lt;filename&gt; 横向切分窗口并打开文件 :vsp &lt;filename&gt; 竖向切分窗口并打开文件 gg=G 缩进整个文件 =a{ 缩进光标所在代码块 =i{ 缩进光标所在代码块，不缩进”{“ &lt;&lt; 减少缩进 &gt;&gt; 增加缩进 == 自动缩进 ctrl+f 下翻一屏 ctrl+b 上翻一屏 ctrl+d 下翻半屏 ctrl+u 上翻半屏 s 替换字符（删除光标处字符，并进入插入模式，前可接数量） S 替换行（删除当前行，并进入插入模式，前可接数量） cc 改写当前行（删除当前行并进入插入模式），同 S cw 改写光标开始处的当前单词 ciw 改写光标所处的单词 caw 改写光标所处的单词，并且包括前后空格（如果有的话） ct, 改写到逗号 c0 改写到行首 c^ 改写到行首（第一个非零字符） c$ 改写到行末 C 改写到行末（同 c$） ci&quot; 改写双引号中的内容 ci&#39; 改写单引号中的内容 ci) 改写小括号中的内容 ci] 改写中括号中内容 ci} 改写大括号中内容 cit 改写 xml tag 中的内容 cis 改写当前句子 ciB 改写’{}’中的内容 c2w 改写下两个单词 ct( 改写到小括号前 x 删除当前字符，前面可以接数字，3x代表删除三个字符 X 向前删除字符 dd 删除当前行 d0 删除到行首 d^ 删除到行首（第一个非零字符） d$ 删除到行末 D 删除到行末（同 d$） dw 删除当前单词 dt, 删除到逗号 diw 删除光标所处的单词 daw 删除光标所处的单词，并包含前后空格（如果有的话） di&quot; 删除双引号中的内容 di&#39; 删除单引号中的内容 di) 删除小括号中的内容 di] 删除中括号中内容 di} 删除大括号中内容 diB 删除’{}’中的内容 dit 删除 xml tag 中的内容 dis 删除当前句子 d2w 删除下两个单词 dt( 删除到小括号前 dgg 删除到文件头部 dG 删除到文件尾部 d} 删除下一段 d{ 删除上一段 u 撤销 U 撤销整行操作 CTRL-R 撤销上一次 u 命令 J 连接若干行 gJ 连接若干行，删除空白字符 . 重复上一次操作 ~ 交换大小写 g~iw 替换当前单词的大小写 gUiw 将单词转成大写 guiw 将当前单词转成小写 guu 全行转为小写 gUU 全行转为大写 gg=G 缩进整个文件 =a{ 缩进光标所在代码块 =i{ 缩进光标所在代码块，不缩进”{“ &lt;&lt; 减少缩进 &gt;&gt; 增加缩进 == 自动缩进 CTRL-A 增加数字 CTRL-X 减少数字 p 粘贴到光标后 P 粘贴到光标前 v 开始标记 y 复制标记内容 V 开始按行标记 CTRL-V 开始列标记 y$ 复制当前位置到本行结束的内容 yy 复制当前行 Y 复制当前行，同 yy yt, 复制到逗号 yiw 复制当前单词 3yy 复制光标下三行内容 v0 选中当前位置到行首 v$ 选中当前位置到行末 vt, 选中到逗号 viw 选中当前单词 vi) 选中小括号内的东西 vi] 选中中括号内的东西 viB 选中’{}’中的内容 vis 选中句子中的东西 gv 重新选择上一次选中的文字 :set paste 允许粘贴模式（避免粘贴时自动缩进影响格式） :set nopaste 禁止粘贴模式 &quot;?yy 复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称 &quot;?p 将寄存器 ? 的内容粘贴到光标后 &quot;?P 将寄存器 ? 的内容粘贴到光标前 :registers 显示所有寄存器内容 :[range]y 复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行 :[range]d 删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行 ddp 交换两行内容：先删除当前行复制到寄存器，并粘贴 /pattern 从光标处向文件尾搜索 pattern ?pattern 从光标处向文件头搜索 pattern n 向同一方向执行上一次搜索 N 向相反方向执行上一次搜索 * 向前搜索光标下的单词 # 向后搜索光标下的单词 :s/p1/p2/g 替换当前行的p1为p2 :%s/p1/p2/g 替换当前文件中的p1为p2 :%s/&lt;p1&gt;/p2/g 替换当前文件中的p1单词为p2 :%s/p1/p2/gc 替换当前文件中的p1为p2，并且每处询问你是否替换 :10,20s/p1/p2/g 将第10到20行中所有p1替换为p2 :%s/1\\2\/3/123/g 将“1\2/3” 替换为 “123”（特殊字符使用反斜杠标注） :%s/\r//g 删除 DOS 换行符 ^M :g/^\s*$/d 删除空行 :g/test/d 删除所有包含 test 的行 :v/test/d 删除所有不包含 test 的行 :%s/^/test/ 在行首加入特定字符(也可以用宏录制来添加) :%s/$/test/ 在行尾加入特定字符(也可以用宏录制来添加) :sort 排序 :g/^\(.\+\)$\n\1/d 去除重复行(先排序) :%s/^.\{10\}// 删除每行前10个字符 :%s/.\{10\}$// 删除每行尾10个字符]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 编程相关的常用快捷键]]></title>
    <url>%2F2018%2F03%2F23%2FVim%2FvimProgramHotKey%2F</url>
    <content type="text"><![CDATA[vimplus github 插件相关 快捷键 说明 , Leader Key &lt;leader&gt;n 打开/关闭代码资源管理器 &lt;leader&gt;t 打开/关闭函数列表 &lt;leader&gt;a .h .cpp 文件切换 &lt;leader&gt;u 转到函数声明 &lt;leader&gt;U 转到函数实现 &lt;leader&gt;o 打开include文件 &lt;leader&gt;y 拷贝函数声明 &lt;leader&gt;p 生成函数实现 &lt;leader&gt;w 单词跳转 &lt;leader&gt;f 搜索~目录下的文件 &lt;leader&gt;F 搜索当前目录下的文本 &lt;leader&gt;g 显示git仓库提交记录 &lt;leader&gt;G 显示当前文件提交记录 &lt;leader&gt;gg 显示当前文件在某个commit下的完整内容 &lt;leader&gt;ff 语法错误自动修复(FixIt) &lt;c-p&gt; 切换到上一个buffer &lt;c-n&gt; 切换到下一个buffer &lt;leader&gt;d 删除当前buffer &lt;leader&gt;D 删除当前buffer外的所有buffer Ya 复制行文本到字母a Da 剪切行文本到字母a Ca 改写行文本到字母a rr 替换文本 &lt;leader&gt;r 全局替换，目前只支持单个文件 gcc 注释代码 gcap 注释段落 vif 选中函数内容 dif 删除函数内容 cif 改写函数内容 vaf 选中函数内容（包括函数名 花括号） daf 删除函数内容（包括函数名 花括号） caf 改写函数内容（包括函数名 花括号） fa 查找字母a，然后再按f键查找下一个 折叠代码 快捷键 说明 za 打开或关闭当前折叠 zM 关闭所有折叠 zR 打开所有折叠 声明/定义跳转 快捷键 说明 g] 声明/定义跳转 缓存操作 快捷键 说明 :e &lt;filename&gt; 新建buffer打开文件 :bp 切换到上一个buffer :bn 切换到下一个buffer :bd 删除当前buffer 窗口操作 快捷键 说明 :sp &lt;filename&gt; 横向切分窗口并打开文件 :vsp &lt;filename&gt; 竖向切分窗口并打开文件 &lt;c-w&gt;h 跳到左边的窗口 &lt;c-w&gt;j 跳到下边的窗口 &lt;c-w&gt;k 跳到上边的窗口 &lt;c-w&gt;l 跳到右边的窗口 &lt;c-w&gt;c 关闭当前窗口 &lt;c-w&gt;o 关闭其他窗口 :only 关闭其他窗口 光标移动 快捷键 说明 h 上下左右移动 j 上下左右移动 k 上下左右移动 l 上下左右移动 0 光标移动到行首 ^ 跳到从行首开始第一个非空白字符 $ 光标移动到行尾 &lt;c-o&gt; 跳到上一个位置 &lt;c-i&gt; 跳到下一个位置 &lt;c-b&gt; 上一页 &lt;c-f&gt; 下一页 &lt;c-u&gt; 上移半屏 &lt;c-d&gt; 下移半屏 H 调到屏幕顶上 M 调到屏幕中间 L 调到屏幕下方 :n 跳到第n行 w 跳到下一个单词开头(标点或空格分隔的单词) W 跳到下一个单词开头(空格分隔的单词) e 跳到下一个单词尾部(标点或空格分隔的单词) E 跳到下一个单词尾部(空格分隔的单词) b 上一个单词头(标点或空格分隔的单词) B 上一个单词头(空格分隔的单词) ge 上一个单词尾 % 在配对符间移动, 可用于()、{}、[] gg 到文件首 G 到文件尾 fx 跳转到下一个为x的字符 Fx 跳转到上一个为x的字符 tx 跳转到下一个为x的字符前 Tx 跳转到上一个为x的字符前 ; 跳到下一个搜索的结果 [[ 跳转到函数开头 ]] 跳转到函数结尾 文本编辑 快捷键 说明 r 替换当前字符 R 进入替换模式，直至 ESC 离开 s 替换字符（删除光标处字符，并进入插入模式，前可接数量） S 替换行（删除当前行，并进入插入模式，前可接数量） cc 改写当前行（删除当前行并进入插入模式），同 S cw 改写光标开始处的当前单词 ciw 改写光标所处的单词 caw 改写光标所处的单词，并且包括前后空格（如果有的话） ct, 改写到逗号 c0 改写到行首 c^ 改写到行首（第一个非零字符） c$ 改写到行末 C 改写到行末（同 c$） ci&quot; 改写双引号中的内容 ci&#39; 改写单引号中的内容 ci) 改写小括号中的内容 ci] 改写中括号中内容 ci} 改写大括号中内容 cit 改写 xml tag 中的内容 cis 改写当前句子 ciB 改写’{}’中的内容 c2w 改写下两个单词 ct( 改写到小括号前 x 删除当前字符，前面可以接数字，3x代表删除三个字符 X 向前删除字符 dd 删除当前行 d0 删除到行首 d^ 删除到行首（第一个非零字符） d$ 删除到行末 D 删除到行末（同 d$） dw 删除当前单词 dt, 删除到逗号 diw 删除光标所处的单词 daw 删除光标所处的单词，并包含前后空格（如果有的话） di&quot; 删除双引号中的内容 di&#39; 删除单引号中的内容 di) 删除小括号中的内容 di] 删除中括号中内容 di} 删除大括号中内容 diB 删除’{}’中的内容 dit 删除 xml tag 中的内容 dis 删除当前句子 d2w 删除下两个单词 dt( 删除到小括号前 dgg 删除到文件头部 dG 删除到文件尾部 d} 删除下一段 d{ 删除上一段 u 撤销 U 撤销整行操作 CTRL-R 撤销上一次 u 命令 J 连接若干行 gJ 连接若干行，删除空白字符 . 重复上一次操作 ~ 交换大小写 g~iw 替换当前单词的大小写 gUiw 将单词转成大写 guiw 将当前单词转成小写 guu 全行转为小写 gUU 全行转为大写 gg=G 缩进整个文件 =a{ 缩进光标所在代码块 =i{ 缩进光标所在代码块，不缩进”{“ &lt;&lt; 减少缩进 &gt;&gt; 增加缩进 == 自动缩进 CTRL-A 增加数字 CTRL-X 减少数字 p 粘贴到光标后 P 粘贴到光标前 v 开始标记 y 复制标记内容 V 开始按行标记 CTRL-V 开始列标记 y$ 复制当前位置到本行结束的内容 yy 复制当前行 Y 复制当前行，同 yy yt, 复制到逗号 yiw 复制当前单词 3yy 复制光标下三行内容 v0 选中当前位置到行首 v$ 选中当前位置到行末 vt, 选中到逗号 viw 选中当前单词 vi) 选中小括号内的东西 vi] 选中中括号内的东西 viB 选中’{}’中的内容 vis 选中句子中的东西 gv 重新选择上一次选中的文字 :set paste 允许粘贴模式（避免粘贴时自动缩进影响格式） :set nopaste 禁止粘贴模式 &quot;?yy 复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称 &quot;?p 将寄存器 ? 的内容粘贴到光标后 &quot;?P 将寄存器 ? 的内容粘贴到光标前 :registers 显示所有寄存器内容 :[range]y 复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行 :[range]d 删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行 ddp 交换两行内容：先删除当前行复制到寄存器，并粘贴 文件操作 快捷键 说明 :e &lt;filename&gt; 打开文件并编辑 :saveas &lt;filename&gt; 另存为文件 :close 关闭文件 :wa 保存所有文件 :new 打开一个新的窗口编辑新文件 :enew 在当前窗口创建新文件 :vnew 在左右切分的新窗口中编辑新文件 :tabnew 在新的标签页中编辑新文件 使用外部程序 快捷键 说明 ! 告诉vim正在执行一个过滤操作 !5Gsort&lt;Enter&gt; 使用外部sort命令对1-5行文本排序 !! 对当前行执行过滤命令 !!date&lt;Enter&gt; 用”date”的输出代替当前行 宏录制 快捷键 说明 qa 开始录制名字为a的宏 q 结束录制宏 @a 播放名字为a的宏 100@a 播放名字为a的宏100次 :normal@a 播放名字为a的宏直到自动结束 实用命令 快捷键 说明 /pattern 从光标处向文件尾搜索 pattern ?pattern 从光标处向文件头搜索 pattern n 向同一方向执行上一次搜索 N 向相反方向执行上一次搜索 * 向前搜索光标下的单词 # 向后搜索光标下的单词 :s/p1/p2/g 替换当前行的p1为p2 :%s/p1/p2/g 替换当前文件中的p1为p2 :%s/&lt;p1&gt;/p2/g 替换当前文件中的p1单词为p2 :%s/p1/p2/gc 替换当前文件中的p1为p2，并且每处询问你是否替换 :10,20s/p1/p2/g 将第10到20行中所有p1替换为p2 :%s/1\\2\/3/123/g 将“1\2/3” 替换为 “123”（特殊字符使用反斜杠标注） :%s/\r//g 删除 DOS 换行符 ^M :g/^\s*$/d 删除空行 :g/test/d 删除所有包含 test 的行 :v/test/d 删除所有不包含 test 的行 :%s/^/test/ 在行首加入特定字符(也可以用宏录制来添加) :%s/$/test/ 在行尾加入特定字符(也可以用宏录制来添加) :sort 排序 :g/^\(.\+\)$\n\1/d 去除重复行(先排序) :%s/^.\{10\}// 删除每行前10个字符 :%s/.\{10\}$// 删除每行尾10个字符 帮助 快捷键 说明 h tutor 入门文档 h quickref 快速帮助 h index 查询Vim所有键盘命令定义 h summary 帮助你更好的使用内置帮助系统 h pattern.txt 正则表达式帮助 h eval 脚本编写帮助 h function-list 查看VimScript的函数列表 h windows.txt 窗口使用帮助 h tabpage.txt 标签页使用帮助 h tips 查看Vim内置的常用技巧文档 h quote 寄存器 h autocommand-events 所有可能事件 h write-plugin 编写插件 其他 快捷键 说明 vim -u NONE -N 开启vim时不加载vimrc文件 vimdiff file1 file2 显示文件差异 &lt;leader&gt;e 快速编辑vimrc文件 &lt;leader&gt;s 重新加载vimrc文件 &lt;leader&gt;h 打开vimplus帮助文档 &lt;leader&gt;H 打开当前光标所在单词的vim帮助文档 &lt;leader&gt;&lt;leader&gt;i 安装插件 &lt;leader&gt;&lt;leader&gt;u 更新插件 &lt;leader&gt;&lt;leader&gt;c 删除插件]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 快捷键]]></title>
    <url>%2F2018%2F03%2F20%2FVim%2FvimHotKey%2F</url>
    <content type="text"><![CDATA[vimplus github Vim使用笔记 利用ctags+cscope+taglist+nerdree+srcexpl+trinity 将 VIM 变成 source insight 1. 文档操作 :e – 重新加载当前文档。 :e! – 重新加载当前文档，并丢弃已做的改动。 :e file – 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告。 :e! file – 放弃对当前文件的修改，编辑新的文件。 :e# 或 ctrl+^ – 回到刚才编辑的文件，很实用。 gf – 打开以光标所在字符串为文件名的文件。 :saveas newfilename – 另存为 2. 光标的移动 gj : 移动到一段内的下一行； gk : 移动到一段内的上一行； w : 前移一个单词，光标停在下一个单词开头； b : 后移一个单词，光标停在上一个单词开头； ( : 前移1句。 ) : 后移1句。 { : 前移1段。 } : 后移1段。 fc : 把光标移到同一行的下一个 c 字符处 Fc : 把光标移到同一行的上一个 c 字符处 tc : 把光标移到同一行的下一个 c 字符前 Tc : 把光标移到同一行的上一个 c 字符后 ; : 配合 f &amp; t 使用，重复一次 , : 配合 f &amp; t 使用，反向重复一次 上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。 0 : 移动到行首。 g0 : 移到光标所在屏幕行行首。 ^ : 移动到本行第一个非空白字符。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 $ : 移动到行尾。 g$ : 移动光标所在屏幕行行尾。 n| : 把光标移到递 n 列上。 nG : 到文件第 n 行。 :n&lt;cr&gt; : 移动到第 n 行。 :$&lt;cr&gt; : 移动到最后一行。 H : 把光标移到屏幕最顶端一行。 M : 把光标移到屏幕中间一行。 L : 把光标移到屏幕最底端一行。 gg : 到文件头部。 G : 到文件尾部。 2.1 翻屏 ctrl+f : 下翻一屏。 ctrl+b : 上翻一屏。 ctrl+d : 下翻半屏。 ctrl+u : 上翻半屏。 ctrl+e : 向下滚动一行。 ctrl+y : 向上滚动一行。 n% : 到文件 n% 的位置。 zz : 将当前行移动到屏幕中央。 zt : 将当前行移动到屏幕顶端。 zb : 将当前行移动到屏幕底端。 2.2 标记使用标记可以快速移动。到达标记后，可以用 Ctrl+o 返回原来的位置。 Ctrl+o 和 Ctrl+i 很像浏览器上的 后退 和 前进 。 m{a-z} : 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z} : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 ``{a-z}` : 移动到标记位置。 &#39;{a-z} : 移动到标记行的行首。 ``{0-9}` ：回到上[2-10]次关闭vim时最后离开的位置。 ``: 移动到上次编辑的位置。’’ 也可以，不过``精确到列，而 ‘’ 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。 `” : 移动到上次离开的地方。 `. : 移动到最后改动的地方。 :marks – 显示所有标记。 :delmarks a b – 删除标记 a 和 b。 :delmarks a-c – 删除标记 a、b 和 c。 :delmarks a c-f – 删除标记 a、c、d、e、f。 :delmarks! – 删除当前缓冲区的所有标记。 :help mark-motions – 查看更多关于 mark 的知识。 3. 插入文本3.1 基本插入 i : 在光标前插入；一个小技巧：按 8，再按 i，进入插入模式，输入 =， 按 esc 进入命令模式，就会出现 8 个 = 。 这在插入分割线时非常有用，如30i+&lt;esc&gt; 就插入了 36 个 + 组成的分割线。 :r filename : 在当前位置插入另一个文件的内容。 :r !date : 在光标处插入当前日期与时间。同理，:r !command 可以将其它 shell 命令的输出插入当前文档。 3.2 改写插入 c[n]w : 改写光标后 1(n) 个词。 c[n]l : 改写光标后 n 个字母。 c[n]h : 改写光标前 n 个字母。 [n]cc : 修改当前 [n] 行。 [n]s : 以输入的文本替代光标之后 1(n) 个字符，相当于 c[n]l。 [n]S : 删除指定数目的行，并以所输入文本代替之。 注意，类似 cnw,dnw,ynw 的形式同样可以写为 ncw,ndw,nyw。 4. 剪切复制和寄存器4.1 剪切和复制、粘贴 [n]x : 剪切光标右边 n 个字符，相当于 d[n]l。 [n]X : 剪切光标左边 n 个字符，相当于 d[n]h。 y : 复制在可视模式下选中的文本。 yy or Y : 复制整行文本。 y[n]w : 复制一 (n) 个词。 y[n]l : 复制光标右边 1(n) 个字符。 y[n]h : 复制光标左边 1(n) 个字符。 y$ : 从光标当前位置复制到行尾。 y0 : 从光标当前位置复制到行首。 :m,ny&lt;cr&gt; : 复制 m 行到 n 行的内容。 y1G 或 ygg : 复制光标以上的所有行。 yG : 复制光标以下的所有行。 yaw 和 yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d : 删除（剪切）在可视模式下选中的文本。 d$ or D : 删除（剪切）当前位置到行尾的内容。 d[n]w: 删除（剪切）1(n)个单词 d[n]l: 删除（剪切）光标右边 1(n) 个字符。 d[n]h: 删除（剪切）光标左边 1(n) 个字符。 d0: 删除（剪切）当前位置到行首的内容 [n] dd: 删除（剪切）1(n) 行。 :m,nd&lt;cr&gt; : 剪切 m 行到 n 行的内容。 d1G 或 dgg : 剪切光标以上的所有行。 dG : 剪切光标以下的所有行。 daw 和 das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 d/f&lt;cr&gt;：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。 p: 在光标之后粘贴。 P : 在光标之前粘贴。 4.2 文本对象 aw：一个词 as：一句。 ap：一段。 ab：一块（包含在圆括号中的）。 y, d, c, v 都可以跟文本对象。 4.3 寄存器 a-z：都可以用作寄存器名。&quot;ayy 把当前行的内容放入 a 寄存器。 A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如 &quot;Ayy 把当前行的内容追加到 a 寄存器中。 :reg : 显示所有寄存器的内容。 &quot;&quot;：不加寄存器索引时，默认使用的寄存器。 &quot;*：当前选择缓冲区，&quot;*yy 把当前行的内容放入当前选择缓冲区。 &quot;+：系统剪贴板。&quot;+yy 把当前行的内容放入系统剪贴板。 5. 查找与替换5.1 查找 /something : 在后面的文本中查找 something。 ?something : 在前面的文本中查找 something。 /pattern/+number : 将光标停在包含 pattern 的行后面第 number 行上。 /pattern/-number : 将光标停在包含 pattern 的行前面第 number 行上。 n : 向后查找下一个。 N : 向前查找下一个。 可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 :grep 是调用外部的 grep 程序，而 :vimgrep 是 vim 自己的查找算法。 用法为： :vim[grep]/pattern/[g] [j] files g 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。 j 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。 vimgrep 前面可以加数字限定搜索结果的上限，如 :1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。 其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：:vim/^d{1,}./ % 然后用 :cw 或 :copen 查看结果，可以用 C-w H 把 quickfix 窗口移到左侧，就更像个目录了。 5.2 替换 :s/old/new – 用 new 替换当前行第一个 old。 :s/old/new/g – 用 new 替换当前行所有的 old。 :n1,n2s/old/new/g – 用 new 替换文件 n1 行到 n2 行所有的 old。 :%s/old/new/g – 用 new 替换文件中所有的 old。 :%s/^/xxx/g – 在每一行的行首插入 xxx，^ 表示行首。 :%s/$/xxx/g – 在每一行的行尾插入 xxx，$ 表示行尾。 所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令， 语法为 :[range]g/pattern/command 例如 : %g/^ xyz/normal dd。 表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。 关于 range 的规定为： 如果不指定 range，则表示当前行。 m,n : 从 m 行到 n 行。 0 : 最开始一行（可能是这样）。 $ : 最后一行 . : 当前行 % : 所有行 5.3 正则表达式高级的查找替换就要用到正则表达式。 \d : 表示十进制数（我猜的） \s : 表示空格 \S : 非空字符 \a : 英文字母 \| : 表示 或 \. : 表示. {m,n} : 表示 m 到 n 个字符。这要和 \s 与 \a 等连用，如 \a\{m,n} 表示 m 到 n 个英文字母。 {m,}: 表示 m 到无限多个字符。 **: 当前目录下的所有子目录。 :help pattern 得到更多帮助。 6. 编辑多个文件6.1 一次编辑多个文件我们可以一次打开多个文件，如 1$ vi a.txt b.txt c.txt 使用 :next(:n) 编辑下一个文件。 :2n 编辑下 2 个文件。 使用 :previous或:N 编辑上一个文件。 使用 :wnext，保存当前文件，并编辑下一个文件。 使用 :wprevious，保存当前文件，并编辑上一个文件。 使用 :args 显示文件列表。 :n filenames 或 :args filenames 指定新的文件列表。 vi -o filenames 在水平分割的多个窗口中编辑多个文件。 vi -O filenames 在垂直分割的多个窗口中编辑多个文件。 6.2 多标签编辑 vim -p files : 打开多个文件，每个文件占用一个标签页。 :tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。 ^w gf – 在新的标签页里打开光标下路径指定的文件。 :tabn – 切换到下一个标签。Control + PageDown，也可以。 :tabp – 切换到上一个标签。Control + PageUp，也可以。 [n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。 :tab split – 将当前缓冲区的内容在新页签中打开。 :tabc[lose] – 关闭当前的标签页。 :tabo[nly] – 关闭其它的标签页。 :tabs – 列出所有的标签页和它们包含的窗口。 :tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。 6.3 缓冲区 :buffers 或 :ls 或 :files 显示缓冲区列表。 ctrl+^：在最近两个缓冲区间切换。 :bn – 下一个缓冲区。 :bp – 上一个缓冲区。 :bl – 最后一个缓冲区。 :b[n] 或 :[n]b – 切换到第 n 个缓冲区。 :nbw(ipeout) – 彻底删除第 n 个缓冲区。 :nbd(elete) – 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。 :ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。 7. 分屏编辑 vim -o file1 file2 : 水平分割窗口，同时打开 file1 和 file2 vim -O file1 file2 : 垂直分割窗口，同时打开 file1 和 file2 7.1 水平分割 :split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S 可能会冻结终端，请按 CTRL-Q 继续。 :split filename – 水平分割窗口，并在新窗口中显示另一个文件。 :nsplit(:nsp) – 水平分割出一个 n 行高的窗口。 :[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 ( CTRL-W n 或 CTRL-W CTRL-N) ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。 C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。 7.2 垂直分割 :vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v 或 CTRL CTRL-V) :[N]vne[w] – 垂直分割出一个新窗口。 :vertical 水平分割的命令： 相应的垂直分割。 7.3 关闭子窗口 :qall – 关闭所有窗口，退出 vim。 :wall – 保存所有修改过的窗口。 :only – 只保留当前窗口，关闭其它窗口。(CTRL-W o) :close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x 同样工作 ) 7.4 调整窗口大小 ctrl+w + –当前窗口增高一行。也可以用 n 增高 n 行。 ctrl+w - –当前窗口减小一行。也可以用 n 减小 n 行。 ctrl+w _ –当前窗口扩展到尽可能的大。也可以用 n 设定行数。 :resize n – 当前窗口 n 行高。 ctrl+w = – 所有窗口同样高度。 n ctrl+w _ – 当前窗口的高度设定为 n 行。 ctrl+w &lt; –当前窗口减少一列。也可以用 n 减少 n 列。 ctrl+w &gt; –当前窗口增宽一列。也可以用 n 增宽 n 列。 ctrl+w | –当前窗口尽可能的宽。也可以用 n 设定列数。 7.5 切换和移动窗口如果支持鼠标，切换和调整子窗口的大小就简单了。 ctrl+w ctrl+w : 切换到下一个窗口。或者是 ctrl+w w。 ctrl+w p : 切换到前一个窗口。 ctrl+w h(l,j,k) :切换到左（右，下，上）的窗口。 ctrl+w t(b) :切换到最上（下）面的窗口。 ctrl+w H(L,K,J) : 将当前窗口移动到最左（右、上、下）面。 ctrl+w r：旋转窗口的位置。 ctrl+w T : 将当前的窗口移动到新的标签页上。 8. 快速编辑8.1 改变大小写 ~ : 反转光标所在字符的大小写。 可视模式下的 U 或 u：把选中的文本变为大写或小写。 gu(U) 接范围（如$，或 G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如 gu5j，把当前行和下面四行全部变成小写。 8.2 替换（normal模式） r : 替换光标处的字符，同样支持汉字。 R : 进入替换模式，按 esc 回到正常模式。 8.3 撤消与重做（normal模式） [n] u : 取消一(n)个改动。 :undo 5 – 撤销 5 个改变。 :undolist – 你的撤销历史。 ctrl + r : 重做最后的改动。 U : 取消当前行中所有的改动。 :earlier 4m – 回到 4 分钟前 :later 55s – 前进 55 秒 8.4 宏 . –重复上一个编辑动作 qa：开始录制宏 a（键盘操作记录） q：停止录制 @a：播放宏 a 9. 编辑特殊文件9.1 文件加解密 vim -x file : 开始编辑一个加密的文件。 :X – 为当前文件设置密码。 :set key= – 去除文件的密码。 这里是 滇狐总结的比较高级的 vi 技巧。 9.2 文件的编码 :e ++enc=utf8 filename, 让 vim 用 utf-8 的编码打开这个文件。 :w ++enc=gbk，不管当前文件什么编码，把它转存成 gbk 编码。 :set fenc 或 :set fileencoding，查看当前文件的编码。 在 vimrc 中添加 set fileencoding=ucs-bom,utf-8,cp936，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。 让 vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置 9.3 文件格式大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。 :e ++ff=dos filename, 让 vim 用 dos 格式打开这个文件。 :w ++ff=mac filename, 以 mac 格式存储这个文件。 :set ff，显示当前文件的格式。 在 vimrc 中添加 set fileformats=unix,dos,mac，让 vim 自动识别文件格式。 10. 编程辅助10.1 一些按键 gd : 跳转到局部变量的定义处； gD : 跳转到全局变量的定义处，从当前文件开头开始搜索； g; : 上一个修改过的地方； g, : 下一个修改过的地方； [[ : 跳转到上一个函数块开始，需要有单独一行的 {。 ]] : 跳转到下一个函数块开始，需要有单独一行的 {。 [] : 跳转到上一个函数块结束，需要有单独一行的 }。 ][ : 跳转到下一个函数块结束，需要有单独一行的 }。 [{ : 跳转到当前块开始处； ]} : 跳转到当前块结束处； [/ : 跳转到当前注释块开始处； ]/ : 跳转到当前注释块结束处； % : 不仅能移动到匹配的 (),{} 或 []上，而且能在 #if，#else， #endif 之间跳跃。 下面的括号匹配对编程很实用的。 ci&#39;, di&#39;, yi&#39;：修改、剪切或复制 &#39; 之间的内容。 ca&#39;, da&#39;, ya&#39;：修改、剪切或复制 &#39; 之间的内容，包含 &#39;。 ci&quot;, di&quot;, yi&quot;：修改、剪切或复制 &quot; 之间的内容。 ca&quot;, da&quot;, ya&quot;：修改、剪切或复制 &quot; 之间的内容，包含 &quot;。 ci(, di(, yi(：修改、剪切或复制 ()之间的内容。 ca(, da(, ya(：修改、剪切或复制 () 之间的内容，包含 ()。 ci[, di[, yi[：修改、剪切或复制 [] 之间的内容。 ca[, da[, ya[：修改、剪切或复制 []之间的内容，包含 []。 ci{, di{, yi{：修改、剪切或复制 {} 之间的内容。 ca{, da{, ya{：修改、剪切或复制 {} 之间的内容，包含 {}。 ci&lt;, di&lt;, yi&lt;：修改、剪切或复制 &lt;&gt; 之间的内容。 ca&lt;, da&lt;, ya&lt;：修改、剪切或复制 &lt;&gt; 之间的内容，包含&lt;&gt;。 10.2 ctags Ctrl + ] 找到光标所在位置的标签定义的地方 Ctrl + t 回到跳转之前的标签处 Ctrl + o 退回原来的地方 [I 查找全局标识符. Vim会列出它所找出的匹配行，不仅在当前文件内查找，还会在所有的包含文件中查找 [i 从当前文件起始位置开始查找第一处包含光标所指关键字的位置 ]i 类似上面的 [i，但这里是从光标当前位置开始往下搜索 [{ 转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。） ]} 转到下一个位于第一列的”}” Ctrl+＼+ s 会出现所有调用、定义该函数的地方，输入索引号，回车即可 [ + ctrl + i 跳转到函数、变量和 #define 用 ctrl+o 返回 [ + ctrl + d 跳转到 #define 处用 ctrl+o 返回 ctags -R : 生成 tag 文件，-R 表示也为子目录中的文件生成 tags :set tags=path/tags – 告诉 ctags 使用哪个 tag 文件 :tag xyz – 跳到 xyz 的定义处，或者将光标放在 xyz 上按 C-]，返回用 C-t :stag xyz – 用分割的窗口显示 xyz 的定义，或者 C-w ]， 如果用 C-w n ]，就会打开一个 n 行高的窗口 :ptag xyz – 在预览窗口中打开 xyz 的定义，热键是 C-w }。 :pclose – 关闭预览窗口。热键是 C-w z。 :pedit abc.h – 在预览窗口中编辑 abc.h :psearch abc – 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。 有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。 :[n]tnext – 下一 [n] 个匹配。 :[n]tprev – 上一 [n]个匹配。 :tfirst – 第一个匹配 :tlast – 最后一个匹配 :tselect tagname – 打开选择列表 tab 键补齐 :tag xyz&lt;tab&gt; – 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。 :tag /xyz&lt;tab&gt; – 会用名字中含有 xyz 的 tag 名补全。 ctags 对 c++ 生成 tags : 1ctags -R --c++-kinds=+p --fields=+iaS --extra=+q 每个参数解释如下： -R : ctags 循环生成子目录的 tags --c++-kinds=+px : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明 --fields=+iaS : ctags 要求描述的信息 其中 i 表示如果有继承，则标识出父类； a 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）； S 表示如果是函数，则标识函数的 signature。 --extra=+q : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。 10.3 cscope查看阅读 c++ 代码 cscope 缺省只解析 C 文件 (.c 和 .h)、lex 文件( .l )和 yacc 文件( .y )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及 Java 后缀的文件。如果希望 cscope 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。 下面的命令会查找当前目录及子目录中所有后缀名为 &quot;.h&quot;, &quot;.c&quot;, &quot;cc&quot; 和 &quot;.cpp&quot; 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 &quot;:help tags&quot; 命令查询它的用法。它可以和 cscope 一起使用。 123$ find . -name "*.h" -o -name "*.c" -o -name "*.cc" -o "*.cpp" &gt; cscope.files$ cscope -bkq -i cscope.files$ ctags -R cscope -Rbq : 生成 cscope.out 文件 :cs add /path/to/cscope.out /your/work/dir :cs find c func – 查找 func 在哪些地方被调用 s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方 g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能 d: 查找本函数调用的函数 c: 查找调用本函数的函数 t: 查找指定的字符串 e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了 f: 查找并打开文件，类似 vim 的 find 功能 i: 查找包含本文件的文件 :cw – 打开 quickfix 窗口查看结果 10.4 gtagsGtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。 :Gtags funcname 定位到 funcname 的定义处。 :Gtags -r funcname 查询 funcname被引用的地方。 :Gtags -s symbol 定位 symbol 出现的地方。 :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。 :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。 :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示 vm 目录下的文件。 10.5 编译vim 提供了 :make 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 :make 即可。 如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置： 1set makeprg=javac\ abc.java 然后 :make 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如： 1:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%# %f 表示文件名，%l 表示行号， %m 表示错误信息，其它的还不能理解。 请参考 :help errorformat。 10.6 快速修改窗口其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 :copen – 打开快速修改窗口。 :cclose – 关闭快速修改窗口。 快速修改窗口在 make 程序时非常有用，当 make 之后： :cl – 在快速修改窗口中列出错误。 :cn – 定位到下一个错误。 :cp – 定位到上一个错误。 :cr – 定位到第一个错误。 10.7 自动补全 C-x C-s – 拼写建议。 C-x C-v – 补全 vim 选项和命令。 C-x C-l – 整行补全。 C-x C-f – 自动补全文件路径。弹出菜单后，按 C-f 循环选择，当然也可以按 C-n 和 C-p。 C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按 C-p 和 C-n也可以。 C-x C-o – 编程时可以补全关键字和函数名啊。 C-x C-i – 根据头文件内关键字补全。 C-x C-d – 补全宏定义。 C-x C-n – 按缓冲区中出现过的关键字补全。 直接按 C-n 或 C-p 即可。 当弹出补全菜单后： C-p 向前切换成员； C-n 向后切换成员； C-e 退出下拉菜单，并退回到原来录入的文字； C-y 退出下拉菜单，并接受当前选项。 10.8 多行缩进缩出 正常模式下，按两下 &gt;; 光标所在行会缩进。 如果先按了 n，再按两下 &gt;;，光标以下的 n 行会缩进。 对应的，按两下 &lt;;，光标所在行会缩出。 如果在编辑代码文件，可以用 = 进行调整。 在可视模式下，选择要调整的代码块，按 =，代码会按书写规则缩排好。 或者 n =，调整 n 行代码的缩排。 10.9 折叠 zf – 创建折叠的命令，可以在一个可视区域上使用该命令； zd – 删除当前行的折叠； zD – 删除当前行的折叠； zfap – 折叠光标所在的段； zo – 打开折叠的文本； zc – 收起折叠； za – 打开/关闭当前折叠； zr – 打开嵌套的折行； zm – 收起嵌套的折行； zR (zO) – 打开所有折行； zM (zC) – 收起所有折行； zj – 跳到下一个折叠处； zk – 跳到上一个折叠处； zi -- enable/disable fold; 10.10 zshrc配置脚本1234567891011121314151617$ vi ~/.zshrcctags_fun()&#123; ctags -R cscope -Rbqk return 0&#125;alias mctags=ctags_fun # define mctagsctags_cplus_fun()&#123; find . -name "*.h" -o -name "*.c" -o -name "*.cc" -o -name "*.cpp" &gt; cscope.files cscope -bkq -i cscope.files ctags -R --c++-kinds=+p --fields=+iaS --extra=+q return 0&#125;alias cplusctags=ctags_cplus_fun # define mctags 11. 其它11.1 工作目录 :pwd 显示vim的工作目录。 :cd path 改变 vim 的工作目录。 :set autochdir 可以让 vim 根据编辑的文件自动切换工作目录。 11.2 一些快捷键（收集中） K : 打开光标所在词的 manpage。 * : 向下搜索光标所在词。 g* : 同上，但部分符合即可。 \# : 向上搜索光标所在词。 g# : 同上，但部分符合即可。 g C-g : 统计全文或统计部分的字数。 11.3 在线帮助 :h(elp) 或 F1 打开总的帮助。 :help user-manual 打开用户手册。 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。 :helptags somepath 为 somepath 中的文档生成索引。 :helpgrep 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。 Ctrl+] 跳转到 tag 主题，Ctrl+t 跳回。 :ver 显示版本信息。 高亮所有搜索模式匹配 shift + * 向后搜索光标所在位置的单词 shift + # 向前搜索光标所在位置的单词 n 和 N 可以继续向后或者向前搜索匹配的字符串 :set hlsearch 高亮所有匹配的字符串 :nohlsearch 临时关闭 :set nohlsearch 彻底关闭，只有重新 :set hlsearch 才可以高亮搜索 vim 高亮显示光标所在的单词，在单词的地方输入 gd 语法高亮 syntax on syntax off vim自动补全 ctrl + n 或者 ctrl + p 复制 vim 文件中所有内容 gg 回到文件首 shift + v 进入 VISUAL LINE 模式 shift + g 全选所有内容 ctrl + insert 复制所选的内容 12 ctags 安装 Vim 配置 Catgs 用于前端开发 Ubuntu16.04安装配置和使用ctags 12.1 安装 universal-ctagsuniversal-ctags 是一个现代化的ctag实现，本文只介绍使用Vim的安装方法 1brew install --HEAD universal-ctags/universal-ctags/universal-ctags universal-ctags 是什么？A maintained ctags implementation, https://ctags.io, 一个负责的 ctags 实现，在github上开源并且持续更新和维护。 12345678$ sudo apt install autoconf$ cd /tmp$ git clone https://github.com/universal-ctags/ctags$ cd ctags$ ./autogen.sh$ ./configure --prefix=/opt/software/universal-ctags # 我的安装路径。你按自己的情况调整。$ make -j8$ sudo make install 把 ctags 可执行文件更新到系统 PATH 上？No, 我选择创建链接的方式： 1234# 如果你装了 emacs-snapshot，那么现在的 ctags 命令实际上链接到了 /usr/bin/ctags-snapshot，要先删除链接文件：# sudo rm /usr/bin/ctags# 然后，把新编译安装的 universal-ctags 链接过来：sudo ln -s /opt/software/universal-ctags/bin/ctags /usr/bin/ctags 其他系统请参考项目主页：ctags 每次生成ctags文件都要手动run一次命令，这一点也不Vim，当然也有解决方法。 12.2 安装vim-gutentagsvim-gutentags 是一个用于自动生成 tag 文件的插件。使用 vim-plug 安装 1Plug 'ludovicchabant/vim-gutentags' 12.3 配置如果只是介绍安装方法，那就必要写这篇文章了，安装完成之后还是要针对前端开发的特点手动调教一下。首先我们在任何目录打开文件，都会在目录下生成 ctags 文件，这样的话对项目代码有入侵性，并不推荐，建议把 tag 文件写在特定的目录里。可以做如下设置： 1let g:gutentags_cache_dir = '~/.cachetags' 这样生成的 tags 文件会统一放在 ~/.cachetags 目录下。另外默认生成的文件名叫 tags，也可以根据个从喜好修改： 1let g:gutentags_ctags_tagfile = '.tags' 这样生成的文件是隐藏文件。另外一个很纠结的问题是有些文件我们并不想让他们生成 tags 文件，比如 node_modules 下文件，还有 .git 目录下的文件。这里有个取巧的方法是根据《Vim配置使用FZF》中的方法，把 ctags 获取文件列表的命令改成 ripgrep 的搜索，这样就可以自动忽略 .gitignore 下的文件。如下： 1let g:gutentags_file_list_command = 'rg --files' 另外有的文件我们也不想让其生成 ctags 文件，比如 *.md、*.svg 文件，可以通过 universal-ctags 的全局配置来配置，这里要注意的是 universal-ctags 默认的全局配置文件已经不是 ~/.ctags 和 ./.ctags，而是在 ~/.ctags.d/*.ctags 和 ./.ctags.d/*.ctags。比如我的全局配置文件放在~/.ctags.d/ignore.ctags。简要配置如下 ： 12345--exclude=node_modules--exclude=gulp--exclude=.git--exclude=*.md--exclude=*.svg 12.4 结合FZF在文章《Vim配置使用FZF》中的介绍，FZF 是支持 ctags 的，所以可以做个快捷键配置，如下： 1map &lt;leader&gt;t :Tags&lt;CR&gt; 这样就可以方便的使用 ctrl-] 和 ctrl-o 来进行 tag 跳转了。 13 Gtags Vim 8 中 C/C++ 符号索引：GTags Ubuntu 安裝 GNU Global(gtags) 阅读Linux内核源码 14. VIM 插件 vim 入坑指南（六）插件 UltiSnips]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络传输基础]]></title>
    <url>%2F2018%2F03%2F16%2Fweb-transmission-basis%2F</url>
    <content type="text"><![CDATA[示例：Web服务器向Http客户端传送数据的过程: 在详细阐述网络传输过程之前，先来看一个最常见的例子，下图显示了一个网络服务器向客户端传送数据的完整过程： 需要传送的数据是网络服务器的HTML页面。 应用协议HTTP报文首部添加到HTML数据之前。报文头信息包括：服务器所使用的HTTP版本（1.0/1.1），以及表明它包含发给网络客户端信息的状态编码（比如200表示Ok）。 HTTP应用层协议将HTML格式的网页数据发送给传输层，传输层添加TCP首部信息。TCP传输层用于管理网络服务器和客户端之间的会话，TCP是面向连接的，通过拥赛控制、滑动窗口、超时重传等机制保证数据有效的传输给客户端。 IP首部添加到TCP首部之前。IP层指定适当的源和目的IP地址。这些信息就构成了IP报文（IP Packet）。 以太网协议首部添加到IP报文的两端之后，就形成了数据链路帧(frame)。上述帧发送至通向网络客户端的路径上的最近一个路由器（默认网关）。每经过一个路由器会移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧（下一个路由器的MAC地址），并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。 数据通过互联网络传输，互联网络包含媒介和中间设备。 客户端接收到包含数据的数据链路帧，处理各层协议头，之后以与添加时相反的顺序移除协议头。首先处理并移除以太网信息，之后是IP协议信息，接下来TCP信息，最后是HTTP信息。 之后，将网页信息传递给客户端网页浏览器，浏览器把HTML网页渲染呈现给用户。 数据封装:消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。 消息大小 理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割（segmentation）为较小的，便于管理的片段，能够带来两点好处： 发送较小片段，网络上同时可有多个会话交错进行。这种在网络上将不同会话片段交错进行的过程称为多路传输（multiplexing）。 分割可提高网络通讯的可靠性。各消息片段从源地址到目的地址无需经过相同路径，如果一条路径被堵塞或断开，其余消息可从替换路径到达目的地址。如果部分消息到不了目的地址，那只需重传丢失部分。 通过对片段打上标签的方式来保证顺序以及在接收时重组。 协议数据单元（Protocol Data Unit, PDU） 应用层数据在传输过程中沿着协议栈向下传递，每一层协议都会向其中添加首部信息，TCP首部和IP首部都是20字节的长度。这就是封装的过程。数据片段在各层网络结构中采用的形式就称为协议数据单元（PDU）。封装过程中，下一层对从上一层收到的PDU进行封装。在处理的每一个阶段PDU都有不同的名字来反应它的功能。 PDU按照TCP/IP协议的命名规范： 数据（Data）：应用层PDU的常用术语 分段（Segment）：传输层PDU 数据报(Packet): 网络成PDU 以太网帧（Frame）：链路层PDU 比特（Bits）：在介质上物理传输数据所使用的PDU。 封装 封装是指在传输之前为数据添加额外的协议头信息的过程。在绝大多数数据通信过程中，源数据在传输前都会封装以数层协议。在网络上发送消息时，主机上的协议栈从上至下进行操作。 以网络服务器为例，HTTP应用层协议发送HTML格式网页数据到传输层，应用层数据被分成TCP分段。各TCP分段被打上标签（主要是端口号，HTTP默认端口为80），称为首部（header），表明接收方哪一个进程应当接收此消息。同时也包含使得接收方能够按照原有的格式来重组数据的信息。 传输层将网页HTML数据封装成分段并发送至网络层，执行IP层协议。整个TCP分段封装成IP报文，也就是再添上IP首部。IP首部包括源和目的IP地址，以及发送报文到目的地址所必须的信息，包括一些控制字段。 之后，IP报文发送到链路层，封装以帧头和帧尾。每个帧头都包含源和目的物理地址。物理地址唯一指定了本地网络上的设备。帧尾包含差错校正信息。最后，由服务器网卡将比特编码传输给介质。 解封装 接收主机以相反的方式（从下至上）进行操作称为解封装。解封装是接收设备移除一层或多层协议头的过程。数据在协议栈中向上移动直到终端应用层伴随着解封装。 访问本地资源：访问本地网络资源需要两种类型的地址：网络层地址和数据链路层地址。网络层和数据链路层负责将数据从发送设备传输至接收设备。两层协议都有源和目的地址，但两种地址的目的不同。 示例：客户端PC1与FTP在同一IP网络的通信 网络地址 网络层地址或IP地址包含两个部分：网络号和主机号。路由器使用网络前缀部分将报文转发给适当的网络。最后一个路由器使用主机部分将报文发送给目标设备。同一本地网络中，网络前缀部分是相同的，只有主机设备地址部分不同。 源IP地址：发送设备，即客户端PC1的IP地址：192.168.1.110 目的IP地址：接收设备，即FTP服务器：192.168.1.9 数据链路地址 数据链路地址（MAC）的目的是在同一网络中将数据链路帧从一个网络接口发送至另一个网络接口。以太网LAN和无线网LAN是两种不同物理介质的网络示例，分别有自己的数据链路协议。 当IP报文的发送方和接收方位于同一网络，数据链路帧直接发送到接收设备（通过ARP来获取目的IP的MAC地址）。以太网上数据链路地址就是以太网MAC地址。MAC地址是物理植入网卡的48比特地址。源MAC地址：发送IP报文的PC1以太网卡MAC地址，AA-AA-AA-AA-AA-AA。 目的MAC地址：当发送设备与接收设备位于同一网络，即为接收设备的数据链路地址。本例中，FTP MAC地址：CC-CC-CC-CC-CC-CC。 源和目的MAC地址添加到以太网帧中。 MAC与IP地址 发送方必须知道接收方的物理和逻辑地址。发送方主机能够以多种方式学习到接收方的IP地址：比如浏览器缓存、getHostByName系统调用、域名系统（Domain Name System, DNS），或通过应用手动输入，如用户指定FTP地址。 以太网MAC地址是怎么识别的呢？发送方主机使用地址解析协议（Address Resolution Protocol, ARP）以检测本地网络的所有MAC地址。如下图所示，发送主机在整个LAN发送ARP请求消息，这是一条广播消息。ARP请求包含目标设备的IP地址，LAN上的每一个设备都会检查该ARP请求，看看是否包含它自身的IP地址。只有符合该IP地址的设备才会发送ARP响应。ARP响应包含ARP请求中IP地址相对应的MAC地址。 访问远程资源： 默认网关 当主机发送消息到远端网络，必须使用路由器，也称为默认网关。默认网关就是位于发送主机同一网络上的路由器的接口IP地址。有一点很重要：本地网络上的所有主机都能够配置自己的默认网关地址。如果该主机的TCP/IP设置中没有配置默认网关地址，或指定了错误的默认网关地址，则远端网络消息无法被送达。 如下图所示，LAN上的主机PC 1使用IP地址为192.168.1.1的R1作为默认网关，如果PDU的目的地址位于另一个网络，则主机将PDU发送至路由器上的默认网关。 与远端网络设备通讯 下图显示了客户端主机PC 1与远端IP网络服务器进行通讯的网络层地址与数据链路层地址： 网络地址 当报文的发送方与接收方位于不同网络，源和目的IP地址将会代表不同网络上的主机。 源IP地址：发送设备即客户端主机PC 1的IP地址：192.168.1.110。 目的IP地址：接收设备即网络服务器的IP地址：172.16.1.99。 数据链路地址 当报文的发送方与接收方位于不同网络，以太网数据链路帧无法直接被发送到目的主机。以太网帧必须先发送给路由器或默认网关。本例中，默认网关是R1，R1的接口IP地址与PC 1属于同一网络，因此PC 1能够直接达到路由器。 源MAC地址：发送设备即PC 1的MAC地址，PC1的以太网接口MAC地址为：AA-AA-AA-AA-AA-AA。 目的MAC地址：当报文的发送方与接收方位于不同网络，这一值为路由器或默认网关的以太网MAC地址。本例中，即R1的以太网接口MAC地址，即：11-11-11-11-11-11。 IP报文封装成的以太网帧先被传输至R1，R1再转发给目的地址即网络服务器。R1可以转发给另一个路由器，如果目的服务器所在网路连接至R1，则直接发送给服务器。 发送设备如何确定路由器的MAC地址？每一个设备通过自己的TCP/IP设置中的默认网关地址得知路由器的IP地址。之后，它通过ARP来得知默认网关的MAC地址，该MAC地址随后添加到帧中。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机算法--图算法介绍]]></title>
    <url>%2F2018%2F03%2F08%2Fgraph%2F</url>
    <content type="text"><![CDATA[图的定义：图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。 图的种类：地图，电路图，调度图，事物，网络，程序结构 图的属性：有V个顶点的图最多有V*（V-1）/2条边 邻接矩阵：邻接矩阵是一个元素为bool值的VV矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为VV，当图是稠密时，邻接矩阵是比较合适的表达方法。 邻接表的表示对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。 深度优先搜索深度优先搜索介绍图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程。 深度优先搜索图解无向图的深度优先搜索下面以”无向图”为例，来对深度优先搜索进行演示。 对上面的图G1进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问(A的邻接点)C。 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 第3步：访问(C的邻接点)B。 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 第4步：访问(C的邻接点)D。 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 第5步：访问(A的邻接点)F。 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 第6步：访问(F的邻接点)G。 第7步：访问(G的邻接点)E。 因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索下面以”有向图”为例，来对深度优先搜索进行演示。 对上面的图G2进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问B。 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 第3步：访问C。 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 第4步：访问E。 接下来访问C的出边的另一个顶点，即顶点E。 第5步：访问D。 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 第6步：访问F。 接下应该回溯”访问A的出边的另一个顶点F”。 第7步：访问G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 广度优先搜索广度优先搜索介绍广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 广度优先搜索图解无向图的广度优先搜索下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。 第1步：访问A。 第2步：依次访问C,D,F。 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 第3步：依次访问B,G。 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 第4步：访问E。 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。 第1步：访问A。 第2步：访问B。 第3步：依次访问C,E,F。 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 第4步：依次访问D,G。 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 搜索算法的源码1. 邻接矩阵表示的"无向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299/*** C++: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"** @author LippiOuYang* @date 2013/04/19*/#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define MAX 100class MatrixUDG &#123;private: char mVexs[MAX]; // 顶点集合 int mVexNum; // 顶点数 int mEdgNum; // 边数 int mMatrix[MAX][MAX]; // 邻接矩阵public: // 创建图(自己输入数据) MatrixUDG(); // 创建图(用已提供的矩阵) MatrixUDG(char vexs[], int vlen, char edges[][2], int elen); ~MatrixUDG(); // 深度优先搜索遍历图 void DFS(); // 广度优先搜索（类似于树的层次遍历） void BFS(); // 打印矩阵队列图 void print();private: // 读取一个输入字符 char readChar(); // 返回ch在mMatrix矩阵中的位置 int getPosition(char ch); // 返回顶点v的第一个邻接顶点的索引，失败则返回-1 int firstVertex(int v); // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1 int nextVertex(int v, int w); // 深度优先搜索遍历图的递归实现 void DFS(int i, int *visited);&#125;;/* * 创建图(自己输入数据) */MatrixUDG::MatrixUDG()&#123; char c1, c2; int i, p1, p2; // 输入"顶点数"和"边数" cout &lt;&lt; "input vertex number: "; cin &gt;&gt; mVexNum; cout &lt;&lt; "input edge number: "; cin &gt;&gt; mEdgNum; if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1)))) &#123; cout &lt;&lt; "input error: invalid parameters!" &lt;&lt; endl; return ; &#125; // 初始化"顶点" for (i = 0; i &lt; mVexNum; i++) &#123; cout &lt;&lt; "vertex(" &lt;&lt; i &lt;&lt; "): "; mVexs[i] = readChar(); &#125; // 初始化"边" for (i = 0; i &lt; mEdgNum; i++) &#123; // 读取边的起始顶点和结束顶点 cout &lt;&lt; "edge(" &lt;&lt; i &lt;&lt; "): "; c1 = readChar(); c2 = readChar(); p1 = getPosition(c1); p2 = getPosition(c2); if (p1==-1 || p2==-1) &#123; cout &lt;&lt; "input error: invalid edge!" &lt;&lt; endl; return ; &#125; mMatrix[p1][p2] = 1; mMatrix[p2][p1] = 1; &#125;&#125;/* * 创建图(用已提供的矩阵) * * 参数说明： * vexs -- 顶点数组 * vlen -- 顶点数组的长度 * edges -- 边数组 * elen -- 边数组的长度 */MatrixUDG::MatrixUDG(char vexs[], int vlen, char edges[][2], int elen)&#123; int i, p1, p2; // 初始化"顶点数"和"边数" mVexNum = vlen; mEdgNum = elen; // 初始化"顶点" for (i = 0; i &lt; mVexNum; i++) mVexs[i] = vexs[i]; // 初始化"边" for (i = 0; i &lt; mEdgNum; i++) &#123; // 读取边的起始顶点和结束顶点 p1 = getPosition(edges[i][0]); p2 = getPosition(edges[i][1]); mMatrix[p1][p2] = 1; mMatrix[p2][p1] = 1; &#125;&#125;/* * 析构函数 */MatrixUDG::~MatrixUDG() &#123;&#125;/* * 返回ch在mMatrix矩阵中的位置 */int MatrixUDG::getPosition(char ch)&#123; int i; for(i=0; i&lt;mVexNum; i++) if(mVexs[i]==ch) return i; return -1;&#125;/* * 读取一个输入字符 */char MatrixUDG::readChar()&#123; char ch; do &#123; cin &gt;&gt; ch; &#125; while(!((ch&gt;='a'&amp;&amp;ch&lt;='z') || (ch&gt;='A'&amp;&amp;ch&lt;='Z'))); return ch;&#125;/** 返回顶点v的第一个邻接顶点的索引，失败则返回-1*/int MatrixUDG::firstVertex(int v)&#123; int i; if (v&lt;0 || v&gt;(mVexNum-1)) return -1; for (i = 0; i &lt; mVexNum; i++) if (mMatrix[v][i] == 1) return i; return -1;&#125;/** 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1*/int MatrixUDG::nextVertex(int v, int w)&#123; int i; if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1)) return -1; for (i = w + 1; i &lt; mVexNum; i++) if (mMatrix[v][i] == 1) return i; return -1;&#125;/* * 深度优先搜索遍历图的递归实现 */void MatrixUDG::DFS(int i, int *visited)&#123; int w; visited[i] = 1; cout &lt;&lt; mVexs[i] &lt;&lt; " "; // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走 for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w)) &#123; if (!visited[w]) DFS(w, visited); &#125;&#125;/* * 深度优先搜索遍历图 */void MatrixUDG::DFS()&#123; int i; int visited[MAX]; // 顶点访问标记 // 初始化所有顶点都没有被访问 for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; "DFS: "; for (i = 0; i &lt; mVexNum; i++) &#123; //printf("\n== LOOP(%d)\n", i); if (!visited[i]) DFS(i, visited); &#125; cout &lt;&lt; endl;&#125;/* * 广度优先搜索（类似于树的层次遍历） */void MatrixUDG::BFS()&#123; int head = 0; int rear = 0; int queue[MAX]; // 辅组队列 int visited[MAX]; // 顶点访问标记 int i, j, k; for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; "BFS: "; for (i = 0; i &lt; mVexNum; i++) &#123; if (!visited[i]) &#123; visited[i] = 1; cout &lt;&lt; mVexs[i] &lt;&lt; " "; queue[rear++] = i; // 入队列 &#125; while (head != rear) &#123; j = queue[head++]; // 出队列 for (k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) &#123; //k是为访问的邻接顶点 if (!visited[k]) &#123; visited[k] = 1; cout &lt;&lt; mVexs[k] &lt;&lt; " "; queue[rear++] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;/* * 打印矩阵队列图 */void MatrixUDG::print()&#123; int i,j; cout &lt;&lt; "Martix Graph:" &lt;&lt; endl; for (i = 0; i &lt; mVexNum; i++) &#123; for (j = 0; j &lt; mVexNum; j++) cout &lt;&lt; mMatrix[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;&#125; int main()&#123; char vexs[] = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; char edges[][2] = &#123; &#123;'A', 'C'&#125;, &#123;'A', 'D'&#125;, &#123;'A', 'F'&#125;, &#123;'B', 'C'&#125;, &#123;'C', 'D'&#125;, &#123;'E', 'G'&#125;, &#123;'F', 'G'&#125;&#125;; int vlen = sizeof(vexs)/sizeof(vexs[0]); int elen = sizeof(edges)/sizeof(edges[0]); MatrixUDG* pG; // 自定义"图"(输入矩阵队列) // pG = new MatrixUDG(); // 采用已有的"图" pG = new MatrixUDG(vexs, vlen, edges, elen); pG-&gt;print(); // 打印图 pG-&gt;DFS(); // 深度优先遍历 pG-&gt;BFS(); // 广度优先遍历 return 0;&#125; 2. 邻接表表示的"无向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343/** * C++: 邻接表表示的"无向图(List Undirected Graph)" * * @author LippiOuYang * @date 2013/04/19 */#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define MAX 100// 邻接表class ListUDG&#123;private: // 内部类 // 邻接表中表对应的链表的顶点 class ENode &#123; public: int ivex; // 该边所指向的顶点的位置 ENode *nextEdge; // 指向下一条弧的指针 &#125;; // 邻接表中表的顶点 class VNode &#123; public: char data; // 顶点信息 ENode *firstEdge; // 指向第一条依附该顶点的弧 &#125;;private: // 私有成员 int mVexNum; // 图的顶点的数目 int mEdgNum; // 图的边的数目 VNode mVexs[MAX];public: // 创建邻接表对应的图(自己输入) ListUDG(); // 创建邻接表对应的图(用已提供的数据) ListUDG(char vexs[], int vlen, char edges[][2], int elen); ~ListUDG(); // 深度优先搜索遍历图 void DFS(); // 广度优先搜索（类似于树的层次遍历） void BFS(); // 打印邻接表图 void print();private: // 读取一个输入字符 char readChar(); // 返回ch的位置 int getPosition(char ch); // 深度优先搜索遍历图的递归实现 void DFS(int i, int *visited); // 将node节点链接到list的最后 void linkLast(ENode *list, ENode *node);&#125;;/* * 创建邻接表对应的图(自己输入) */ListUDG::ListUDG()&#123; char c1, c2; int v, e; int i, p1, p2; ENode *node1, *node2; // 输入"顶点数"和"边数" cout &lt;&lt; "input vertex number: "; cin &gt;&gt; mVexNum; cout &lt;&lt; "input edge number: "; cin &gt;&gt; mEdgNum; if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1)))) &#123; cout &lt;&lt; "input error: invalid parameters!" &lt;&lt; endl; return ; &#125; // 初始化"邻接表"的顶点 for(i=0; i&lt;mVexNum; i++) &#123; cout &lt;&lt; "vertex(" &lt;&lt; i &lt;&lt; "): "; mVexs[i].data = readChar(); mVexs[i].firstEdge = NULL; &#125; // 初始化"邻接表"的边 for(i=0; i&lt;mEdgNum; i++) &#123; // 读取边的起始顶点和结束顶点 cout &lt;&lt; "edge(" &lt;&lt; i &lt;&lt; "): "; c1 = readChar(); c2 = readChar(); p1 = getPosition(c1); p2 = getPosition(c2); // 初始化node1 node1 = new ENode(); node1-&gt;ivex = p2; // 将node1链接到"p1所在链表的末尾" if(mVexs[p1].firstEdge == NULL) mVexs[p1].firstEdge = node1; else linkLast(mVexs[p1].firstEdge, node1); // 初始化node2 node2 = new ENode(); node2-&gt;ivex = p1; // 将node2链接到"p2所在链表的末尾" if(mVexs[p2].firstEdge == NULL) mVexs[p2].firstEdge = node2; else linkLast(mVexs[p2].firstEdge, node2); &#125;&#125;/* * 创建邻接表对应的图(用已提供的数据) */ListUDG::ListUDG(char vexs[], int vlen, char edges[][2], int elen)&#123; char c1, c2; int i, p1, p2; ENode *node1, *node2; // 初始化"顶点数"和"边数" mVexNum = vlen; mEdgNum = elen; // 初始化"邻接表"的顶点 for(i=0; i&lt;mVexNum; i++) &#123; mVexs[i].data = vexs[i]; mVexs[i].firstEdge = NULL; &#125; // 初始化"邻接表"的边 for(i=0; i&lt;mEdgNum; i++) &#123; // 读取边的起始顶点和结束顶点 c1 = edges[i][0]; c2 = edges[i][1]; p1 = getPosition(c1); p2 = getPosition(c2); // 初始化node1 node1 = new ENode(); node1-&gt;ivex = p2; // 将node1链接到"p1所在链表的末尾" if(mVexs[p1].firstEdge == NULL) mVexs[p1].firstEdge = node1; else linkLast(mVexs[p1].firstEdge, node1); // 初始化node2 node2 = new ENode(); node2-&gt;ivex = p1; // 将node2链接到"p2所在链表的末尾" if(mVexs[p2].firstEdge == NULL) mVexs[p2].firstEdge = node2; else linkLast(mVexs[p2].firstEdge, node2); &#125;&#125;/* * 析构函数 */ListUDG::~ListUDG() &#123;&#125;/* * 将node节点链接到list的最后 */void ListUDG::linkLast(ENode *list, ENode *node)&#123; ENode *p = list; while(p-&gt;nextEdge) p = p-&gt;nextEdge; p-&gt;nextEdge = node;&#125;/* * 返回ch的位置 */int ListUDG::getPosition(char ch)&#123; int i; for(i=0; i&lt;mVexNum; i++) if(mVexs[i].data==ch) return i; return -1;&#125;/* * 读取一个输入字符 */char ListUDG::readChar()&#123; char ch; do &#123; cin &gt;&gt; ch; &#125; while(!((ch&gt;='a'&amp;&amp;ch&lt;='z') || (ch&gt;='A'&amp;&amp;ch&lt;='Z'))); return ch;&#125;/* * 深度优先搜索遍历图的递归实现 */void ListUDG::DFS(int i, int *visited)&#123; ENode *node; visited[i] = 1; cout &lt;&lt; mVexs[i].data &lt;&lt; " "; node = mVexs[i].firstEdge; while (node != NULL) &#123; if (!visited[node-&gt;ivex]) DFS(node-&gt;ivex, visited); node = node-&gt;nextEdge; &#125;&#125;/* * 深度优先搜索遍历图 */void ListUDG::DFS()&#123; int i; int visited[MAX]; // 顶点访问标记 // 初始化所有顶点都没有被访问 for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; "DFS: "; for (i = 0; i &lt; mVexNum; i++) &#123; if (!visited[i]) DFS(i, visited); &#125; cout &lt;&lt; endl;&#125; /* * 广度优先搜索（类似于树的层次遍历） */void ListUDG::BFS()&#123; int head = 0; int rear = 0; int queue[MAX]; // 辅组队列 int visited[MAX]; // 顶点访问标记 int i, j, k; ENode *node; for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; "BFS: "; for (i = 0; i &lt; mVexNum; i++) &#123; if (!visited[i]) &#123; visited[i] = 1; cout &lt;&lt; mVexs[i].data &lt;&lt; " "; queue[rear++] = i; // 入队列 &#125; while (head != rear) &#123; j = queue[head++]; // 出队列 node = mVexs[j].firstEdge; while (node != NULL) &#123; k = node-&gt;ivex; if (!visited[k]) &#123; visited[k] = 1; cout &lt;&lt; mVexs[k].data &lt;&lt; " "; queue[rear++] = k; &#125; node = node-&gt;nextEdge; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;/* * 打印邻接表图 */void ListUDG::print()&#123; int i,j; ENode *node; cout &lt;&lt; "List Graph:" &lt;&lt; endl; for (i = 0; i &lt; mVexNum; i++) &#123; cout &lt;&lt; i &lt;&lt; "(" &lt;&lt; mVexs[i].data &lt;&lt; "): "; node = mVexs[i].firstEdge; while (node != NULL) &#123; cout &lt;&lt; node-&gt;ivex &lt;&lt; "(" &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; ") "; node = node-&gt;nextEdge; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; char vexs[] = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; char edges[][2] = &#123; &#123;'A', 'C'&#125;, &#123;'A', 'D'&#125;, &#123;'A', 'F'&#125;, &#123;'B', 'C'&#125;, &#123;'C', 'D'&#125;, &#123;'E', 'G'&#125;, &#123;'F', 'G'&#125;&#125;; int vlen = sizeof(vexs)/sizeof(vexs[0]); int elen = sizeof(edges)/sizeof(edges[0]); ListUDG* pG; // 自定义"图"(输入矩阵队列) //pG = new ListUDG(); // 采用已有的"图" pG = new ListUDG(vexs, vlen, edges, elen); pG-&gt;print(); // 打印图 pG-&gt;DFS(); // 深度优先遍历 pG-&gt;BFS(); // 广度优先遍历 return 0;&#125; 迪杰斯特拉算法迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 操作步骤 (1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 5.3迪杰斯特拉算法图解 以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。 初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 第1步：将顶点D加入到S中。 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。 第2步：将顶点C加入到S中。 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 第3步：将顶点E加入到S中。 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 第4步：将顶点F加入到S中。 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。 第5步：将顶点G加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。 第6步：将顶点B加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。 第7步：将顶点A加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。 此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。 代码本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明， 基本定义12345678910111213141516// 邻接矩阵typedef struct _graph&#123; char vexs[MAX]; // 顶点集合 int vexnum; // 顶点数 int edgnum; // 边数 int matrix[MAX][MAX]; // 邻接矩阵&#125;Graph, *PGraph;// 边的结构体typedef struct _EdgeData&#123; char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重&#125;EData; Graph是邻接矩阵对应的结构体。 vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。 EData是邻接矩阵边对应的结构体。 迪杰斯特拉算法代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * Dijkstra最短路径。 * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。 * * 参数说明： * G -- 图 * vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。 */void dijkstra(Graph G, int vs, int prev[], int dist[])&#123; int i,j,k; int min; int tmp; int flag[MAX]; // flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。 // 初始化 for (i = 0; i &lt; G.vexnum; i++) &#123; flag[i] = 0; // 顶点i的最短路径还没获取到。 prev[i] = 0; // 顶点i的前驱顶点为0。 dist[i] = G.matrix[vs][i];// 顶点i的最短路径为"顶点vs"到"顶点i"的权。 &#125; // 对"顶点vs"自身进行 // 初始化 flag[vs] = 1; dist[vs] = 0; // 遍历G.vexnum-1次；每次找出一个顶点的最短路径。 for (i = 1; i &lt; G.vexnum; i++) &#123; // 寻找当前最小的路径； // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。 min = INF; for (j = 0; j &lt; G.vexnum; j++) &#123; if (flag[j]==0 &amp;&amp; dist[j]&lt;min) &#123; min = dist[j]; k = j; &#125; &#125; // 标记"顶点k"为已经获取到最短路径 flag[k] = 1; // 修正当前最短路径和前驱顶点 // 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。 for (j = 0; j &lt; G.vexnum; j++) &#123; tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); // 防止溢出 if (flag[j] == 0 &amp;&amp; (tmp &lt; dist[j]) ) &#123; dist[j] = tmp; prev[j] = k; &#125; &#125; &#125; // 打印dijkstra最短路径的结果 printf("dijkstra(%c): \n", G.vexs[vs]); for (i = 0; i &lt; G.vexnum; i++) printf(" shortest(%c, %c)=%d\n", G.vexs[vs], G.vexs[i], dist[i]);&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作手册|命令速查表]]></title>
    <url>%2F2018%2F02%2F27%2FGit%2Fgit-guide%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。本文分为以下几个部分： Git与SVN差异 Git常用命令 Git进阶指南 Git与SVN差异Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。 Git 和 SVN 思想最大的差别有四个： 去中心化 直接记录快照，而非差异 不一样的分支概念 三个文件状态 去中心化 Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心 图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。 直接记录快照，而非差异 Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉： SVN： Git: Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。 不一样的分支概念 Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。 三个文件状态 在Git中文件有三种状态： 已提交（committed）：该文件被安全地保存在了本地数据库 已修改（modified）：修改了某个文件，但还没有保存 已暂存（staged）：把已修改的文件放下下次保存的清单中 Git常用命令创建复制一个已创建的仓库: 1$ git clone ssh://user@domain.com/repo.git 创建一个新的本地仓库: 1$ git init 本地修改显示工作路径下已修改的文件： 1$ git status 显示与上次提交版本文件的不同： 1$ git diff 把当前所有修改添加到下次提交中： 1$ git add 把对某个文件的修改添加到下次提交中： 1$ git add -p &lt;file&gt; 提交本地的所有修改： 1$ git commit -a 提交之前已标记的变化： 1$ git commit 附加消息提交： 1$ git commit -m 'message here' 提交，并将提交时间设置为之前的某个日期: 1$ git commit --date="`date --date='n day ago'`" -am "Commit Message" 修改上次提交请勿修改已发布的提交记录! 1$ git commit --amend 把当前分支中未提交的修改移动到其他分支 123$ git stash$ git checkout branch2$ git stash pop 搜索从当前目录的所有文件中查找文本内容： 1$ git grep "Hello" 在某一版本中搜索文本： 1$ git grep "Hello" v2.5 提交历史从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）： 1$ git log 显示所有提交（仅显示提交的hash和message）： 1$ git log --oneline 显示某个用户的所有提交： 1$ git log --author="username" 显示某个文件的所有修改： 1$ git log -p &lt;file&gt; 谁，在什么时间，修改了文件的什么内容： 1$ git blame &lt;file&gt; 分支与标签列出所有的分支： 1$ git branch 切换分支： 1$ git checkout &lt;branch&gt; 创建并切换到新分支: 1$ git checkout -b &lt;branch&gt; 基于当前分支创建新分支： 1$ git branch &lt;new-branch&gt; 基于远程分支创建新的可追溯的分支： 1$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 删除本地分支: 1$ git branch -d &lt;branch&gt; 给当前版本打标签： 1$ git tag &lt;tag-name&gt; 更新与发布列出当前配置的远程端： 1$ git remote -v 显示远程端的信息： 1$ git remote show &lt;remote&gt; 添加新的远程端： 1$ git remote add &lt;remote&gt; &lt;url&gt; 下载远程端版本，但不合并到HEAD中： 1$ git fetch &lt;remote&gt; 下载远程端版本，并自动与HEAD版本合并： 1$ git remote pull &lt;remote&gt; &lt;url&gt; 将远程端版本合并到本地版本中： 1$ git pull origin master 将本地版本发布到远程端： 1$ git push remote &lt;remote&gt; &lt;branch&gt; 删除远程端分支： 123$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)或$ git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0) 发布标签: 1$ git push --tags 合并与重置将分支合并到当前HEAD中： 1$ git merge &lt;branch&gt; 将当前HEAD版本重置到分支中:请勿重置已发布的提交! 1$ git rebase &lt;branch&gt; 退出重置: 1$ git rebase --abort 解决冲突后继续重置： 1$ git rebase --continue 使用配置好的merge tool 解决冲突： 1$ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突 12$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt; 撤销放弃工作目录下的所有修改： 1$ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次git add）: 1$ git reset HEAD 放弃某个文件的所有本地修改： 1$ git checkout HEAD &lt;file&gt; 重置一个提交（通过创建一个截然不同的新提交） 1$ git revert &lt;commit&gt; 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改： 1$ git reset --hard &lt;commit&gt; 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： 1$ git reset &lt;commit&gt; 将HEAD重置到上一次提交的版本，并保留未提交的本地修改： 1$ git reset --keep &lt;commit&gt; Git进阶指南问：如何修改 origin 仓库信息？1、添加 origin 仓库信息1$ git remote add origin &lt;git仓库地址&gt; 2、查看 origin 仓库信息1234# 以下三种方式均可$ git config get --remote.origin.url$ git remote -v$ git remote show origin 3、删除 origin 仓库信息1$ git remote rm origin 问：如何配置 git ssh keys ？在本地生成 ssh 私钥 / 公钥 文件 将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台 测试 git ssh 连接是否成功 接下来以添加 github ssh keys 为例，请注意替换 github 文件名。 注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。 1234567891011# 运行以下命令，一直回车，文件名可随意指定$ ssh-keygen -t rsa -b 4096 -C "kaiye@macbook" -f ~/.ssh/github# 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain$ ssh-add -K ~/.ssh/github# 将 pub 公钥的内容粘贴到线上网站的后台$ cat ~/.ssh/github.pub# 测试 git ssh 是否连接成功$ ssh -T git@github.com 问：如何撤销修改？修改包含四种情况，需单独区分。 1、新建的文件和目录，且从未提交至版本库此类文件的状态为 Untracked files ，撤销方法如下： 1$ git clean -fd . 其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。 2、提交过版本库，但未提交至暂存区的文件（未执行 git add）此类文件的状态为Changes not staged for commit，撤销方法： 1$ git checkout . 3、已提交至暂存区的文件此类文件的状态为 Changes to be committed，撤销方法： 1$ git reset . 执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。 4、已提交至版本库（执行了 git commit）每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚： 12$ git log$ git reset &lt;版本号&gt; 如果需要「回滚至上一次提交」，可直接使用以下命令： 1$ git reset head~1 执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。 5、如果回滚了之后又不想回滚了怎么办？如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。 如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。 问：遇到冲突了怎么解决？两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。 1、最快的办法大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。 12345678# 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方$ git checkout --ours &lt;文件名&gt;# 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分$ git checkout --theirs &lt;文件名&gt;# 标记为解决状态加入暂存区$ git add &lt;文件名&gt; 2、最通用的办法用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。 在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。 3、最好的习惯有三个好的习惯，可以减少代码的冲突： 在开始修改代码前先 git pull 一下； 将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件； 通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。 4、最复杂的情况如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。 它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。 rebase 大概的操作步骤如下： 1234567891011# 将当前分支的版本追加到从远程 pull 回来的节点之后$ git pull --rebase# 若发生冲突，则按以上其他方法进行解决，解决后继续$ git rebase --continue# 直到所有冲突得以解决，待项目最后上线前再执行$ git push origin# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可$ git rebase --skip 问：如何在不提交修改的前提下，执行 pull / merge 等操作？有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。 这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。 以下是 git stash 常用命令： 1234567891011121314# 查看 stash 队列中已暂存了多少 WIP$ git stash list# 恢复上一次的 WIP 状态，并从队列中移除$ git stash pop# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失$ git stash# 恢复指定编号的 WIP，同时从队列中移除$ git stash pop stash@&#123;num&#125;# 恢复指定编号的 WIP，但不从队列中移除$ git stash apply stash@&#123;num&#125; 问：如何在 git log 中查看修改的文件列表？默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。 1$ git log --name-status --oneline 每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作： 1$ git config --global alias.ls 'log --name-status --oneline --graph' 运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。 1$ git config --global alias.st 'status --porcelain' 更多 git log 参数，可通过 git help log 查看手册。 如果是看上一次提交的版本日志，直接运行 git show 即可。 此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。 问：git submodule update 时出错怎么解决？例如，在执行 git submodule update 时有以下错误信息： fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’ 在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。 解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。 其他问题设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可 1$ git push origin master -u 支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示） 1$ git config core.quotepath off 常用的打 tag 操作，更多请查看《Git 基础 - 打标签》 12345678910# 列出所有本地 tag$ git tag # 本地新增一个 tag，推送至 origin 服务器$ git tag -a v1.0.0 -m 'tag description'$ git push origin v1.0.0# 删除本地与 origin tag$ git tag -d v1.0.0$ git push origin --delete v1.0.0 使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令： 123456789101112# 新建分支 branch1，并切换过去$ git checkout -b branch1# 查看所有本地与远程分支$ git branch -a# 修改完成后，切换回 master 分支，将 branch1 分支合并进来$ git checkout master$ git merge branch1# 删除已完成合并的分支 branch1$ git branch -d branch1 参考资料 Pro Git 简体中文版 Git权威指南 命令行man手册]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习深度学习-文章收藏]]></title>
    <url>%2F2018%2F01%2F13%2FDeepLearning%2Fnote-blog-link%2F</url>
    <content type="text"><![CDATA[沁原的硅谷创新课 Github项目推荐 | 基于 deepfakes（视频换脸）的非官方项目deepfakes_faceswap]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dogs vs Cats (猫狗大战)]]></title>
    <url>%2F2018%2F01%2F03%2FDeepLearning%2FDogsVsCats%2F</url>
    <content type="text"><![CDATA[GitHub 项目地址：Dogs vs Cats (猫狗大战) 项目说明本项目是优达学城的一个毕业项目。项目要求使用深度学习方法识别一张图片是猫还是狗 输入：一张彩色图片 输出：是猫还是狗 项目环境项目使用Anaconda搭建环境。可是使用environment目录下的yml进行环境安装。 1$ conda env create -f environment.yml 数据来源数据集来自 kaggle 上的一个竞赛：Dogs vs. Cats Redux: Kernels Edition。 下载kaggle猫狗数据集解压后分为 3 个文件 train.zip、 test.zip 和 sample_submission.csv。 train 训练集包含了 25000 张猫狗的图片， 每张图片包含图片本身和图片名。命名规则根据“type.num.jpg”方式命名。 test 测试集包含了 12500 张猫狗的图片， 每张图片命名规则根据“num.jpg”，需要注意的是测试集编号从 1 开始， 而训练集的编号从 0 开始。 sample_submission.csv 需要将最终测试集的测试结果写入.csv 文件中，上传至 kaggle 进行打分。 基准模型项目使用ResNet50, Xception, Inception V3 这三个模型完成。本项目的最低要求是 kaggle Public Leaderboard 前10%。在kaggle上，总共有1314只队伍参加了比赛，所以需要最终的结果排在131位之前，131位的得分是0.06127，所以目标是模型预测结果要小于0.06127。 评估指标kaggle 官方的评估标准是 LogLoss，下面的表达式就是二分类问题的 LogLoss 定义。 其中： n 是测试集中图片数量 是图片预测为狗的概率 如果图像是狗，则为1，如果是猫，则为0 是自然（基数 ）对数 对数损失越小，代表模型的性能越好。上述评估指标可用于评估该项目的解决方案以及基准模型。 设计大纲12$ cd model_graphviz/$ make 整个模型是在本地训练的，训练了三天才完成。建议使用云端 GPU 训练复现实验过程。 1. 数据预处理 从kaggle下载好图片 将猫和狗的图片放在不同的文件夹以示分类，使用创建符号链接的方法 对图片进行resize，保持输入图片信息大小一致 2. 模型搭建 Kera的应用模块Application提供了带有预训练权重的Keras模型，这些模型可以用来进行预测、特征提取和微调整和。 Xception 默认输入图片大小是 299*299*3 InceptionV3 默认输入图片大小是 299*299*3 ResNet50 默认输入图片大小是 224*224*3 在Keras中载入模型并进行全局平均池化，只需要在载入模型的时候，设置include_top=False, pooling=&#39;avg&#39;. 每个模型都将图片处理成一个1*2048的行向量，将这三个行向量进行拼接，得到一个1*6144的行向量， 作为数据预处理的结果。 3. 模型训练&amp;模型调参 载入预处理的数据之后，先进行一次概率为0.5的dropout，然后直接连接输出层，激活函数为Sigmoid，优化器为Adam，输出一个零维张量，表示某张图片中有狗的概率。 4. 模型评估 使用$Logloss$进行模型评估,上传Kaggle判断是否符合标准 5. 可视化 进行数据探索并且可视化原始数据 可视化模型训练过程的准确率曲线，损失函数曲线等 项目部署项目使用 Keras 和 Flask 搭建部署一个简单易用的深度学习图像网页应用，可以通过网页导入一张彩色猫或者狗的图片预测是猫或者狗的概率。 项目目录结构： 12345678910111213141516171819.├── README.md├── ResNet50_image_predict.ipynb├── app.py├── environmert.yml├── static│ ├── css│ │ └── main.css│ └── js│ └── main.js├── templates│ ├── base.html│ └── index.html├── models│ └── ResNet50_catdog_model.h5├── uploads│ ├── test01.jpg│ └── test02.jpg└── webapp_image_predict.ipynb 环境搭建1$ conda env create -f environmert.yml 运行1$ python app.py 这时候用浏览器打开 http://localhost:5000/ 就可以进行网页导入图片预测图片是狗的概率了。 快速复现webapp预测结果如果不想搭建环境复现实验结果，可以按照以下操作分分钟复现实验结果： 12$ docker pull miaowmiaow/webapp:1.1.0$ docker run -p 5000:5000 miaowmiaow/webapp:1.1.0 到此就可以在浏览器中输入 http://localhost:5000 就可以使用网页对导入的猫狗图片做预测了。 下图为预测的效果图：]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket教程]]></title>
    <url>%2F2017%2F05%2F16%2FWebSocket%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转自阮一峰网络编程 WebSocket 是一种网络通信协议，很多高级功能都需要它。 为什么需要 WebSocker初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是 ws（如果加密，则为 wss ），服务器网址就是 URL。 1ws://example.com:80/some/path 客户端的简单示例WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 123456789101112131415var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; 客户端的 APIWebSocket 客户端的 API 如下。 WebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyStatereadyState 属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的 onopen 属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send('Hello Server!');&#125; 如果要指定多个回调函数，可以使用addEventListener`方法。 123ws.addEventListener('open', function (event) &#123; ws.send('Hello Server!');&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener("close", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener("message", function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（ blob 对象或 Arraybuffer 对象）。 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log("Received data string"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log("Received arraybuffer"); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = "blob";ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = "arraybuffer";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send( )实例对象的 send( ) 方法用于向服务器发送数据。 发送文本的例子。 1ws.send('your message'); 发送 Blob 对象的例子。 1234var file = document .querySelector('input[type="file"]') .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的 bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener("error", function(event) &#123; // handle error event&#125;); 服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本 counter.sh。 123456789#!/bin/bashecho 1sleep 1echo 2sleep 1echo 3 命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。 1234$ bash ./counter.sh123 现在，启动websocketd，指定这个脚本作为服务。 1$ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是 8080 。每当客户端连接这个服务器，就会执行 counter.sh 脚本，并将它的输出推送给客户端。 12345var ws = new WebSocket('ws://localhost:8080/');ws.onmessage = function(event) &#123; console.log(event.data);&#125;; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 1$ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子 五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务 greeter.js。 12345678process.stdin.setEncoding('utf8');process.stdin.on('readable', function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write('data: ' + chunk); &#125;&#125;); 启动这个脚本的命令如下。 1$ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 参考链接 How to Use WebSockets WebSockets - Send &amp; Receive Messages Introducing WebSockets: Bringing Sockets to the Web]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制支持串口安装的ubuntu系统镜像]]></title>
    <url>%2F2017%2F05%2F15%2F%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[1、所需环境：硬件环境： 笔记本 串口调试线缆 光盘 显示器 FWA产品的任一机型（此次使用的是FWA-4210） SATA或者USB光驱×1 软件环境： 带有genisoimage(旧版是mkisofs)的linux发行版（此次使用的是Ubuntu 16.04 server版） Ubuntu官网通用镜像ISO文件 2、操作过程：2.1 开机进入系统，将光盘挂载到Ubuntu系统CLI命令如下； 1$ mount -o loop ubuntu-16.04.2-server-amd64.iso /mnt/temp 2.2 更改配置相关配置文件（menu.cfg、txt.cfg、isolinux.cfg此文件不是必须要修改，具体见下边解释）。将光盘文件，拷贝到临时目录（家目录或者自己新建目录均可，但建议拷贝到/var或/temp目录下），具体命令如下： 1$ cp -rf /mnt/temp/ /var/mycdrom 因为 /mnt 目录的默认权限是 333 ，所以在此使用 -r 和 -f 参数，-r 代表递归，即文件夹下所有文件都拷贝，-f 代表强制执行； 更改 menu.cfg 文件，如下图，主要是注释掉标准安装的配置文件，以便可以定制安装。 123$ cd /var/mycdrom/temp/isolinux$ vi menu.cfg 注： vi有三种模式，普通模式、编辑模式、命令行模式； I o a进入编辑模式， 普通模式下数字+yy复制 P黏贴 命令行模式：w写入，q离开，！强制执行 注释 menu.cfg 内容如下红框所示： 更改 txt.cfg 文件，主要用于定制串口安装（如下图）： 更改 isolinux.cfg 文件，主要修改grub菜单等待时间（如下图），也可不修改； 2.3 重新打包ISO文件命令如下： 1$ genisoimage -o ubuntu-16.04.2-server-adm64-console_115200.iso -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b isolinux/isolinux.bin -c isolinux/boot.cat /var/mycdrom/temp genisoimage 是linux各大发行版制作ISO镜像比较流行的工具，若要定制系统，最好在linux下更改相关配置，并使用此工具重新打包；若在Windows平台使用UltraISO等工具解压更改重新打包会出现不稳定的情况（无法找到镜像，无法找到安装源等）。 -o ：是output缩写，用来指定输出镜像名称 -r ： 即rational-rock，用来开放ISO文件所有权限（r、w、x） -J ： 即Joliet，一种ISO9600扩展格式，用来增加兼容性，最好加上 -no-emul-boot -boot-load-size 4 -boot-info-table ：指定兼容模式下虚拟扇区的数量，若不指定，有些BISO会出现一些问题 -b ：指定开机映像文件 -c ：具体开机配置文件 最后加上输出目录 Reboot系统U盘启动，即可安装系统。 3、文本安装系统注意事项3.1 进入安装模式关闭系统插入U盘，启动系统，看到如下提示按F12进入安装系统模式： 1Press F12 for boot menu.. 选择U盘所在的选项。 3.2 分区若是硬盘已有linux发行版系统，那在如下界面，必须umount分区，才能将更改写入分区表 3.3 自动更新如下界面，若有特许需求（需要安装一些特许软件apache、weblogic等）可以选择自动更新（需要联网），一般情况不选则自动更新]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本攻略笔记]]></title>
    <url>%2F2017%2F05%2F15%2FShell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 基本命令1.1 shell 格式输出12345678$ echo 'Hello world !'-n # 忽略结尾的换行符-e # 激活转义字符-E # disable转义字符# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。$ echo -e "1\t2\t3" 打印彩色输出： 1234567# 彩色文本# 重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37$ echo -e "\e[1;31m This is red text \e[0m"# 彩色背景# 重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47$ echo -e "\e[1;42m Green Background \e[0m" 1$ printf "%-5s %-10s %-4s\n" No Name Mark 原理： %-5s 指明了一个格式为左对齐且宽度为5的字符串替换（ -表示左对齐）。如果不用 - 指定对齐方式，字符串就采用右对齐形式。 %s 、 %c 、%d 和 %f 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 1.2 替换命令 tr123456789101112131415161718192021222324252627282930313233# tr 是 translate的简写$ tr '\0' '\n' # 将 \0 替换成 \n$ tr [选项]… 集合1 [集合2]选项说明：-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。-d, –delete 删除集合1中的字符而不是转换-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符字符集合的范围：\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序[CHAR*] in SET2, copies of CHAR until length of SET1[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal if starting with 0[:alnum:] 所有的字母和数字[:alpha:] 所有字母[:blank:] 水平制表符，空白等[:cntrl:] 所有控制字符[:digit:] 所有的数字[:graph:] 所有可打印字符，不包括空格[:lower:] 所有的小写字符[:print:] 所有可打印字符，包括空格[:punct:] 所有的标点字符[:space:] 所有的横向或纵向的空白[:upper:] 所有大写字母 1.3 打印变量1234$ var="value"$ echo $var或者$ echo $&#123;var&#125; 1.4 设置环境变量12345# 在PATH中添加一条新路径$ export PATH="$PATH:/home/user/bin"也可以使用：$ PATH="$PATH:/home/user/bin"$ export PATH 1.5 Shell中三种引号的用法123456789101112131415161718# 单引号# 使用单引号时，变量不会被扩展（expand），将依照原样显示。$ var="123"$ echo '$var' will print $var结果为：'$var' will print 123# 双引号# 输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出$ echo "$var" will print $var结果为：123 will print 123# 反引号# 命令替换$ var=`whoami`$ echo $var结果为：root# 备注：反引号和$()作用相同 1.6 获得字符串的长度123456# 用法$ length=$&#123;#var&#125;$ var=12345678901234567890$ echo $&#123;#var&#125;20 1.7 识别当前shell123$ echo $SHELL也可以使用：$ echo $0 1.8 使用shell进行数学运算在Bash shell环境中，可以利用 let、(( )) 和[] 执行基本的算术操作。而在进行高级操作时，expr 和 bc 这两个工具也会非常有用。 使用 let 时，变量名之前不需要再添加 $ 123$ no1=4$ let no1++$ let no1+=6 # 等同于let no=no+6 1234# 操作符[]的使用方法和let命令类似$ result=$[ no1 + no2 ]# 在[]中也可以使用$前缀$ result=$[ $no1 + 5 ] 12# 使用(())时，变量名之前需要加上$$ result=$(( no1 + 50 )) 123# expr同样可以用于基本算术操作$ result=`expr 3 + 4`$ result=$(expr $no1 + 5) bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。 1.9 shell中各种括号的作用()、(())、[]、[[]]、{}1.9.1 小括号，圆括号（）1、单小括号 ( ) 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。 命令替换。等同于cmd，shell扫描一遍命令行，发现了$(cmd)结构 ，便将 $(cmd) 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。 用于初始化数组。如：array=(a b c d)。 2、双小括号 (( )) 整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。 只要括号中的运算符、表达式符合C语言运算规则，都可用在 $((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。 单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6。 常用于算术运算比较，双括号中的变量可以不使用$ 符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in seq 0 4或者for i in {0..4}。再如可以直接使用 if (($i&lt;5)) , 如果不使用双括号, 则为 if [ $i -lt 5 ] 。 1.9.2 中括号，方括号[]1、单中括号 [] bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。 Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。 2、双中括号 [[ ]] [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。 使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 if [[ $a != 1 &amp;&amp; $a != 2 ]] , 如果不适用双括号, 则为 if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者 if [ $a -ne 1 -a $a != 2 ] 。 bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。 1.9.3 大括号、花括号 {}1）常规用法 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。 2）几种特殊的替换结构 1$&#123;var:-string&#125;,$&#123;var:+string&#125;,$&#123;var:=string&#125;,$&#123;var:?string&#125; ${var:-string} 和 ${var:=string}: 若变量var为空，则用在命令行中用string来替换 ${var:-string}，否则变量var不为空时，则用变量var的值来替换 ${var:-string} ；对于 ${var:=string} 的替换规则和 ${var:-string} 是一样的，所不同之处是 ${var:=string} 若var为空时，用string替换 ${var:=string} 的同时，把string赋给变量 var： ${var:=string} 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。 ${var:+string} 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。 ${var:?string} 替换规则为：若变量var不为空，则用变量var的值来替换 ${var:?string} ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。 补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。 3）四种模式匹配替换结构 模式匹配记忆方法： 123# 是去掉左边(在键盘上#在$之左边)% 是去掉右边(在键盘上%在$之右边)#和%中的单一符号是最小匹配，两个相同符号是最大匹配。 1$&#123;var%pattern&#125;,$&#123;var%%pattern&#125;,$&#123;var#pattern&#125;,$&#123;var##pattern&#125; 第一种模式：${variable%pattern} ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式 第二种模式：${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式 第四种模式：${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。 4）字符串提取和替换 1$&#123;var:num&#125;,$&#123;var:num1:num2&#125;,$&#123;var/pattern/pattern&#125;,$&#123;var//pattern/pattern&#125; 第一种模式：${var:num} ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 ${var: -2} 、${var:1-3} 或 ${var:(-2)}。 第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从 $var字符串的第$num1 个位置开始提取长度为$num2的子串。不能为负数。 第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。。 第四种模式：${var//pattern/pattern} 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。 1.9.4 符号$后的括号 ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。 $(cmd) 命令替换，和cmd效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 $() 形式的命令替换, 如tcsh。 $((expression)) 和exprexpression效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。 1.9.5 多条命令执行 单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。 单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。 对 {} 和 () 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。 1.10 Shell特殊变量 `$0, $#, $*, $@, $?, ### 和命令行参数 变量 含义 $0 当前脚本的文件名。 $n 传递给脚本或函数的参数。n是一个数字，表示几个参数。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。 1.10.1 命令行参数运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。 1.10.2 $* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 但是当它们被双引号(“ “)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot; 的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以 &quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;的形式输出所有参数。 1.10.3 退出状态$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 不过，也有一些命令返回其他值，表示不同类型的错误。 $? 也可以表示函数的返回值，此处不展开。 1.11 Shell重定向1、重定向符号 1234&gt; 输出重定向到一个文件或设备 覆盖原来的文件&gt;! 输出重定向到一个文件或设备 强制覆盖原来的文件&gt;&gt; 输出重定向到一个文件或设备 追加原来的文件&lt; 输入重定向到一个程序 2、标准输入刷出 1234在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt; 3、使用实例 12345678910111213# &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。# 1&gt;&amp;2 意思是把标准输出重定向到标准错误.# 2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。# &amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中$ cmd &lt;&gt; file # 以读写方式打开文件 file$ cmd &gt;&amp;n # 将 cmd 的输出发送到文件描述符 n$ cmd m&gt;&amp;n # 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n$ cmd m&lt;&amp;n # 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取$ cmd &gt;&amp;- # 关闭标准输出$ cmd &lt;&amp;- # 关闭标准输入$ cmd &gt;&amp; file # 将标准输出和标准错误都发送到文件 file $ cmd &amp;&gt; file # 作用同上, 更好的格式 要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。 12345678# 用法：command | tee FILE1 FILE2$ cat a* | tee out.txt | cat -n# 默认情况下， tee命令会将文件覆盖，但它提供了一个-a选项，用于追加内容$ cat a* | tee -a out.txt | cat –n# 我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可# 用法：$ cmd1 | cmd2 | cmd -$ echo who is this | tee - 1.12 Shell数组和关联数组1.12.1 简介数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。 1.12.2 定义打印普通数组数组的方法有如下几种： 1234567#在一行上列出所有元素$ array_var=(1 2 3 4 5 6)#以“索引-值”的形式一一列出$ array_var[0]="test1"$ array_var[1]="test2"$ array_var[2]="test3" 注意：第一种方法要使用圆括号，否则后面会报错。 数组元素的方法有如下几种： 123456$ echo $&#123;array_var[0]&#125; #输出结果为 test1$ index=2$ echo $&#123;array_var[$index]&#125; #输出结果为 test3$ echo $&#123;array_var[*]&#125; #输出所有数组元素$ echo $&#123;array_var[@]&#125; #输出所有数组元素$ echo $&#123;#array_var[*]&#125; #输出值为 3 注意：在ubuntu 14.04中，shell脚本要以#!/bin/bash开头，且执行脚本的方式为 bash test.sh。 1.12.3 定义打印关联数组定义关联数组在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下： 12345678$ declare -A ass_array #声明一个关联数组$ ass_array=(["index1"]=index1 ["index2"]=index2)#内嵌“索引-值”列表法$ ass_array["index3"]=index3$ ass_array["index4"]=index4$ echo $&#123;ass_array["index1"]&#125; #输出为index1$ echo $&#123;ass_array["index4"]&#125;$ echo $&#123;!ass_array[*]&#125; #输出索引列表$ echo $&#123;!ass_array[@]&#125; #输出索引列表 注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。 1.13 使用别名alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~/.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~/.bashrc中的命令。 1$ alias install='sudo apt-get install' 1.14 获取、设置日期和延时时间方面 : 1234567891011121314% : 印出% %n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区 日期方面 : 12345678910111213141516171819%a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy) 若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中： 1234567MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数 参数 : -d datestr : 显示 datestr 中所设定的时间 (非系统时间) –help : 显示辅助讯息 -s datestr : 将系统时间设为 datestr 中所设定的时间 -u : 显示目前的格林威治时间 –version : 显示版本编号 例子： 12345$ date # 获取日期$ date +%s # 打印纪元时$ date "+%d %B %Y" # 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期20 May 2010$ date -s "21 June 2009 11:01:22" # 设置日期和时间 1.15 脚本调试1.15.1使用选项–x，启用shell脚本的跟踪调试功能1$ bash -x script.sh 1.15.2 使用set -x和set +x对脚本进行部分调试123456789#!/bin/bash#文件名: debug.shfor i in &#123;1..6&#125;do set -x echo $i set +xdoneecho "Script executed" set –x：在执行时显示参数和命令。 set +x：禁止调试。 set –v：当命令进行读取时显示输入。 set +v：禁止打印输入。 1.15.3 通过传递 _DEBUG环境变量调试123456789#!/bin/bashfunction DEBUG()&#123; [ "$_DEBUG" == "on" ] &amp;&amp; $@ || :&#125;for i in &#123;1..10&#125;do DEBUG echo $idone 可以将调试功能置为”on”来运行上面的脚本： 1$ _DEBUG=on ./script.sh 我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG=on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 : 告诉shell不要进行任何操作。 1.15.4 利用shebang来进行调试shebang的妙用把shebang从 #!/bin/bash 改成 #!/bin/bash -xv，这样一来，不用任何其他选项就可以启用调试功能了。 1.16 函数参数1234567$0 # 脚本名$1 # 第一个参数$2 # 第二个参数$n # 第n个参数"$@" # 被扩展成 "$1" "$2" "$3"等"$*" # 被扩展成 "$1c$2c$3"，其中c是IFS的第一个字符"$@" 要比"$*"用得多。由于 "$*"将所有的参数当做单个字符串，因此它很少被使用。 导出函数： 函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： 1export -f fname 1.17 read命令123456789101112# 从输入中读取n个字符并存入变量$ read -n 2 var$ echo $var# 用无回显的方式读取密码$ read -s var# 显示提示信息$ read -p "Enter input:" var# 在特定时(秒)限内读取输入$ read -t timeout var 1.18 条件比较与测试123456789101112131415# if条件if conditionthen commandsfi# else if和elseif conditionthen commandselse if condition then commandselse commandsfi if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： 12[ condition ] &amp;&amp; action # 如果condition为真，则执行action[ condition ] || action # 如果condition为假，则执行action &amp;&amp; 是逻辑与运算符， || 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 算术比较： -gt ：大于。 -lt ：小于。 -ge ：大于或等于。 -le ：小于或等于。 可以按照下面的方法结合多个条件进行测试： 12[ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a[ $var1 -ne 0 -o var2 -gt 2 ] #逻辑或 -o 文件系统相关测试： 我们可以使用不同的条件标志测试不同的文件系统相关的属性。 [ -f $file_var ] ：如果给定的变量包含正常的文件路径或文件名，则返回真。 [ -x $var ] ：如果给定的变量包含的文件可执行，则返回真。 [ -d $var ] ：如果给定的变量包含的是目录，则返回真。 [ -e $var ] ：如果给定的变量包含的文件存在，则返回真。 [ -c $var ] ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 [ -b $var ] ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 [ -w $var ] ：如果给定的变量包含的文件可写，则返回真。 [ -r $var ] ：如果给定的变量包含的文件可读，则返回真。 [ -L $var ] ：如果给定的变量包含的是一个符号链接，则返回真。 字符串比较： 使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 可以用下面的方法检查两个字符串，看看它们是否相同。 [[ $str1 = $str2 ]]：当str1等于str2时，返回真。也就是说， str1和str2包含的文本是一模一样的。 [[ $str1 == $str2 ]] ：这是检查字符串是否相等的另一种写法。 也可以检查两个字符串是否不同。 [[ $str1 != $str2 ]] ：如果str1和str2不相同，则返回真。 我们还可以检查字符串的字母序情况，具体如下所示。 [[ $str1 &gt; $str2 ]] ：如果str1的字母序比str2大，则返回真。 [[ $str1 &lt; $str2 ]] ：如果str1的字母序比str2小，则返回真。 [[ -z $str1 ]] ：如果str1包含的是空字符串，则返回真。 [[ -n $str1 ]] ：如果str1包含的是非空字符串，则返回真。 使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： 1234if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]] then commandsfi test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 123if [ $var -eq 0 ]; then echo "True"; fi# 也可以写成：if test $var -eq 0 ; then echo "True"; fi 补充内容1. 利用子shell生成一个独立的进程子shell本身就是独立的进程。可以使用 ( )操作符来定义一个子shell ： 123pwd;(cd /bin; ls);pwd; 2. 无限循环的实例1repeat() &#123; while true; do $@ &amp;&amp; return; done &#125; 工作原理： 函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 $@ 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 一种更快的做法 ： 在大多数现代系统中， true 是作为 /bin 中的一个二进制文件来实现的。这就意味着每执行一次while循环， shell就不得不生成一个进程。如果不想这样，可以使用shell内建的 :命令，它总是会返回为0的退出码： 1repeat() &#123; while :; do $@ &amp;&amp; return; done &#125; 尽管可读性不高，但是肯定比第一种方法快。 2. 命令之乐2.1 cat命令123456# 摆脱多余的空白行$ cat -s file# 显示行号$ cat -n file# -n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。 2.2 find命令123456# 列出当前目录及子目录下所有的文件和文件夹$ find base_path$ find . -print# -print指明打印出匹配文件的文件名（路径）。当使用 -print时， '\n'作为用于对输出的文件名进行分隔。就算你忽略-print， find命令仍会打印出文件名。# -print0指明使用'\0'作为匹配的文件名之间的定界符。 1、find命令有一个选项 -iname（忽略字母大小写） 12345$ lsexample.txt EXAMPLE.txt file.txt$ find . -iname "example*" -print./example.txt./EXAMPLE.txt 2、如果想匹配多个条件中的一个，可以采用OR条件操作 : 12345$ lsnew.txt some.jpg text.pdf$ find . \( -name "*.txt" -o -name "*.pdf" \) -print./text.pdf./new.txt 3、选项-path的参数可以使用通配符来匹配文件路径。 -name 总是用给定的文件名进行匹配。-path 则将文件路径作为一个整体进行匹配。例如 : 123$ find /home/users -path "*/slynux/*" -print/home/users/list/slynux.txt/home/users/slynux/eg.css 4、选项 -regex 的参数和 -path 的类似，只不过 -regex 是基于正则表达式来匹配文件路径的。 12345678$ lsnew.PY next.jpg test.py$ find . -regex ".*\(\.py\|\.sh\)$"./test.py# 类似地， -iregex可以让正则表达式忽略大小写。例如：$ find . -iregex ".*\(\.py\|\.sh\)$"./test.py./new.PY 5、find也可以用“!”否定参数的含义。例如： 1234567$ lslist.txt new.PY new.txt next.jpg test.py$ find . ! -name "*.txt" -print../next.jpg./test.py./new.PY 6、基于目录深度的搜索 123456# 深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度# 下列命令将find命令向下的最大深度限制为1:$ find . -maxdepth 1 -name "f*" -print# 打印出深度距离当前目录至少两个子目录的所有文件:$ find . -mindepth 2 -name "f*" -print 注：-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 根据文件类型搜索 7、根据文件类型搜索 -type 可以对文件搜索进行过滤 文件类型 类型参数 普通文件 f 符号链接 l 目录 d 字符设备 c 块设备 b 套接字 s FIFO p 8、根据文件时间进行搜索 访问时间（-atime）：用户最近一次访问文件的时间。 修改时间（-mtime）：文件内容最后一次被修改的时间。 变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。 -atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 12345678# 打印出在最近7天内被访问过的所有文件：$ find . -type f -atime -7 -print# 打印出恰好在7天前被访问过的所有文件：$ find . -type f -atime 7 -print# 打印出访问时间超过7天的所有文件：$ find . -type f -atime +7 -print -atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： -amin（访问时间） -mmin（修改时间） -cmin（变化时间） 使用 -newer ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 12# 找出比file.txt修改时间更近的所有文件：$ find . -type f -newer file.txt -print 9、基于文件大小的搜索 12345678$ find . -type f -size +2k# 大于2KB的文件$ find . -type f -size -2k# 小于2KB的文件$ find . -type f -size 2k# 大小等于2KB的文件 b —— 块（512字节） c —— 字节 w —— 字（2字节） k —— 1024字节 M —— 1024k字节 G —— 1024M字节 10、删除匹配的文件 -delete 可以用来删除find查找到的匹配文件。 12# 删除当前目录下所有的 .swp文件：$ find . -type f -name "*.swp" -delete 11、基于文件权限和所有权的匹配 12$ find . -type f -perm 644 -print# 打印出权限为644的文件 -perm指明find应该只匹配具有特定权限值的文件。 12、利用find执行命令或动作 find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 123$ find . -type f -user root -exec chown slynux &#123;&#125; \;# &#123;&#125;是一个与 -exec选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。 -exec 结合多个命令 : 我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本： 1-exec ./commands.sh &#123;&#125; \; 13、让find跳过特定的目录 123$ find devel/source_path \( -name ".git" -prune \) -o \( -type f -print \)# 以上命令打印出不包括在.git目录中的所有文件的名称（路径）。 \( -name &quot;.git&quot; -prune \) 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而\( -type f -print \) 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 2.3 玩转xargsxargs 擅长将标准输入数据转换成命令行参数。 xargs 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 2.3.1 将多行输入转换成单行输出只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 123456$ cat example.txt # 样例文件1 2 3 4 5 67 8 9 1011 12$ cat example.txt | xargs1 2 3 4 5 6 7 8 9 10 11 12 2.3.2 将单行输入转换成多行输出指定每行最大的参数数量 n，我们可以将任何来自stdin的文本划分成多行，每行 n 个参数。 12345$ cat example.txt | xargs -n 31 2 34 5 67 8 910 11 12 2.3.3 定制定界符用 -d 选项为输入指定一个定制的定界符： 123456$ echo "splitXsplitXsplitXsplit" | xargs -d Xsplit split split split$ echo "splitXsplitXsplitXsplit" | xargs -d X -n 2split splitsplit split 在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 2.3.4 读取stdin，将格式化参数传递给命令-I 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 -I 与 xargs 结合使用，对于每一个参数，命令都会被执行一次。 12345678$ cat args.txtarg1arg2arg3$ cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l-p arg1 -l #-p arg2 -l #-p arg3 -l # -I {} 指定了替换字符串。对于每一个命令参数，字符串 {} 都会被从stdin读取到的参数替换掉。 使用 -I 的时候，命令以循环的方式执行。 xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： 1$ find . -type f -name "*.txt" -print | xargs rm -f 这样做很危险。 有时可能会删除不必要删除的文件。 只要我们把 find 的输出作为 xargs 的输入，就必须将 -print0 与 find 结合使用，以字符null（&#39;\0&#39;）来分隔输出。 12345$ find . -type f -name "*.txt" -print0 | xargs -0 rm -f# xargs -0将\0作为输入定界符。$ find source_code_dir_path -type f -name "*.c" -print0 | xargs -0 wc -l# 统计源代码目录中所有C程序文件的行数 2.4 校验和与核实校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 123456789101112$ md5sum filename68b329da9893e34099c7d8ad5cb9c940 filename$ md5sum filename &gt; file_sum.md5$ md5sum file1 file2 file3 ..$ md5sum -c file_sum.md5# 这个命令会输出校验和是否匹配的消息# 如果需要用所有的.md5信息来检查所有的文件，可以使用：$ md5sum -c *.md5 计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 对目录进行校验： 123456789$ md5deep -rl directory_path &gt; directory.md5# -r使用递归的方式# -l使用相对路径。默认情况下， md5deep会输出文件的绝对路径# 或者也可以结合find来递归计算校验和：$ find directory_path -type f -print0 | xargs -0 md5sum &gt;&gt; directory.md5# 用下面的命令进行核实：$ md5sum -c directory.md5 2.4.1 加密工具与散列crypt、 gpg、 base64、 md5sum、 sha1sum 以及 openssl 的用法。 1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 1234567$ crypt &lt;input_file &gt;output_fileEnter passphrase:# 它会要求输入一个口令。我们也可以通过命令行参数来提供口令。$ crypt PASSPHRASE &lt;input_file &gt;encrypted_file# 如果需要解密文件，可以使用：$ crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file 2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 12345# 用gpg加密文件：$ gpg -c filename# 该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：$ gpg filename.gpg# 该命令读取口令，然后对文件进行解密。 3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码/解码Base64字符串。要将文件编码为Base64格式，可以使用： 123456789$ base64 filename &gt; outputfile# 或者$ cat file | base64 &gt; outputfile# base64可以从stdin中进行读取。# 解码Base64数据：$ base64 -d file &gt; outputfile# 或者$ cat base64_file | base64 -d &gt; outputfile 4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： 1234$ md5sum file8503063d5488c3080d4800ff50850dc9 file$ sha1sum file1ba02b66e2e557fede8f61b7df282cd0a27b816b file 这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 5）openssl 用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 123$ opensslpasswd -1 -salt SALT_STRING PASSWORD$1$SALT_STRING$323VkWkSLHuhbt1zkSsUG.# 将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。 2.5 排序、唯一与重复1234567891011121314151617# 对一组文件进行排序：$ sort file1.txt file2.txt &gt; sorted.txt# 按照数字顺序进行排序：$ sort -n file.txt# 按照逆序进行排序：$ sort -r file.txt# 按照月份进行排序（依照一月，二月，三月……）：$ sort -M months.txt# 合并两个已排序过的文件：$ sort -m sorted1 sorted2# 找出已排序文件中不重复的行：$ sort file1.txt file2.txt | uniq 检查文件是否已经排序过： 12345678#!/bin/bash#功能描述：排序sort -C filename ;if [ $? -eq 0 ]; then echo Sorted;else echo Unsorted;fi -k 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 -r 告诉sort命令按照逆序进行排序。例如： 12345678910111213# 依据第1列，以逆序形式排序$ sort -nrk 1 data.txt4 linux 10003 bsd 10002 winxp 40001 mac 2000# -nr表明按照数字，采用逆序形式排序# 依据第2列进行排序$ sort -k 2 data.txt3 bsd 10004 linux 10001 mac 20002 winxp 4000 有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用： 12$ sort -bd unsorted.txt# 选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。 sort选项： 1234567891011121314151617181920212223-b：忽略每行前面开始出的空格字符；-c：检查文件是否已经按照顺序排序； -d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； -f：排序时，将小写字母视为大写字母； -i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；-m：将几个排序号的文件进行合并； -M：将前面3个字母依照月份的缩写进行排序； -n：依照数值的大小排序； -o&lt;输出文件&gt;：将排序后的结果存入制定的文件； -r：以相反的顺序来排序； -t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； +&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 uniq选项： 1234567891011-c或——count：在每列旁边显示该行重复出现的次数； -d或--repeated：仅显示重复出现的行列； -f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； -s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； -u或——unique：仅显示出一次的行列； -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。 wc选项： 12345678910111213-c或--bytes或——chars：只显示Bytes数； # 统计字符数-l或——lines：只显示列数； # 统计行数-w或——words：只显示字数。 # 统计单词数# 当不使用任何选项执行wc时，它会分别打印出文件的行数、单词数和字符数：$ wc file1435 15763 112200# 使用-L选项打印出文件中最长一行的长度：$ wc file -L205 2.6 临时文件命名与随机数123456789101112131415161718# 创建临时文件：$ filename=`mktemp`$ echo $filename/tmp/tmp.8xvhkjF5fH# 创建临时目录：$ dirname=`mktemp -d`$ echo $dirnametmp.NI8xzW7VRX# 如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：$ tmpfile=`mktemp -u`$ echo $tmpfile/tmp/tmp.RsGmilRpcT# 根据模板创建临时文件名：$mktemp test.XXXtest.2tc 如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 2.7 split 分割文件和数据1234# 将文件分割成多个大小为10KB的文件$ split -b 10k data.file$ lsdata.file xaa xab xac xad xae xaf xag xah xai xaj 上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： 123$ split -b 10k data.file -d -a 4$ lsdata.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079 除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 12345678910# 为分割后的文件指定文件名前缀 $ split -b 10k data.file -d -a 4 split_file$ lsdata.file split_file0002 split_file0005 split_file0008 strtok.csplit_file0000 split_file0003 split_file0006 split_file0009split_file0001 split_file0004 split_file0007# 如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：$ split -l 10 data.file# 分割成多个文件，每个文件包含10行 csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 12345678910111213141516171819$ cat server.logSERVER-1[connection] 192.168.0.1 success[connection] 192.168.0.2 failed[disconnect] 192.168.0.3 pending[connection] 192.168.0.4 successSERVER-2[connection] 192.168.0.1 failed[connection] 192.168.0.2 failed[disconnect] 192.168.0.3 success[connection] 192.168.0.4 failedSERVER-3[connection] 192.168.0.1 pending[connection] 192.168.0.2 pending[disconnect] 192.168.0.3 pending[connection] 192.168.0.4 failed$ csplit server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b "%02d.log" ; rm server00.log$ lsserver01.log server02.log server03.log server.log 有关这个命令的详细说明如下。 /SERVER/ 用来匹配某一行，分割过程即从此处开始。 /[REGEX]/ 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 {*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 -s 使命令进入静默模式，不打印其他信息。 -n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 -f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 -b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log。 因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 2.7.1 根据扩展名切分文件名$、借助 % 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 12345file_jpg="sample.jpg"name=$&#123;file_jpg%.*&#125;echo File name is: $name输出结果：File name is: sample 将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 1234extension=$&#123;file_jpg#*.&#125;echo Extension is: jpg输出结果：Extension is: jpg ${VAR%.*} 的含义如下所述： 从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 给VAR赋值， VAR=sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。 %属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 ${VAR#*.} 的含义如下所述：从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配符从左向右进行匹配。和 %% 类似， #也有一个相对应的贪婪操作符 ##。 ##从左向右进行贪婪匹配，并从指定变量中删除匹配结果。 这里有个能够提取域名不同部分的实用案例。假定 URL=&quot;www.google.com&quot;： 12345678$ echo $&#123;URL%.*&#125; # 移除.*所匹配的最右边的内容www.google$ echo $&#123;URL%%.*&#125; # 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）www$ echo $&#123;URL#*.&#125; # 移除*.所匹配的最左边的内容google.com$ echo $&#123;URL##*.&#125; # 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）com 2.8 批量重命名和移动123456789101112131415# 将 *.JPG更名为 *.jpg：$ rename *.JPG *.jpg# 将文件名中的空格替换成字符“_”：$ rename 's/ /_/g' *# 转换文件名的大小写：$ rename 'y/A-Z/a-z/' *$ rename 'y/a-z/A-Z/' *# 将所有的 .mp3文件移入给定的目录：$ find path -type f -name "*.mp3" -exec mv &#123;&#125; target_dir \;# 将所有文件名中的空格替换为字符“_”：$ find path -type f -exec rename 's/ /_/g' &#123;&#125; \; 3 以文件之名3.1 生成任意大小的文件1$ dd if=/dev/zero of=junk.data bs=1M count=1 该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。 使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of=。 单元大小 代码 字节（1B） c 字（2B） w 块（512B） b 千字节（1024B） k 兆字节（1024KB） M 吉字节（1024MB） G ls -lS 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。 3.2 文件权限、所有权和粘滞位用命令ls -l可以列出文件的权限： 123-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.pydrwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl -—— 普通文件。 d —— 目录。 c —— 字符设备。 b —— 块设备。 l —— 符号链接。 s —— 套接字。 p —— 管道。 123456789101112# 更改所有权$ chown user.group filename# 设置粘滞位# 要设置粘滞位，利用chmod将 +t应用于目录：$ chmod a+t directory_name# 以递归的方式设置权限$ chmod 777 . -R# 以递归的方式设置所有权$ chown user.group . -R 3.3 创建不可修改的文件chattr能够将文件设置为不可修改。 12345# 使用下列命令将一个文件设置为不可修改：$ chattr +i file# 如果需要使文件恢复可写状态，移除不可修改属性即可：$ chattr -i file 3.4 查找符号链接及其指向目标12345678910111213141516171819# 创建符号链接：$ ln -s target symbolic_link_name例如：$ ln -l -s /var/www/ ~/web#这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。# 使用下面的命令来验证是否创建链接：$ ls -l weblrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www# 打印出当前目录下的符号链接：$ ls -l | grep "^l"# 使用find打印当前目录以及子目录下的符号链接：$ find . -type l -print# 使用readlink打印出符号链接所指向的目标路径：$ readlink web/var/www 3.5 列举文件类型统计信息12345678# 用下面的命令打印文件类型信息：$ file filename$ file /etc/passwd/etc/passwd: ASCII text# 打印不包括文件名在内的文件类型信息：$ file -b filenameASCII text 3.6 使用环回文件1234567891011121314151617181920212223242526# 下面的命令可以创建一个1GB大小的文件：$ dd if=/dev/zero of=loobackfile.img bs=1G count=11024+0 records in1024+0 records out1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s# 你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。# 用mkfs命令将1GB的文件格式化成ext4文件系统：$ mkfs.ext4 loopbackfile.img# 使用下面的命令检查文件系统：$ file loobackfile.imgloobackfile.img: Linux rev 1.0 ext4 filesystem data,UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)# 现在就可以挂载环回文件了：$ mkdir /mnt/loopback$ mount -o loop loopbackfile.img /mnt/loopback# -o loop用来挂载环回文件系统。# 我们也可以手动来操作：$ losetup /dev/loop1 loopbackfile.img$ mount /dev/loop1 /mnt/loopback# 使用下面的方法进行卸载（umount）：$ umount mount_point 3.7 生成 ISO 文件及混合型 ISO123456789#用下面的命令从/dev/cdrom创建一个ISO镜像：$ cat /dev/cdrom &gt; image.iso#尽管可以奏效。但创建ISO镜像最好的方法还是使用dd工具：$ dd if=/dev/cdrom of=image.iso# mkisofs命令用于创建ISO文件系统。$ mkisofs -V "Label" -o image.iso source_dir/# 选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。 3.8 diff命令12345678910111213141516171819202122232425262728293031323334- # 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。-a或--text # diff预设只会逐行比较文本文件。-b或--ignore-space-change # 不检查空格字符的不同。-B或--ignore-blank-lines # 不检查空白行。-c # 显示全部内文，并标出不同之处。-C或--context # 与执行"-c-"指令相同。-d或--minimal # 使用不同的演算法，以较小的单位来做比较。-D或ifdef # 此参数的输出格式可用于前置处理器巨集。-e或--ed # 此参数的输出格式可用于ed的script文件。-f或-forward-ed # 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。-H或--speed-large-files # 比较大文件时，可加快速度。-l或--ignore-matching-lines # 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。-i或--ignore-case # 不检查大小写的不同。-l或--paginate # 将结果交由pr程序来分页。-n或--rcs # 将比较结果以RCS的格式来显示。-N或--new-file # 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。-p # 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。-P或--unidirectional-new-file # 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。-q或--brief # 仅显示有无差异，不显示详细的信息。-r或--recursive # 比较子目录中的文件。-s或--report-identical-files # 若没有发现任何差异，仍然显示信息。-S或--starting-file # 在比较目录时，从指定的文件开始比较。-t或--expand-tabs # 在输出时，将tab字符展开。-T或--initial-tab # 在每行前面加上tab字符以便对齐。-u,-U或--unified= # 以合并的方式来显示文件内容的不同。-v或--version # 显示版本信息。-w或--ignore-all-space # 忽略全部的空格字符。-W或--width # 在使用-y参数时，指定栏宽。-x或--exclude # 不比较选项中所指定的文件或目录。-X或--exclude-from # 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。-y或--side-by-side # 以并列的方式显示文件的异同之处。--help # 显示帮助。--left-column # 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。--suppress-common-lines # 在使用-y参数时，仅显示不同之处。 生成目录的差异信息 ： 1$ diff -Naur directory1 directory2 -N：将所有缺失的文件视为空文件。 -a：将所有文件视为文本文件。 -u：生成一体化输出。 -r：遍历目录下的所有文件。 12345678910111213# 生成patch文件$ diff -u version1.txt version2.txt &gt; version.patch# 用下列命令来进行修补：$ patch -p1 version1.txt &lt; version.patchpatching file version1.txt# version1.txt的内容现在和verson2.txt的内容一模一样。# 下面的命令可以撤销做出的修改：$ patch -p1 version1.txt &lt; version.patchpatching file version1.txtReversed (or previously applied) patch detected! Assume -R? [n] y# 修改被撤销 3.9 more、less、head与tail命令3.9.1 more文件内容输出查看工具123456789101112$ more [参数选项] [文件] # 参数如下： +num # 从第num行开始显示； -num # 定义屏幕大小，为num行； +/pattern # 从pattern 前两行开始显示； -c # 从顶部清屏然后显示； -d # 提示Press space to continue, 'q' to quit.（按空格键继续，按q键退出），禁用响铃功能； -l # 忽略Ctrl+l （换页）字符； -p # 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； -s # 把连续的多个空行显示为一行； -u # 把文件内容中的下划线去掉退出more的动作指令是q 举例： 1234567891011# 显示提示，并从终端或控制台顶部显示；$ more -dc /etc/profile # 从profile的第4行开始显示；$ more +4 /etc/profile # 每屏显示4行；$ more -4 /etc/profile # 从profile中的第一个MAIL单词的前两行开始显示；$ more +/MAIL /etc/profile more 的动作指令： 123456789Enter # 向下n行，需要定义，默认为1行； Ctrl+f # 向下滚动一屏； 空格键 # 向下滚动一屏； Ctrl+b # 返回上一屏； = # 输出当前行的行号； :f # 输出文件名和当前行的行号； v # 调用vi编辑器； ! 命令 # 调用Shell，并执行命令； q # 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的； 其它命令通过管道和more结合的运用例子： 1$ ls -l /etc |more 3.9.2 less查看文件内容工具12345678910-c # 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； -f # 强制打开文件，二进制文件显示时，不提示警告； -i # 搜索时忽略大小写；除非搜索串中包含大写字母； -I # 搜索时忽略大小写，除非搜索串中包含小写字母； -m # 显示读取文件的百分比； -M # 显法读取文件的百分比、行号及总行数； -N # 在每行前输出行号； -p # pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile -s # 把连续多个空白行作为一个空白行显示； -Q # 在终端下不响铃； less的动作命令： 123456789101112131415回车键 # 向下移动一行； y # 向上移动一行； 空格键 # 向下滚动一屏； b # 向上滚动一屏； d # 向下滚动半屏； h # less的帮助； u # 向上洋动半屏； w # 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； g # 跳到第一行； G # 跳到最后一行； p # n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； /pattern # 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； v # 调用vi编辑器； q # 退出less !command # 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件； 3.9.3 headhead 是显示一个文件的内容的前多少行： 1$ head -n 10 /etc/profile 3.9.4 tailtail 是显示一个文件的内容的最后多少行： 1$ tail -n 5 /etc/profile 3.10 getopts 参数解析3.10.1 getopts（shell内置命令）1234$ type getoptgetopt 是 /usr/bin/getopt$ type getopts getopts 是 shell 内建 getopts不能直接处理长的选项（如：–prefix=/home等） 关于getopts的使用方法，可以man bash 搜索getopts。 getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 $OPTARG中。提供getopts的shell内置了 $OPTARG 这个变变，getopts修改了这个变量。 这里变量 $OPTARG 存储相应选项的参数，而 $OPTIND 总是存储原始 $* 中下一个要处理的元素位置。while getopts &quot;:a:bc&quot; opt #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数 getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true/false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。 两个特殊变量： 12$OPTIND # 特殊变量，option index，会逐个递增, 初始值为1$OPTARG # 特殊变量，option argument，不同情况下有不同的值 例子： 1234567891011121314151617echo $*while getopts ":a:bc" optdo case $opt in a ) echo $OPTARG echo $OPTIND;; b ) echo "b $OPTIND";; c ) echo "c $OPTIND";; ? ) echo "error" exit 1;; esacdoneecho $OPTINDshift $(($OPTIND - 1))#通过shift $(($OPTIND - 1))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。echo $0echo $* 12345678$ ./getopts.sh -a 11 -b -c-a 11 -b -c113b 4c 55./getopts.sh 3.10.2 getopt（一个外部工具）具体用用法可以 man getopt -o 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 -carg 而不能是 -c arg。 --long 表示长选项 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/bash# A small example program for using the new getopt(1) program.# This program will only work with bash(1)# An similar program using the tcsh(1) script. language can be found# as parse.tcsh# Example input and output (from the bash prompt):# ./parse.bash -a par1 'another arg' --c-long 'wow!*\?' -cmore -b " very long "# Option a# Option c, no argument# Option c, argument `more'# Option b, argument ` very long '# Remaining arguments:# --&gt; `par1'# --&gt; `another arg'# --&gt; `wow!*\?'# Note that we use `"$@"' to let each command-line parameter expand to a# separate word. The quotes around `$@' are essential!# We need TEMP as the `eval set --' would nuke the return value of getopt.#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项#如-carg 而不能是-c arg#--long表示长选项#"$@"在上面解释过# -n:出错时的信息# -- ：举一个例子比较好理解：#我们要创建一个名字为 "-f"的目录你会怎么办？# mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用# mkdir -- -f 这样-f就不会被作为选项。TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \ -n 'example.bash' -- "$@"`if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi# Note the quotes around `$TEMP': they are essential!#set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了eval set -- "$TEMP"#经过getopt的处理，下面处理具体选项。while true ; do case "$1" in -a|--a-long) echo "Option a" ; shift ;; -b|--b-long) echo "Option b, argument \`$2'" ; shift 2 ;; -c|--c-long) # c has an optional argument. As we are in quoted mode, # an empty parameter will be generated if its optional # argument is not found. case "$2" in "") echo "Option c, no argument"; shift 2 ;; *) echo "Option c, argument \`$2'" ; shift 2 ;; esac ;; --) shift ; break ;; *) echo "Internal error!" ; exit 1 ;; esacdoneecho "Remaining arguments:"for arg do echo '--&gt; '"\`$arg'" ;done 123456$ ./getopt.sh --b-long abc -a -c33 remainOption b, argument `abc'Option aOption c, argument `33'Remaining arguments:--&gt; `remain' 3.11 只列出目录的各种方法123456789101112# 使用ls –d：$ ls -d */# 使用grep结合ls –F：$ ls -F | grep "/$"# 当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。# 使用grep结合ls –l：$ ls -l | grep "^d"# 使用find：$ find . -type d -maxdepth 1 -print 3.12 使用pushd和popd进行快速定位使用pushd和popd时，可以无视cd命令。 123456789101112131415161718# 压入并切换路径：$ pushd /var/www# 再压入下一个目录路径：$ pushd /usr/src# 用下面的命令查看栈内容：$ dirs/usr/src /var/www ~ /usr/share /etc0 1 2 3 4# 当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：$ pushd +3# 这条命令会将栈进行翻转并切换到目录 /use/share。# 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：$ popd# 用popd +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。 3.13 tree打印目录树1234567891011# 重点标记出匹配某种样式的文件：$ tree PATH -P "*.sh" # 用一个目录路径代替PATH|-- home| |-- packtpub| | `-- automate.sh# 重点标记出除符合某种样式之外的那些文件：$ tree path -I PATTERN# 使用 -h选项同时打印出文件和目录的大小：$ tree -h 4 让文件飞4.1 正则表达式 正则表达式 描述 示例 ^ 行起始标记 ^tux 匹配以tux起始的行 $ 行尾标记 tux$ 匹配以tux结尾的行 . 匹配任意一个字符 Hack.匹配Hackl和Hacki，它只能匹配单个字符 [ ] 匹配包含在 [字符] 之中的任意一个字符 coo[kl] 匹配cook或cool [ ^ ] 匹配除 [^字符] 之外的任意一个字符 9[^01]匹配92、 93，但是不匹配91或90 [ - ] 匹配 [ ] 中指定范围内的任意一个字符 [1-5] 匹配从1～5的任意一个数字 ? 匹配之前的项1次或0次 colou?r 匹配color或colour，但是不能匹配colouur + 匹配之前的项1次或多次 Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno- * 匹配之前的项0次或多次 co*l 匹配cl、 col、 coool等 ( ) 创建一个用于匹配的子串 ma(tri)?x 匹配max或maxtrix {n} 匹配之前的项n次 [0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为[0-9][0-9][0-9] {n, } 之前的项至少需要匹配n次 [0-9]{2,} 匹配任意一个两位或更多位的数字 {n, m} 指定之前的项所必需匹配的最小次数和最大次数 [0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字 | 交替——匹配 | 两边的任意一项 Oct (1st | 2nd) 匹配Oct 1st或Oct 2nd \ 转义符可以将上面介绍的特殊字符进行转义 a\.b 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义 正则表达式 描述 [:alnum:] 所有的字母和数字 [:alpha:] 所有字母 [:blank:] 水平制表符，空白等 [:cntrl:] 所有控制字符 [:digit:] 所有的数字 [:graph:] 所有可打印字符，不包括空格 [:lower:] 所有的小写字符 [:print:] 所有可打印字符，包括空格 [:punct:] 所有的标点字符 [:space:] 所有的横向或纵向的空白 [:upper:] 所有大写字母 4.2 grep命令1234567891011121314151617181920212223242526-a # 不要忽略二进制的数据。-A&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之后的内容。-b # 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。-B&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前的内容。-c # 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; # 指定字符串做为查找文件内容的范本样式。-E # 将范本样式为延伸的普通表示法来使用。-f&lt;范本文件&gt; # 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。-F # 将范本样式视为固定字符串的列表。-G # 将范本样式视为普通的表示法来使用。-h # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H # 在显示符合范本样式的那一列之前，表示该列所属的文件名称。-i # 忽略字符大小写的差别。-l # 列出文件内容符合指定的范本样式的文件名称。-L # 列出文件内容不符合指定的范本样式的文件名称。-n # 在显示符合范本样式的那一列之前，标示出该列的列数编号。-q # 不显示任何信息。-r # 此参数的效果和指定“-d recurse”参数相同。-s # 不显示错误信息。-v # 反转查找。-V # 显示版本信息。-w # 只显示全字符合的列。-x # 只显示全列符合的列。-o # 只输出文件中匹配到的部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 单个grep命令也可以对多个文件进行搜索：$ grep "match_text" file1 file2 file3 ...# grep -E选项——这意味着使用扩展（extended）正则表达式：$ grep -E "[a-z]+" filename# 或者$ egrep "[a-z]+" filename# 只输出文件中匹配到的文本部分，可以使用选项 -o：$ echo this is a line. | egrep -o "[a-z]+\."line.# 要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：$ grep -v match_pattern file# 统计文件或文本中包含匹配字符串的行数：$ grep -c "text" filename10# 需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：$ echo -e "1 2 3 4\nhello\n5 6" | egrep -c "[0-9]"2# 要文件中统计匹配项的数量，可以使用下面的技巧：$ echo -e "1 2 3 4\nhello\n5 6" | egrep -o "[0-9]" | wc -l6# 打印模式匹配所位于的字符或字节偏移：$ echo gnu is not unix | grep -b -o "not"7:not# 选项 -b总是和 -o配合使用。# 搜索多个文件并找出匹配文本位于哪一个文件中：$ grep -l linux sample1.txt sample2.txtsample1.txtsample2.txt# 和-l相反的选项是-L，它会返回一个不匹配的文件列表。# grep的选项-R和-r功能一样。# 忽略样式中的大小写$ echo hello world | grep -i "HELLO"hello# grep匹配多个样式$ echo this is a line of text | grep -e "this" -e "line" -othisline# 在grep搜索中指定或排除文件$ grep "main()" . -r --include *.&#123;c,cpp&#125; # 目录中递归搜索所有的 .c和 .cpp文件# 如果需要排除目录，可以使用 --exclude-dir选项。# 如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。# 使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。# grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。$ grep "test" file* -lZ | xargs -0 rm# -Z通常和 -l结合使用。# grep的静默输出# grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。# 要打印匹配某个结果之后的3行，使用 -A选项：$ seq 10 | grep 5 -A 35678# 要打印匹配某个结果之前的3行，使用 -B选项：$ seq 10 | grep 5 -B 32345# 要打印匹配某个结果之前以及之后的3行，使用-C选项：$ seq 10 | grep 5 -C 32345678# 如果有多个匹配，那么使用--作为各部分之间的定界符：$ echo -e "a\nb\nc\na\nb\nc" | grep a -A 1ab--ab 4.3 cut 按列切分文件1234# 显示第2列和第3列：$ cut -f 2,3 filename# 记法 范围 N - 从第N个字节，字符或字段到行尾 N - M 从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段 - M 第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段 结合下列选项将字段指定为某个范围内的字节或字符 ： -b ：表示字节 -c ：表示字符 -f ：用于定义字段 123456789101112131415161718$ cat range_fields.txtabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy# 打印第1个到第5个字符：$ cut -c1-5 range_fields.txtabcdeabcdeabcdeabcde# 打印前2个字符：$ cut range_fields.txt -c -2abababab 4.4 sed 进行文本替换选项： 12345-e &lt;script&gt; # 以选项中指定的script来处理输入的文本文件-f &lt;script&gt; # 以选项中指定的script文件来处理输入的文本文件-h # 显示帮助-n # 仅显示script处理后的结果-V # 显示版本信息 命令： 1234567891011121314151617181920212223a\ # 在当前行下面插入文本。i\ # 在当前行上面插入文本。c\ # 把选定的行改为新的文本。 d # 删除，删除选择的行。 D # 删除模板块的第一行。s # 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 H # 追加模板块的内容到内存中的缓冲区。 g # 获得内存缓冲区的内容，并替代当前模板块中的文本。 G # 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l # 列表不能打印字符的清单。 n # 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N # 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p # 打印模板块的行。 P(大写) 打印模板块的第一行。 q # 退出Sed。 b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 r file # 从file中读行。 t label # if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label # 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。w file # 写并追加模板块到file末尾。 W file # 写并追加模板块的第一行到file末尾。 ! # 表示后面的命令对所有没有被选定的行发生作用。 = # 打印当前行号码。 # 把注释扩展到下一个换行符以前。 sed 替换标记： 1234567g # 表示行内全面替换。p # 表示打印行。 w # 表示把行写入一个文件。 x # 表示互换模板块中的文本和缓冲区中的文本。 y # 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \1 # 子串匹配标记 &amp; # 已匹配字符串标记 sed 元字符集： 12345678910111213^ # 匹配行开始，如：/^sed/匹配所有以sed开头的行。$ # 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 . # 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 * # 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 [] # 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 [^] # 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。\(..\) # 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 &amp; # 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 \&lt; # 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。\&gt; # 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。x\&#123;m\&#125; # 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 x\&#123;m,\&#125; # 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 x\&#123;m,n\&#125; # 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。 123456789101112131415161718192021222324252627282930313233343536373839# sed可以替换给定文本中的字符串。$ sed 's/pattern/replace_string/' file# 如果需要在替换的同时保存更改，可以使用-i选项$ sed -i 's/text/replace/' file# 后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。$ sed 's/pattern/replace_string/g' file$ echo thisthisthisthis | sed 's/this/THIS/2g'thisTHISTHISTHIS$ echo thisthisthisthis | sed 's/this/THIS/3g'thisthisTHISTHIS# 字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：$ sed 's:text:replace:g'$ sed 's|text|replace|g'# 当定界符出现在样式内部时，我们必须用前缀\对它进行转义：$ sed 's|te\|xt|replace|g'# \|是一个出现在样式内部并经过转义的定界符。# 移除空白行$ sed '/^$/d' file# 已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。$ echo this is an example | sed 's/\w\+/[&amp;]/g'[this] [is] [an] [example]# 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。# 组合多个表达式$ sed 'expression' | sed 'expression'# 它等价于$ sed 'expression; expression'# 或者$ sed -e 'expression' -e expression'# 引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。$ text=hello$ echo hello world | sed "s/$text/HELLO/"HELLO world 4.5 awk 进行高级文本处理4.5.1 awk 常用命令选项 -F fs fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令 -m[fr] val 对val值设置内在限制，-mf 选项限制分配给val的最大块数目；-mr 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 4.5.2 awk 脚本基本结构1234$ awk 'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;' file# 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：$ awk 'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;' filename $ awk "BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;" filename 4.5.3 awk 的工作原理1$ awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' 第一步：执行 BEGIN{ commands } 语句块中的语句 第二步：从文件或标准输入(stdin)读取一行，然后执行 pattern{ commands } 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕 第三步：当读至输入流末尾时，执行 END{ commands } 语句块 4.5.4 awk 内置变量（预定义变量）说明： [A][N][P][G]表示第一个支持变量的工具，[A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk 12345678910111213141516171819202122$n # 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 $0 # 这个变量包含执行过程中当前行的文本内容。 [N] ARGC # 命令行参数的数目。 [G] ARGIND # 命令行中当前文件的位置（从0开始算）。 [N] ARGV # 包含命令行参数的数组。 [G] CONVFMT # 数字转换格式（默认值为%.6g）。 [P] ENVIRON # 环境变量关联数组。 [N] ERRNO # 最后一个系统错误的描述。 [G] FIELDWIDTHS # 字段宽度列表（用空格键分隔）。 [A] FILENAME # 当前输入文件的名。 [P] FNR # 同NR，但相对于当前文件。 [A] FS # 字段分隔符（默认是任何空格）。 [G] IGNORECASE # 如果为真，则进行忽略大小写的匹配。 [A] NF # 表示字段数，在执行过程中对应于当前的字段数。 [A] NR # 表示记录数，在执行过程中对应于当前的行号。 [A] OFMT # 数字的输出格式（默认值是%.6g）。 [A] OFS # 输出字段分隔符（默认值是一个空格）。 [A] ORS # 输出记录分隔符（默认值是一个换行符）。 [A] RS # 记录分隔符（默认是一个换行符）。 [N] RSTART # 由match函数所匹配的字符串的第一个位置。 [N] RLENGTH # 由match函数所匹配的字符串的长度。 [N] SUBSEP # 数组下标分隔符（默认值是34）。 1234567891011121314151617181920212223242526272829$ echo -e "line1 f2 f3nline2 f4 f5nline3 f6 f7" | awk '&#123;print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3&#125;' Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5 Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7# 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：$ echo -e "line1 f2 f3n line2 f4 f5" | awk '&#123;print $NF&#125;' f3f5$ echo -e "line1 f2 f3n line2 f4 f5" | awk '&#123;print $(NF-1)&#125;' f2 f4# 打印每一行的第二和第三个字段：$ awk '&#123; print $2,$3 &#125;' filename# 统计文件中的行数：$ awk 'END&#123; print NR &#125;' filename# 一个每一行中第一个字段值累加的例子：$ seq 5 | awk 'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;' 总和： 1+ 2+ 3+ 4+ 5+ 等于 15 4.5.5 将外部变量值传递给awk借助 -v 选项，可以将外部值（并非来自stdin）传递给awk： 12345678910$ VAR=10000 $ echo | awk -v VARIABLE=$VAR '&#123; print VARIABLE &#125;'# 另一种传递外部变量方法：$ var1="aaa" $ var2="bbb" $ echo | awk '&#123; print v1,v2 &#125;' v1=$var1 v2=$var2# 当输入来自于文件时使用：$ awk '&#123; print v1,v2 &#125;' v1=$var1 v2=$var2 filename 4.5.6 awk 运算与判断算数运算符： 运算符 描述 + - 加、减 * / &amp; 乘，除与求余 + - ! 一元加、减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 12$ awk 'BEGIN&#123;a="b";print a++,++a;&#125;' 0 2 **注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 赋值运算符： 运算符 描述 = += -= = /= %= ^= *= 赋值语句 逻辑运算符： 运算符 描述 || 逻辑或 &amp;&amp; 逻辑与 12$ awk 'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'0 1 正则运算符： 运算符 描述 ~ ~! 匹配正则表达式和不匹配正则表达式 12$ awk 'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;' ok 关系运算符： 运算符 描述 &lt; &lt;= &gt; &gt;= != == 关系运算符 12$ awk 'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;' ok **注意：**> < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。 其他运算符： 运算符 描述 $ 字段引用 空格 字符串连接符 ? : C条件表达式 in 数组中是否存在某键值 12345678$ awk 'BEGIN&#123;a="b";print a=="b"?"ok":"err";&#125;' ok $ awk 'BEGIN&#123;a="b";arr[0]="b";arr[1]="c";print (a in arr);&#125;' 0 $ awk 'BEGIN&#123;a="b";arr[0]="b";arr["b"]="c";print (a in arr);&#125;' 1 运算级优先级表： 级别 运算符 说明 1 =, +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, &gt;&gt;= 赋值、运算 2 || 逻辑或 3 &amp;&amp; 逻辑与 4 | 按位或 5 ^ 按位异或 6 &amp; 按位与 7 ==, != 等于、不等于 8 &lt;=, &gt;=, &lt;, &gt; 小于等于、大于等于、小于、大于 9 &lt;&lt;, &gt;&gt; 按位左移，按位右移 10 +, - 加、减 11 *, /, % 乘、除、取模 12 !, ~ 逻辑非、按位取反或补码 13 -, + 正、负 级别越高越优先 4.5.7 awk 高级输入输出读取下一条记录： awk中 next 语句使用：在循环逐行匹配，如果遇到 next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并： 12345678910$ cat text.txt a b c d e $ awk 'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;' text.txt 2 b 4 d 当记录行号除以2余1，就跳过当前行。下面的 print NR,$0 也不会执行。下一行开始，程序有开始判断 NR%2 值。这个时候记录行号是 ：2 ，就会执行下面语句块：&#39;print NR,$0&#39; 分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： 123456789101112131415161718192021$ cat text.txt web01[192.168.2.100] httpd ok tomcat ok sendmail ok web02[192.168.2.101] httpd ok postfix ok web03[192.168.2.102] mysqld ok httpd ok 0 $ awk '/^web/&#123;T=$0;next;&#125;&#123;print T":t"$0;&#125;' test.txt web01[192.168.2.100]: httpd ok web01[192.168.2.100]: tomcat ok web01[192.168.2.100]: sendmail ok web02[192.168.2.101]: httpd ok web02[192.168.2.101]: postfix ok web03[192.168.2.102]: mysqld ok web03[192.168.2.102]: httpd ok 简单地读取一条记录： awk getline 用法：输出重定向需用到 getline函数。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 getline语法：getline var，变量var包含了特定行的内容。 awk getline从整体上来说，用法说明： 当其左右无重定向符 | 或 &lt; 时：getline作用于当前文件，读入当前文件的第一行给其后跟的变量 var 或 $0（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。 当其左右有重定向符 | 或 &lt; 时：getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。 12345678# 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：$ awk 'BEGIN&#123; "date" | getline out; print out &#125;' test# 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：$ awk 'BEGIN&#123; "date" | getline out; split(out,mon); print mon[2] &#125;' test# 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。$ awk 'BEGIN&#123; while( "ls" | getline) print &#125;' 关闭文件： awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。 1close("filename") filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。 输出到一个文件： 123$ echo | awk '&#123;printf("hello word!n") &gt; "datafile"&#125;'或 $ echo | awk '&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;' 4.5.8 设置字段定界符默认的字段定界符是空格，可以使用 `-F "定界符"` 明确指定一个定界符： 123$ awk -F: '&#123; print $NF &#125;' /etc/passwd 或 $ awk 'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;' /etc/passwd 在 BEGIN语句块 中则可以用 OFS=“定界符” 设置输出字段的定界符。 4.5.9 流程控制语句条件判断语句： 123456789101112$ awk 'BEGIN&#123; test=100; if(test&gt;90)&#123; print "very good"; &#125; else if(test&gt;60)&#123; print "good"; &#125; else&#123; print "no pass"; &#125; &#125;' very good 每条命令语句后面可以用 ; 分号结尾。 循环语句： while语句： 12345678910$ awk 'BEGIN&#123; test=100; total=0; while(i&lt;=test)&#123; total+=i; i++; &#125; print total; &#125;' 5050 for循环： 格式1： 12345678910111213$ awk 'BEGIN&#123; for(k in ENVIRON)&#123; print k"="ENVIRON[k]; &#125; &#125;' TERM=linux G_BROKEN_FILENAMES=1 SHLVL=1 pwd=/root/text ... logname=root HOME=/root SSH_CLIENT=192.168.1.21 53087 22 注：ENVIRON是awk常量，是子典型数组。 格式2： 123456789$ awk 'BEGIN&#123; total=0; for(i=0;i&lt;=100;i++)&#123; total+=i; &#125; print total; &#125;' 5050 do循环： 12345678910$ awk 'BEGIN&#123; total=0; i=0; do &#123; total+=i;i++; &#125; while(i&lt;=100) print total; &#125;' 5050 其他语句： break 当 break 语句用于 while 或 for 语句时，导致退出程序循环 continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代 next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程 exit 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行 4.5.10 数组应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 得到数组长度$ awk 'BEGIN&#123;info="it is a test";lens=split(info,tA," ");print length(tA),lens;&#125;' 4 4# length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。# asort对数组进行排序，返回数组长度。$ awk 'BEGIN&#123;info="it is a test";split(info,tA," ");print asort(tA);&#125;' 4# 输出数组内容（无序，有序输出）：$ awk 'BEGIN&#123;info="it is a test";split(info,tA," ");for(k in tA)&#123;print k,tA[k];&#125;&#125;' 4 test 1 it 2 is 3 a # for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。$ awk 'BEGIN&#123;info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;' 1 it 2 is 3 a 4 test# 注意：数组下标是从1开始，与C数组不一样。# 判断键值存在以及删除键值：$ awk 'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";if( "c" in tB)&#123;print "ok";&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;' a a1 b b1# 删除键值： $ awk 'BEGIN&#123;tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB)&#123;print k,tB[k];&#125;&#125;' b b1# 二维、多维数组使用$ awk 'BEGIN&#123; for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; print i,"*",j,"=",tarr[i,j]; &#125; &#125; &#125;' 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 ... 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81# 可以通过array[k,k2]引用获得数组内容。# 另一种方法：$ awk 'BEGIN&#123; for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; &#125; &#125; for(m in tarr)&#123; split(m,tarr2,SUBSEP); print tarr2[1],"*",tarr2[2],"=",tarr[m]; &#125; &#125;' 4.5.11 内置函数awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。 算数函数： 格式 描述 atan2( y, x ) 返回 y/x 的反正切 cos( x ) 返回 x 的余弦；x 是弧度 sin( x ) 返回 x 的正弦；x 是弧度 exp( x ) 返回 x 幂函数 log( x ) 返回 x 的自然对数 sqrt( x ) 返回 x 平方根 int( x ) 返回 x 的截断至整数的值 rand( ) 返回任意数字 n，其中 0 &lt;= n &lt; 1 srand( [expr] ) 将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 12345678910$ awk 'BEGIN&#123;OFMT="%.3f";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;' 0.841 22026.466 2.303 3# 获得随机数：$ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 78 $ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 31 $ awk 'BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;' 41 字符串函数： 格式 描述 gsub( Ere, Repl, [ In ] ) 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量） index( String1, String2 ) 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零） length [(String)] 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量） blength [(String)] 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量） substr( String, M, [ N ] ) 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度 match( String, Ere ) 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一） split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建 tolower( String ) 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义 toupper( String ) 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义 sprintf(Format, Expr, Expr, . . . ) 根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串 注：Ere都可以是正则表达式。 1234567891011121314151617181920212223# gsub,sub使用 $ awk 'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;' this is a test!test!# 查找字符串（index使用） $ awk 'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;' ok# 正则表达式匹配查找(match使用） $ awk 'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;' ok# 截取字符串(substr使用） $ awk 'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;' s is a tes# 字符串分割（split使用） $ awk 'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;' 4 4 test 1 this 2 is 3 a 格式化字符串输出（sprintf使用） 格式化字符串格式： 格式 描述 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 自动选择合适的表示法 12$ awk 'BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);&#125;' 124.11,18446744073709551615,1.2,7C,174 一般函数： 格式 描述 close( Expression ) 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的 system(command ) 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程 Expression | getline [ Variable ] 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] &lt; Expression 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量 12345678910111213141516171819202122# 打开外部文件（close用法） $ awk 'BEGIN&#123;while("cat /etc/passwd"|getline)&#123;print $0;&#125;;close("/etc/passwd");&#125;' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin# 逐行读取外部文件(getline使用方法） $ awk 'BEGIN&#123;while(getline &lt; "/etc/passwd")&#123;print $0;&#125;;close("/etc/passwd");&#125;' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin $ awk 'BEGIN&#123;print "Enter your name:";getline name;print name;&#125;' Enter your name: chengmo chengmo# 调用外部应用程序(system使用方法） $ awk 'BEGIN&#123;b=system("ls -al");print b;&#125;' total 42092 drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . drwxr-xr-x 95 root root 4096 10-08 14:01 .. # b返回值，是执行结果。 时间函数： 格式 描述 函数名 说明 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式 strftime([format [, timestamp]]) 格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. systime() 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 12345678910# 建指定时间(mktime使用） $ awk 'BEGIN&#123;tstamp=mktime("2001 01 01 12 12 12");print strftime("%c",tstamp);&#125;' 2001年01月01日 星期一 12时12分12秒 $ awk 'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=mktime("2001 02 01 0 0 0");print tstamp2-tstamp1;&#125;' 2634468 # 求2个时间段中间时间差，介绍了strftime使用方法 $ awk 'BEGIN&#123;tstamp1=mktime("2001 01 01 12 12 12");tstamp2=systime();print tstamp2-tstamp1;&#125;' 308201392 strftime日期和时间格式说明符 格式 描述 %a 星期几的缩写（Sun） %A 星期几的完整写法（Sunday） %b 月名的缩写（Oct） %B 月名的完整写法（October） %c 本地日期和时间 %d 十进制日期 %D 日期 08/20/99 %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的时间 %I 用十进制表示12小时格式的时间 %j 从1月1日期一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法（AM/PM） %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期（星期天作为一个星期的开始） %w 十进制表示的星期几（星期天是0） %W 十进制表示的一年中的第几个星期（星期一作为一个星期的开始） %x 重新设置本地日期（08/20/99） %X 重新设置本地时间（12 : 00 : 00） %y 两位数字表示的年（99） %Y 当前月份 %Z 时区（PDT） %% 百分号（%） 4.6 find 对目录中的所有文件进行文本替换12345# 将所有.cpp文件中的Copyright替换成Copyleft：$ find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i 's/Copyright/Copyleft/g' &#123;&#125;# 选项-exec实现同样的效果：$ find . -name *.cpp -exec sed -i 's/Copyright/Copyleft/g' \&#123;\&#125; \; 5 一团乱麻5.1 wget命令12345678910111213141516171819202122-a&lt;日志文件&gt;： # 在指定的日志文件中记录资料的执行过程； -A&lt;后缀名&gt;： # 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； -b： # 进行后台的方式运行wget； -B&lt;连接地址&gt;： # 设置参考的连接地址的基地地址； -c： # 继续执行上次终端的任务； -C&lt;标志&gt;： # 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； -d： # 调试模式运行指令； -D&lt;域名列表&gt;： # 设置顺着的域名列表，域名之间用“，”分隔； -e&lt;指令&gt;： # 作为文件“.wgetrc”中的一部分执行指定的指令； -h： # 显示指令帮助信息； -i&lt;文件&gt;： # 从指定文件获取要下载的URL地址； -l&lt;目录列表&gt;： # 设置顺着的目录列表，多个目录用“，”分隔； -L： # 仅顺着关联的连接； -r： # 递归下载方式； -nc： # 文件存在时，下载文件不覆盖原有文件； -nv： # 下载时只显示更新和出错信息，不显示指令的详细执行过程； -q： # 不显示指令执行过程； -nh： # 不查询主机名称； -v： # 显示详细执行过程； -V： # 显示版本信息； --passive-ftp： # 使用被动模式PASV连接FTP服务器； --follow-ftp： # 从HTML文件中下载FTP连接文件。 12345678910111213141516171819202122# 使用wget下载单个文件 $ wget http://www.linuxde.net/testfile.zip# 下载并以不同的文件名保存 $ wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080# wget限速下载 $ wget --limit-rate=300k http://www.linuxde.net/testfile.zip# 使用wget断点续传 $ wget -c http://www.linuxde.net/testfile.zip# 使用wget后台下载 $ wget -b http://www.linuxde.net/testfile.zip Continuing in background, pid 1840. Output will be written to `wget-log'.# 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： $ tail -f wget-log# 伪装代理名称下载 $ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.linuxde.net/testfile.zip# 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。 测试下载链接： 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 1$ wget --spider URL 如果下载链接正确，将会显示: 12345Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 200 OK Length: unspecified [text/html] Remote file exists and could contain further links, but recursion is disabled -- not retrieving. 这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误: 1234$ wget --spider url Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 404 Not Found Remote file does not exist -- broken link!!! 你可以在以下几种情况下使用–spider参数： 定时下载之前进行检查 间隔检测网站是否可用 检查网站页面的死链接 123456789101112131415161718192021222324# 增加重试次数 $ wget --tries=40 URL# 下载多个文件 $ wget -i filelist.txt # 首先，保存一份下载链接文件： $ cat &gt; filelist.txt url1 url2 url3 url4 # 接着使用这个文件和参数-i下载。# 过滤指定格式下载 $ wget --reject=gif ur # 下载一个网站，但你不希望下载图片，可以使用这条命令。# 把下载信息存入日志文件 $ wget -o download.log URL # 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 # 限制总下载文件大小 $ wget -Q5m -i filelist.txt # 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 镜像网站： 1$ wget --mirror -p --convert-links -P ./LOCAL URL 下载整个网站到本地。 –mirror 开户镜像下载 -p 下载所有为了html页面显示正常的文件 –convert-links 下载后，转换成本地的链接 -P ./LOCAL URL 保存所有文件和目录到本地指定目录 下载指定格式文件： 1$ wget -r -A.pdf url 可以在以下情况使用该功能： 下载一个网站的所有图片 下载一个网站的所有视频 下载一个网站的所有PDF文件 FTP下载： 12$ wget ftp-url $ wget --ftp-user=USERNAME --ftp-password=PASSWORD url 可以使用wget来完成ftp链接的下载。 使用wget匿名ftp下载： 1$ wget ftp-url 使用wget用户名和密码认证的ftp下载： 1$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url 5.2 curl 命令常见参数： 12345678910111213141516-A/--user-agent &lt;string&gt; # 设置用户代理发送给服务器-b/--cookie &lt;name=string/file&gt; # cookie字符串或文件读取位置-c/--cookie-jar &lt;file&gt; # 操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt; # 断点续转-D/--dump-header &lt;file&gt; # 把header信息写入到该文件中-e/--referer # 来源网址-f/--fail # 连接失败时不显示http错误-o/--output # 把输出写到该文件中-O/--remote-name # 把输出写到该文件中，保留远程文件的文件名-r/--range &lt;range&gt; # 检索来自HTTP/1.1或FTP服务器字节范围-s/--silent # 静音模式。不输出任何东西-T/--upload-file &lt;file&gt; # 上传文件-u/--user &lt;user[:password]&gt; # 设置服务器的用户和密码-w/--write-out [format] # 什么输出完成后-x/--proxy &lt;host[:port]&gt; # 在给定的端口上使用HTTP代理-#/--progress-bar # 进度条显示当前的传送状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 不显示进度信息使用--silent选项。$ curl URL --silent# 使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：$ curl http://man.linuxde.net/text.iso --silent -O# 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：$ curl http://man.linuxde.net/test.iso -o filename.iso --progress######################################### 100.0%# 断点续传$ curl URL/File -C 偏移量 # 偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： $ curl -C -URL# 使用--referer选项指定参照页字符串： $ curl --referer http://www.google.com http://man.linuxde.net # 用curl设置cookies 使用--cookie "COKKIES"选项来指定cookie，多个cookie使用分号分隔： $ curl http://man.linuxde.net --cookie "user=root;pass=123456" # 将cookie另存为一个文件，使用--cookie-jar选项： $ curl URL --cookie-jar cookie_file # 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：$ curl URL --user-agent "Mozilla/5.0" curl URL -A "Mozilla/5.0" # 其他HTTP头部信息也可以使用curl来发送，使用-H"头部信息" 传递多个头部信息，例如： $ curl -H "Host:man.linuxde.net" -H "accept-language:zh-cn" URL # curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度： $ curl URL --limit-rate 50k # 命令中用k（千字节）和m（兆字节）指定下载速度限制。 # 使用--max-filesize指定可下载的最大文件大小： $ curl URL --max-filesize bytes # 如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。 # 用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： $ curl -u user:pwd http://man.linuxde.net $ curl -u user http://man.linuxde.net # 只打印响应头部信息 通过-I或者-head可以只打印出HTTP头部信息： $ curl -I http://man.linuxde.net HTTP/1.1 200 OK Server: nginx/1.2.5 date: Mon, 10 Dec 2012 09:24:34 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Vary: Accept-Encoding X-Pingback: http://man.linuxde.net/xmlrpc.php 其他参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192-a/--append # 上传文件时，附加到目标文件--anyauth # 可以使用“任何”身份验证方法--basic # 使用HTTP基本验证-B/--use-ascii # 使用ASCII文本传输-d/--data &lt;data&gt; # HTTP POST方式传送数据--data-ascii &lt;data&gt; # 以ascii的方式post数据--data-binary &lt;data&gt; # 以二进制的方式post数据--negotiate # 使用HTTP身份验证--digest # 使用数字身份验证--disable-eprt # 禁止使用EPRT或LPRT--disable-epsv # 禁止使用EPSV--egd-file &lt;file&gt; # 为随机数据(SSL)设置EGD socket路径--tcp-nodelay # 使用TCP_NODELAY选项-E/--cert &lt;cert[:passwd]&gt; # 客户端证书文件和密码 (SSL)--cert-type &lt;type&gt; # 证书文件类型 (DER/PEM/ENG) (SSL)--key &lt;key&gt; # 私钥文件名 (SSL)--key-type &lt;type&gt; # 私钥文件类型 (DER/PEM/ENG) (SSL)--pass &lt;pass&gt; # 私钥密码 (SSL)--engine &lt;eng&gt; # 加密引擎使用 (SSL). "--engine list" for list--cacert &lt;file&gt; # CA证书 (SSL)--capath &lt;directory&gt; # CA目 (made using c_rehash) to verify peer against (SSL)--ciphers &lt;list&gt; # SSL密码--compressed # 要求返回是压缩的形势 (using deflate or gzip)--connect-timeout &lt;seconds&gt; # 设置最大请求时间--create-dirs # 建立本地目录的目录层次结构--crlf # 上传是把LF转变成CRLF--ftp-create-dirs # 如果远程目录不存在，创建远程目录--ftp-method [multicwd/nocwd/singlecwd] # 控制CWD的使用--ftp-pasv # 使用 PASV/EPSV 代替端口--ftp-skip-pasv-ip # 使用PASV的时候,忽略该IP地址--ftp-ssl # 尝试用 SSL/TLS 来进行ftp数据传输--ftp-ssl-reqd # 要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt; # 模拟http表单提交数据-form-string &lt;name=string&gt; # 模拟http表单提交数据-g/--globoff # 禁用网址序列和范围使用&#123;&#125;和[]-G/--get # 以get的方式来发送数据-h/--help # 帮助-H/--header &lt;line&gt; # 自定义头信息传递给服务器--ignore-content-length # 忽略的HTTP头信息的长度-i/--include # 输出时包括protocol头信息-I/--head # 只显示文档信息-j/--junk-session-cookies # 读取文件时忽略session cookie--interface &lt;interface&gt; # 使用指定网络接口/地址--krb4 &lt;level&gt; # 使用指定安全级别的krb4-k/--insecure # 允许不使用证书到SSL站点-K/--config # 指定的配置文件读取-l/--list-only # 列出ftp目录下的文件名称--limit-rate &lt;rate&gt; # 设置传输速度--local-port&lt;NUM&gt; # 强制使用本地端口号-m/--max-time &lt;seconds&gt; # 设置最大传输时间--max-redirs &lt;num&gt; # 设置最大读取的目录数--max-filesize &lt;bytes&gt; # 设置最大下载的文件总量-M/--manual # 显示全手动-n/--netrc # 从netrc文件中读取用户名和密码--netrc-optional # 使用 .netrc 或者 URL来覆盖-n--ntlm # 使用 HTTP NTLM 身份验证-N/--no-buffer # 禁用缓冲输出-p/--proxytunnel # 使用HTTP代理--proxy-anyauth # 选择任一代理身份验证方法--proxy-basic # 在代理上使用基本身份验证--proxy-digest # 在代理上使用数字身份验证--proxy-ntlm # 在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt; # 使用端口地址，而不是使用PASV-Q/--quote &lt;cmd&gt; # 文件传输前，发送命令到服务器--range-file # 读取（SSL）的随机文件-R/--remote-time # 在本地生成文件时，保留远程文件时间--retry &lt;num&gt; # 传输出现问题时，重试的次数--retry-delay &lt;seconds&gt; # 传输出现问题时，设置重试间隔时间--retry-max-time &lt;seconds&gt; # 传输出现问题时，设置最大重试时间-S/--show-error # 显示错误--socks4 &lt;host[:port]&gt; # 用socks4代理给定主机和端口--socks5 &lt;host[:port]&gt; # 用socks5代理给定主机和端口-t/--telnet-option &lt;OPT=val&gt; # Telnet选项设置--trace &lt;file&gt; # 对指定文件进行debug--trace-ascii &lt;file&gt; # Like --跟踪但没有hex输出--trace-time # 跟踪/详细输出时，添加时间戳--url &lt;URL&gt; # Spet URL to work with-U/--proxy-user &lt;user[:password]&gt; # 设置代理用户名和密码-V/--version # 显示版本信息-X/--request &lt;command&gt; # 指定什么命令-y/--speed-time # 放弃限速所要的时间。默认为30-Y/--speed-limit # 停止传输速度的限制，速度时间'秒-z/--time-cond # 传送时间设置-0/--http1.0 # 使用HTTP 1.0-1/--tlsv1 # 使用TLSv1（SSL）-2/--sslv2 # 使用SSLv2的（SSL）-3/--sslv3 # 使用的SSLv3（SSL）--3p-quote # like -Q for the source URL for 3rd party transfer--3p-url # 使用url，进行第三方传送--3p-user # 使用用户名和密码，进行第三方传送-4/--ipv4 # 使用IP4-6/--ipv6 # 使用IP6 5.3 curl wget两种方法模拟http的get post请求get请求： 12345# 使用curl命令：$ curl "http://www.baidu.com" # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地$ curl -i "http://www.baidu.com" # 显示全部信息$ curl -l "http://www.baidu.com" # 只显示头部信息$ curl -v "http://www.baidu.com" # 显示get请求全过程解析 12# 使用wget命令：$ wget "http://www.baidu.com" post请求： 12# 使用curl命令(通过-d参数，把访问参数放在里面)：$ curl -d "param1=value1&amp;param2=value2" "http://www.baidu.com" 12# 使用wget命令：（--post-data参数来实现）$ wget --post-data 'user=foo&amp;password=bar' http://server.com/auth.PHP 6 B计划6.1 用tar归档tar支持的参数包括： A、 c、 d、 r、 u、 x、 f 和 v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 用tar对文件进行归档：$ tar -cf output.tar file1 file2 file3 folder1 ..# 使用选项-t列出归档文件中所包含的文件：$ tar -tf archive.tarfile1file2# 如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数$ $ tar -tvf archive.tar-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2# 文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。# 向归档文件中添加文件,追加选项-r$ tar -rvf original.tar new_file# 用下面的方法列出归档文件中的内容：$ tar -tf archive.tarhello.txt# 从归档文件中提取文件或文件夹, -x 表示提取$ tar -xf archive.tar# 用选项-C来指定需要将文件提取到哪个目录：$ tar -xf archive.tar -C /path/to/extraction_directory# 可以通过将文件名指定为命令行参数来提取特定的文件：$ tar -xvf file.tar file1 file4# 上面的命令只提取file1和file4，忽略其他文件。# 在tar中使用stdin和stdout$ tar cvf - files/ | ssh user@example.com "tar xv -C Documents/"# 在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由'-'指明）。# 拼接两个归档文件, -A 选项轻松地合并多个tar文件$ tar -Af file1.tar file2.tar# 查看内容，验证操作是否成功：$ tar -tvf file1.tar# 通过检查时间戳来更新归档文件中的内容# 可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。$ tar -tf archive.tarfileafilebfilec# 仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：$ tar -uf archive.tar filea# 如果两个filea的时间戳相同，则什么都不会发生。# 可用touch命令修改文件的时间戳，然后再用tar命令：$ tar -uvvf archive.tar filea-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea# 比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：$ tar -df archive.tarafile: Mod time differsafile: Size differs# 从归档文件中删除文件, --delete选项从给定的归档文件中删除文件$ tar -tf archive.tarfileafilebfilec# 删除filea：$ tar --delete --file archive.tar filea$ tar -tf archive.tarfilebfilec 压缩tar归档文件： 归档文件通常被压缩成下列格式之一： file.tar.gz file.tar.bz2 file.tar.lzma 不同的tar选项可以用来指定不同的压缩格式： -j 指定bunzip2格式； -z 指定gzip格式； –lzma 指定lzma格式。 12345678910111213141516171819# 为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：$ tar acvf archive.tar.gz filea fileb filec# 从归档中排除部分文件, --exclude [PATTERN]排除匹配通配符样式的文件$ tar -cf arch.tar * --exclude "*.txt"# 样式应该使用双引号来引用，避免shell对其进行扩展。# 也可以将需要排除的文件列表放入文件中，同时配合选项 -X：$ cat listfileafileb$ tar -cf arch.tar * -X list# 排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：$ tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn# 打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：$ tar -cf arc.tar * --exclude "*.txt" --totalsTotal bytes written: 20480 (20KiB, 12MiB/s) 6.2 用cpio归档1234567891011# 创建测试文件：$ touch file1 file2 file3# 将测试文件按照下面的方法进行归档：$ echo file1 file2 file3 | cpio -ov &gt; archive.cpio# 列出cpio归档文件中的内容：$ cpio -it &lt; archive.cpio# 从cpio归档文件中提取文件：$ cpio -id &lt; archive.cpio 对于归档命令： -o 指定了输出； -v 用来打印归档文件列表。 在列出给定cpio归档文件所有内容的命令中： -i 用于指定输入； -t 表示列出归档文件中的内容。 当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 6.3 使用gzip压缩数据12345678910111213141516171819# 要使用gzip压缩文件，可以使用下面的命令：$ gzip filename$ lsfilename.gz# 将gzip文件解压缩的方法如下：$ gunzip filename.gz$ lsfile# 列出压缩文件的属性信息：$ gzip -l test.txt.gzcompressed uncompressed ratio uncompressed_name35 6 -33.3% test.txt# gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。$ cat file | gzip -c &gt; file.gz# 我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 压缩归档文件# 方法 1$ tar -czvvf archive.tar.gz [FILES]或者$ tar -cavvf archive.tar.gz [FILES]# 选项 -a表明从文件扩展名自动推断压缩格式。# 方法 2# 首先，创建一个tar归档文件：$ tar -cvvf archive.tar [FILES]# 压缩tar归档文件：$ gzip archive.tar# zcat——无需解压缩，直接读取gzip格式文件$ lstest.gz$ zcat test.gzA test file# 文件test包含了一行文本"A test file"$ lstest.gz# 压缩率# 我们可以指定压缩率，它共有9级，其中：# 1级的压缩率最低，但是压缩速度最快；# 9级的压缩率最高，但是压缩速度最慢。$ gzip -5 test.img# 这应该能在压缩速度和压缩比之间获得一个不错的平衡。# 使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长$ bzip2 filename# 解压缩bzip2格式的文件：$ bunzip2 filename.bz2# 生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：$ tar -xjvf archive.tar.bz2# 其中-j表明该归档文件是bzip2格式。# 使用lzma# lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。$ lzma filename# 解压缩lzma文件：$ unlzma filename.lzma# 可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：$ tar -cvvf --lzma archive.tar.lzma [FILES]或者$ tar -cavvf archive.tar.lzma [FILES]# 如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：$ tar -xvvf --lzma archive.tar.lzma -C extract_directory# 其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。# 我们也可以用：$ tar -xavvf archive.tar.lzma -C extract_directory 6.4 用 zip 归档和压缩123456789101112131415161718# 对归档文件采用ZIP格式进行压缩：$ zip file.zip file# 对目录和文件进行递归操作, -r 用于指定递归操作：$ zip -r archive.zip folder1 folder2# 要从ZIP文件中提取内容，可以使用：$ unzip file.zip# 在完成提取操作之后， unzip并不会删除file.zip# 如果需要更新压缩文件中的内容，使用选项 -u：$ zip file.zip -u newfile# 从压缩文件中删除内容，则使用-d：$ zip -d arc.zip file.txt# 列出压缩文件中的内容：$ unzip -l archive.zip 6.5 更快的归档工具 pbzip2123456789101112131415161718192021# 压缩单个文件：$ pbzip2 myfile.tar# pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。# 要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：$ tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/或者$ tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2# 从pbzip2格式的文件中进行提取。# 如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：$ pbzip2 -dc myfile.tar.bz2 | tar x# 如果是经过pbzip2压缩过的归档文件，可以使用：$ pbzip2 -d myfile.tar.bz2# 手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量$ pbzip2 -p4 myfile.tar# 上面的命令告诉pbzip2使用4个处理器核心。# 指定压缩比# 像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。 6.6 创建压缩文件系统squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。 123456789101112131415161718# 添加源目录和文件，创建一个squashfs文件：$ sudo mksquashfs /etc test.squashfsParallel mksquashfs: Using 2 processorsCreating 4.0 filesystem on test.squashfs, block size 131072.[=======================================] 1867/1867 100%# 利用环回形式挂载squashfs文件：$ mkdir /mnt/squash$ mount -o loop compressedfs.squashfs /mnt/squash# 你可以访问/mnt/squashfs访问其中的内容。# 在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：$ sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow# 也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：$ cat excludelist/etc/passwd/etc/shadow$ sudo mksquashfs /etc test.squashfs -ef excludelist 6.7 使用 rsync 备份系统快照rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 rsync也支持压缩、加密等多种特性。 1234567891011121314151617181920212223242526272829303132# 将源目录复制到目的端：$ rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data# 其中： -a表示要进行归档； -v表示在stdout上打印出细节信息或进度。# 将数据备份到远程服务器或主机：$ rsync -av source_dir username@host:PATH# 用下面的方法将远程主机上的数据恢复到本地主机：$ rsync -av username@host:PATH destination# 通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：$ rsync -avz source destination# 将一个目录中的内容同步到另一个目录：$ rsync -av /home/test/ /home/backups# 这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中# 在使用rsync进行归档的过程中排除部分文件$ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude "*.txt"# 或者我们可以通过一个列表文件指定需要排除的文件。# 这可以利用--exclude-from FILEPATH。# 在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件$ rsync -avz SOURCE DESTINATION --delete# 定期进行备份$ crontab -ev# 添加上这么一行：0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups# 上面的crontab条目将rsync调度为每10个小时运行一次。 6.8 用 fsarchiver 创建全盘镜像1234567891011121314# 创建文件系统/分区备份。# 使用fsarchiver的savefs选项：$ fsarchiver savefs backup.fsa /dev/sda1# 同时备份多个分区。$ fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2# 从备份归档中恢复分区。$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1# id=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。# 从备份归档中恢复多个分区。# 像之前一样，使用restfs选项：$ fsarchiver restfs backup.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1 7 无网不利7.1 设置网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 手动设置网络接口的IP地址：$ ifconfig wlan0 192.168.0.80# 使用以下命令设置比IP地址的子网掩码：$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0# 自动配置网络接口$ dhclient eth0# 打印网络接口列表$ ifconfig | cut -c-10 | tr -d ' ' | tr -s '\n'lowlan0# 显示IP地址$ ifconfig wlan0 | egrep -o "inet addr:[^ ]*" | grep -o "[0-9.]*"192.168.0.82# 硬件地址（MAC地址）欺骗$ ifconfig eth0 hw ether 00:1c:bf:87:25:d5# 名字服务器与DNS（域名服务）$ cat /etc/resolv.confnameserver 8.8.8.8# 我们可以像下面这样手动添加名字服务器：$ echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf# DNS查找$ host google.comgoogle.com has address 64.233.181.105google.com has address 64.233.181.99google.com has address 64.233.181.147google.com has address 64.233.181.106google.com has address 64.233.181.103google.com has address 64.233.181.104$ nslookup google.comServer: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer:Name: google.comAddress: 64.233.181.105Name: google.comAddress: 64.233.181.99Name: google.comAddress: 64.233.181.147Name: google.comAddress: 64.233.181.106Name: google.comAddress: 64.233.181.103Name: google.comAddress: 64.233.181.104Server: 8.8.8.8# 上面最后一行对应着用于DNS解析的默认名字服务器。# 如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。# 用下面的方法进行添加：$ echo IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts# 例如：$ echo 192.168.0.9 backupserver &gt;&gt; /etc/hosts# 添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。# 显示路由表信息$ routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref UseIface192.168.0.0 * 255.255.252.0 U 2 0 0wlan0link-local * 255.255.0.0 U 1000 0 0wlan0default p4.local 0.0.0.0 UG 0 0 0wlan0# 也可以使用：$ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 0.0.0.0 255.255.252.0 U 2 0 0 wlan0169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 wlan00.0.0.0 192.168.0.4 0.0.0.0 UG 0 0 0 wlan0# -n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。# 设置默认网关：$ route add default gw 192.168.0.1 wlan0 7.2 traceroute 命令traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量（metric）。 traceroute的输出如下： 12345678910111213141516$ traceroute google.comtraceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172(209.85.255.172) 5.678 ms5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114(72.14.233.114) 13.736 ms 13.803 ms7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110(209.85.255.110) 14.122 ms*9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms 7.3 列出网络上所有的活动主机 (fping)fping的选项如下： 选项 -a指定打印出所有活动主机的IP地址； 选项 -u指定打印出所有无法到达的主机； 选项 -g指定从 “IP地址/子网掩码”记法或者”IP地址范围”记法中生成一组IP地址； 12345678910111213141516$ fping -a 192.160.1/24 -g# 或者$ fping -a 192.160.1 192.168.0.255 -g# 我们可以用已有的命令行工具来查询网络上的主机状态：$ fping -a 192.160.1/24 -g 2&gt; /dev/null192.168.0.1192.168.0.90# 或者，使用：$ fping -a 192.168.0.1 192.168.0.255 -g# &gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6# 将IP地址作为参数传递$ fping -a &lt; ip.list# 从文件中传递一组IP地址 7.4 ssh 命令123456789101112131415# SSH的压缩功能,选项-C启用这一功能：$ ssh -C user@hostname COMMANDS# 将数据重定向至远程shell命令的stdin$ echo 'text' | ssh user@remote_host 'echo'text# 或者# 将文件中的数据进行重定向$ ssh user@remote_host 'echo' &lt; file# 在远程主机中执行图形化命令# 对此，你需要像这样设置变量$DISPLAY：$ ssh user@host "export DISPLAY=:0 ; command1; command2"""# 这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：$ ssh -X user@host "command1; command2 7.5 通过网络传输文件计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 文件传输协议（File Transfer Protocol， FTP） ： 1234# 要连接FTP服务器传输文件，可以使用：$ lftp username@ftphost# 它会提示你输入密码，然后显示一个像下面那样的登录提示符：lftp username@ftphost:~&gt; 你可以在提示符后输入命令，如下所示。 用cd directory改变目录。 用lcd改变本地主机的目录。 用mkdir创建目录。 列出远程机器当前目录下的文件使用Is。 用get filename下载文件：lftp username@ftphost:~&gt; get filename 用put filename从当前目录上传文件：lftp username@ftphost:~&gt; put filename 用quit退出lftp会话。 FTP自动传输 ： ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 SFTP（Secure FTP，安全FTP） ： 12345$ cd /home/slynux$ put testfile.jpg$ get serverfile.jpg# 运行sftp：$ sftp user@domainname rsync命令 ： rsync广泛用于网络文件复制及系统备份。 SCP（Secure Copy Program，安全复制程序） ： 123$ scp filename user@remotehost:/home/path$ scp user@remotehost:/home/path/filename filename 用SCP进行递归复制 : 123$ scp -r /home/slynux user@remotehost:/home/backups# 将目录/home/slynux递归复制到远程主机中# scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。 7.6 连接网线网络我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： 12345678$ iwlist scanwlan0 Scan completed : Cell 01 - Address: 00:12:17:7B:1C:65 Channel:11 Frequency:2.462 GHz (Channel 11) Quality=33/70 Signal level=-77 dBm Encryption key:on ESSID:"model-2" 7.7 在本地挂载点上挂载远程驱动器sshfs允许你将远程文件系统挂载到本地挂载点上。 123456# 将位于远程主机上的文件系统挂载到本地挂载点上：$ sshfs -o allow_other user@remotehost:/home/path /mnt/mountpointPassword:# 完成任务后，可用下面的方法卸载：$ umount /mnt/mountpoint 7.8 网络流量与端口分析列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： 1234$ lsof -i# 要列出本地主机当前的开放端口，可以使用：$ lsof -i | grep ":[0-9]\+-&gt;" -o | grep "[0-9]\+" -o | sort | uniq 用netstat查看开放端口与服务 ： 12# netstat -tnp列出开放端口与服务：$ netstat -tnp 7.9 创建套接字最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 12345678# 设置侦听套接字：$ nc -l 1234# 这会在本地主机的端口1234上创建一个侦听套接字。# 连接到该套接字：$ nc HOST 1234# 要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。 在网络上进行快速文件复制 ： 12345# 在接收端执行下列命令：$ nc -l 1234 &gt; destination_filename# 在发送端执行下列命令：$ nc HOST 1234 &lt; source_filename 7.10 iptables防火墙设置12345678910# 阻塞发送到特定IP地址的流量：$ iptables -A OUTPUT -d 8.8.8.8 -j DROP# 阻塞发送到特定端口的流量：$ iptables -A OUTPUT -p tcp -dport 21 -j DROP# iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。# 清除对iptables链所做出的所有改动。$ iptables --flush 8 当个好管家8.1 监视磁盘使用情况df 是disk free的缩写， du 是disk usage的缩写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 找出某个文件（或多个文件）占用的磁盘空间：$ du file.txt# 要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：$ du -a DIRECTORY# 以KB、 MB或块（block）为单位显示磁盘使用情况$ du -h FILENAME# 显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况$ du -c process_log.shpcpu.sh4 process_log.sh4 pcpu.sh8 total# -s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。$ du -sh slynux680K slynux# 打印以字节（默认输出）为单位的文件大小：$ du -b FILE(s)# 打印以KB为单位的文件大小：$ du -k FILE(s)# 打印以MB为单位的文件大小：$ du -m FILE(s)# 打印以指定块为单位的文件大小：$ du -B BLOCK_SIZE FILE(s)# 从磁盘使用统计中排除部分文件$ du --exclude "*.txt" FILES(s)# 排除所有的.txt文件$ du --exclude-from EXCLUDE.txt DIRECTORY# EXCLUDE.txt包含了需要排除的文件列表# --max-depth指定du应该遍历的目录层次的最大深度。$ du --max-depth 2 DIRECTORY# 找出指定目录中最大的10个文件$ du -ak /home/slynux | sort -nrk 1 | head -n 4$ find . -type f -exec du -k &#123;&#125; \; | sort -nrk 1 | head du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 123456789$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sda1 9.2G 2.2G 6.6G 25% /none 497M 240K 497M 1% /devnone 502M 168K 501M 1% /dev/shmnone 502M 88K 501M 1% /var/runnone 502M 0 502M 0% /var/locknone 502M 0 502M 0% /lib/init/rwnone 9.2G 2.2G 6.6G 25% /var/lib/ureadahead/debugfs 8.2 计算命令执行时间 real: %e user: %U sys: %S 12345678910111213141516171819202122$ time COMMAND# 可以用选项-o filename将相关的时间统计信息写入文件：$ /usr/bin/time -o output.txt COMMAND# 要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：$ /usr/bin/time -a -o output.txt COMMAND# 创建格式化输出：$ /usr/bin/time -f "Time: %U" -a -o timing.log unameLinux# 用错误重定向操作符（2&gt;）对时间信息重定向。$ /usr/bin/time -f "Time: %U" uname&gt; command_output.txt 2&gt;time.log$ cat time.logTime: 0.00$ cat command_output.txtLinux# 使用参数%Z显示系统页面大小：$ /usr/bin/time -f "Page size: %Z bytes" ls&gt; /dev/nullPage size: 4096 bytes 三种不同类型的时： Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I/O操作完成所用的时间）。 User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。 time命令 一些可以使用的参数： 参数 描述 %C 进行计时的命令名称以及命令行参数 %D 进程非共享数据区域的大小，以KB为单位 %E 进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒 %x 命令的退出状态 %k 进程接收到的信号数量 %W 进程被交换出主存的次数 %Z 系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同 %P 进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示 %K 进程的平均总（data+stack+text）内存使用量，以KB为单位 %w 进程主动进行上下文切换的次数，例如等待I/O操作完成 %c 进程被迫进行上下文切换的次数（由于时间片到期） 8.3 收集与当前登录用户、启动日志及启动故障的相关信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 获取当前登录用户的相关信息：$ whoslynux pts/0 2010-09-29 05:24 (slynuxs-macbook-pro.local)slynux tty7 2010-09-29 07:08 (:0)# 获得有关登录用户更详细的信息：$ w 07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATslynux pts/0 slynuxs 05:24 0.00s 0.65s 0.11s sshd: slynuxslynux tty7 :0 07:08 1:45m 3.28s 0.26s gnome-session# 第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。# 列出当前登录主机的用户列表：$ usersslynux slynux slynux hacker$ users | tr ' ' '\n' | sort | uniqslynuxhacker# 查看系统已经加电运行了多长时间：$ uptime21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09$ uptime | grep -Po '\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;'# 获取上一次启动以及用户登录会话的信息：$ lastslynux tty7 :0 Tue Sep 28 18:27 still logged inreboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)# last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录tty、登录时间、状态等信息。# last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：$ last -f /var/log/wtmp# 获取单个用户登录会话的信息：$ last USER# 获取重启会话（reboot session）信息：$ last rebootreboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)# 获取失败的用户登录会话信息：$ lastbtest tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00) 8.4 使用 watch 监视命令输出watch命令可以用来在终端中以固定的间隔监视命令输出。 123456789101112$ watch ls$ watch 'ls -l | grep "^d"'# 只列出目录# 命令默认每2秒更新一次输出。# -n SECOND指定更新输出的时间间隔。例如：$ watch -n 5 'ls -l'# 以5秒为间隔，监视ls -l的输出# 突出标示watch输出中的差异, -d 可以启用这一功能：$ watch -d 'COMMANDS' 8.5 用 logrotate 管理日志文件用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 logrotate 的配置目录位于/etc/logrotate.d。 12345678910$ cat /etc/logrotate.d/program/var/log/program.log &#123;missingoknotifemptysize 30kcompressweeklyrotate 5create 0600 root root&#125; 配置文件中各个参数的含义： 参数 描述 missingok 如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替） notifempty 仅当源日志文件非空时才对其进行轮替 size 30k 限制实施轮替的日志文件的大小。可以用1M表示1MB compress 允许用gzip压缩较旧的日志 weekly 指定进行轮替的时间间隔。可以是weekly、 yearly或daily rotate 5 这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz create 0600 root root 指定所要创建的归档文件的模式、用户以及用户组 8.6 用 syslog 记录日志每一个标准应用进程都可以利用syslog记录日志信息。 使用命令logger通过syslogd记录日志。 Linux中一些重要的日志文件 ： 日志文件 描述 /var/log/boot.log 系统启动信息 /var/log/httpd Apache Web服务器日志 /var/log/messages 发布内核启动信息 /var/log/auth.log 用户认证日志 /var/log/dmesg 系统启动信息 /var/log/mail.log 邮件服务器日志 /var/log/Xorg.0.log X服务器日志 12345678910111213# 向系统日志文件/var/log/message中写入日志信息：$ logger This is a test log line$ tail -n 1 /var/log/messagesSep 29 07:47:44 slynux-laptop slynux: This is a test log line # 如果要记录特定的标记（tag），可以使用：$ logger -t TAG This is a message$ tail -n 1 /var/log/messagesSep 29 07:48:42 slynux-laptop TAG: This is a message# 但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。# 要将另一个日志文件的最后一行记录到系统日志中，可以使用：$ logger -f /var/log/source.log 8.7 通过监视用户登录找出入侵者入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： 试图登录的账户 试图登录的次数 攻击者的IP地址 IP地址所对应的主机 进行登录的时间段 为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件/var/log/auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 8.8 监视磁盘活动12345678# 交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：$ iotop -o# 用于shell脚本的非交互式用法：$ iotop -b -n 2# 监视特定进程$ iotop -p PID 8.9 检查磁盘及文件系统错误使用fsck的各种选项对文件系统错误进行检查和修复。 12345678910111213141516171819202122232425# 要检查分区或文件系统的错误，只需要将路径作为fsck的参数：$ fsck /dev/sdb3fsck from util-linux 2.20.1e2fsck 1.42.5 (29-Jul-2012)HDD2 has been mounted 26 times without being checked, check forced.Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary informationHDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks# 检查/etc/fstab中所配置的所有文件系统：$ fsck -A# 该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统# 指定fsck自动修复错误，无需询问是否进行修复：$ fsck -a /dev/sda2# 模拟fsck要执行的操作：$ fsck -ANfsck from util-linux 2.20.1[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6 9 管理重任9.1 收集进程信息1234567891011121314151617181920212223242526272829303132333435# 为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：$ ps -fUID PID PPID C STIME TTY TIME CMDslynux 1220 1219 0 18:18 pts/0 00:00:00 -bashslynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f# 使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。# 运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。$ ps -e | headPID TTY TIME CMD1 ? 00:00:00 init2 ? 00:00:00 kthreadd3 ? 00:00:00 migration/04 ? 00:00:00 ksoftirqd/05 ? 00:00:00 watchdog/06 ? 00:00:00 events/07 ? 00:00:00 cpuset8 ? 00:00:00 khelper9 ? 00:00:00 netns# 用 -o 来指定想要显示的列，以便只打印出我们需要的内容。# -o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。# -e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。# 示例如下，其中comm表示COMMAND， pcpu表示CPU占用率：$ ps -eo comm,pcpu | headCOMMAND %CPUinit 0.0kthreadd 0.0migration/0 0.0ksoftirqd/0 0.0watchdog/0 0.0events/0 0.0cpuset 0.0khelper 0.0netns 0.0 选项-o可以使用不同的参数： 参数 描述 pcpu CPU占用率 pid 进程ID ppid 父进程ID pmem 内存使用率 comm 可执行文件名 cmd 简单命令 user 启动进程的用户 nice 优先级 time 累计的CPU时间 etime 进程启动后流逝的时间 tty 所关联的TTY设备 euid 有效用户ID stat 进程状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。$ top# 根据参数对ps输出进行排序$ ps -eo comm,pcpu --sort -pcpu | headCOMMAND %CPUXorg 0.1hald-addon-stor 0.0ata/0 0.0scsi_eh_0 0.0gnome-settings- 0.0init 0.0hald 0.0pulseaudio 0.0gdm-simple-gree 0.0$ ps -eo comm,pid,pcpu,pmem | grep bashbash 1255 0.0 0.3bash 1680 5.5 0.3# 找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。$ ps -C bash -o pid=12551680$ pgrep bash12551680# 如果不使用换行符作为定界符，而是要自行指定可以像下面这样：$ pgrep bash -d ":"1255:1680# 指定进程的用户（拥有者）列表：$ pgrep -u root,slynux COMMAND# 根据真实用户或ID以及有效用户或ID过滤ps输出 用 -u EUSER1,EUSER2 …，指定有效用户列表； 用 -U RUSER1,RUSER2 …，指定真实用户列表$ ps -u root -U root -o user,pcpu# 用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：$ ps -t pts/0,pts/1PID TTY TIME CMD1238 pts/0 00:00:00 bash1835 pts/1 00:00:00 bash1864 pts/0 00:00:00 ps# 进程线程的相关信息# 通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：$ ps -eLf# 指定输出宽度以及所要显示的列# 可以按照你自己的使用方式来进行应用。尝试以下选项: -f ps –ef u ps -e u ps ps -e w（w表示宽松输出）# 显示进程的环境变量# 了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。$ ps -eo pid,cmd e | tail -n 31162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket1172 sshd: slynux [priv]1237 sshd: slynux@pts/01238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynuxPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/gamesMAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-colorLANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.592429-1573657095 9.2 which、 whereis、 file、 whatis与平均负载1234567891011121314151617181920212223# which, which命令用来找出某个命令的位置。$ which ls/bin/ls# whereis# whereis与which命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）$ whereis lsls: /bin/ls /usr/share/man/man1/ls.1.gz# file$ file FILENAME# 该命令会打印出与该文件类型相关的细节信息。$ file /bin/ls/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked(uses shared libs), for GNU/Linux 2.6.15, stripped# whatis, whatis命令会输出作为参数的命令的简短描述信息。$ whatis lsls (1) - list directory contents# 平均负载$ uptime12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00 9.3 杀死进程以及发送或响应信号信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 123456789101112131415# 列出所有可用的信号：$ kill -l# 终止进程：$ kill PROCESS_ID_LIST# kill命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。# 要通过kill命令向进程发送指定的信号，可以使用：$ kill -s SIGNAL PID# 参数SIGNAL要么是信号名称，要么是信号编号。# 我们经常要强行杀死进程，可以使用：$ kill -s SIGKILL PROCESS_ID或者$ kill -9 PROCESS_ID 常用到的信号量： SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection） SIGINT 2——当按下Ctrl + C时发送该信号 SIGKILL 9——用于强行杀死进程 SIGTERM 15——默认用于终止进程 SIGTSTP 20——当按下Ctrl + Z时发送该信号 1234567891011121314151617# killall命令通过命令名终止进程：$ killall process_name# 通过名称向进程发送信号：$ killall -s SIGNAL process_name# 通过名称强行杀死进程：$ killall -9 process_name# pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：$ pkill process_name$ pkill -s SIGNAL process_name# pkill不支持信号名称。# 捕捉并响应信号# trap命令在脚本中用来为信号分配信号处理程序。$ trap 'signal_handler_function_name' SIGNAL LIST 9.4 向用户终端发送消息1234567# wall命令用来向当前所有登录用户的终端写入消息。$ cat message | wall或者$ wall&lt; messageBroadcast Message from slynux@slynux-laptop(/dev/pts/1) at 12:54 ...This is a messag 9.5 采集系统信息1234567891011121314151617181920212223242526272829303132# 打印当前系统的主机名：$ hostname或者$ uname -n# 打印Linux内核版本、硬件架构等详细信息：$ uname -a# 打印内核发行版本：$ uname -r# 打印主机类型：$ uname -m# 打印CPU相关信息：$ cat /proc/cpuinfo# 获取处理器名称：$ cat /proc/cpuinfo | sed -n 5p# 打印内存的详细信息：$ cat /proc/meminfo# 打印系统可用内存总量：$ cat /proc/meminfo | head -1MemTotal: 1026096 kB# 列出系统的分区信息：$ cat /proc/partitions或者$ fdisk -l #如果没有输出，切换到root用户执行该命令# 获取系统的详细信息：$ lshw #建议以root用户来执行 9.6 使用 proc 采集信息以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录/proc/4295。进程对应的目录中包含了大量有关进程的信息。 /proc/PID中一些重要的文件如下所示。 environ：包含与进程相关的环境变量。使用cat /proc/4295/environ，可以显示所有传递给该进程的环境变量 cwd： 是一个到进程工作目录（working directory）的符号链接 exe：是一个到当前进程所对应的可执行文件的符号链接 $ readlink /proc/4295/exe/bin/bash fd：包含了进程所使用的文件描述符 9.7 用 cron 进行调度crontab任务配置基本格式： 12* * * * * command分钟(0-59) 小时(0-23) 日期(1-31) 月份(1-12) 星期(0-6,0代表星期天) 命令 cron表中的每一个条目都由6部分组成，并按照下列顺序排列： 分钟（0～59） 小时（0～23） 天（1～31） 月份（1～12） 工作日（0～6） 命令（在指定时间执行的脚本或命令） 星号（*）指定命令应该在每个时间段执行。 除了数字还有几个个特殊的符号就是 &quot;*&quot; 、&quot;/&quot; 和 &quot;-&quot; 、&quot;,&quot; ，* 代表所有的取值范围内的数字，&quot;/&quot; 代表每的意思, &quot;*/5&quot; 表示每5个单位，&quot;-&quot; 代表从某个数字到某个数字, &quot;,&quot; 分开几个离散的数字。以下举几个例子说明问题： 1234567891011121314151617181920212223242526272829# 指定每小时的第5分钟执行一次ls命令5 * * * * ls # 指定每天的 5:30 执行ls命令30 5 * * * ls # 指定每月8号的7：30分执行ls命令30 7 8 * * ls # 指定每年的6月8日5：30执行ls命令30 5 8 6 * ls # 指定每星期日的6:30执行ls命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]30 6 * * 0 ls # 每月10号及20号的3：30执行ls命令 [注：“，”用来连接多个不连续的时段 ]30 3 10,20 * * ls # 每天8-11点的第25分钟执行ls命令 [注：“-”用来连接连续的时段 ]25 8-11 * * * ls # 每15分钟执行一次ls命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]*/15 * * * * ls # 每个月中，每隔10天6:30执行一次ls命令[即每月的1、11、21、31日是的6：30执行一次ls命令。 ]30 6 */10 * * ls # 每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件50 7 * * * root run-parts /etc/cron.daily # [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ] 配置用户定时任务的语法： 123$ crontab [-u user]file$ crontab -u user[-i] 参数与说明： crontab -u //设定某个用户的cron服务 crontab -l //列出某个用户cron服务的详细内容 crontab -r //删除没个用户的cron服务 crontab -e //编辑某个用户的cron服务 9.8 从终端截图12345678# 取整个屏幕：$ import -window root screenshot.png# 手动选择部分区域进行抓取：$ import screenshot.png# 抓取特定窗口：$ import -window window_id screenshot.png]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令eval的用法]]></title>
    <url>%2F2017%2F04%2F13%2FLinux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[eval command-line其中command－line是在终端上键入的一条普通命令行。然而当在它前面放上eval时，其结果是shell在执行命令行之前扫描它两次。如： 123$ pipe="|"$ eval ls $pipe wc -l shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。 如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。 eval echo $# 取得最后一个参数如： 12345$ cat lasteval echo $$#$ ./last one two three fourfour 第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令 以下示意如何用eval命令创建指向变量的“指针”：1234567891011$ x=100$ ptrx=x$ eval echo $$ptrx #指向ptrx，用这里的方法可以理解b中的例子100 打印100$ eval $ptrx=50 #将50存到ptrx指向的变量中。$ echo $x50 打印50]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP思维导图]]></title>
    <url>%2F2017%2F04%2F12%2FHTTP%2FHTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[文章来自HTTP思维导图。 HTTP mindmap整理 source from 《HTTP权威指南》 概述-Summary 报文-Message 连接-Connection 代理-Proxy 缓存-Cache 网关、隧道与中继-Gateway、Tunnel and Relay 识别-Identification 认证-Authentication 安全-Security 实体与编码-Entity and Encoding]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack创建、运行vue.js项目及其目录结构详解]]></title>
    <url>%2F2017%2F04%2F10%2FWebpack%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E8%A1%8Cvue-js%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[项目环境搭建：1.安装node 进入node官网进行下载。 版本查看： 12$ node -vv6.10.1 **注意：**node版本最好新一点，推介6.0以上。 2.全局安装vue-cli 1$ npm install -g vue-cli 注意： 如果安装失败可能需要root权限重新安装。 3.创建一个基于 webpack 模板的新项目 12$ vue init webpack project-name #(默认安装2.0版本)$ vue init webpack#1.0 project-name #(安装1.0版本) 项目目录结构： main.js是入口文件，主要作用是初始化vue实例并使用需要的插件 123456789101112131415// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, components: &#123; Hello &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; index.html文件入口 src放置组件和入口文件 node_modules为依赖的模块 config中配置了路径端口值等 build中配置了webpack的基本配置、开发环境配置、生产环境配置等 运行项目：1234$ cd project-name$ npm install$ npm run dev# 上述步骤都完成后在浏览器输入：localhost:8080]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP--cookie，session，token]]></title>
    <url>%2F2017%2F04%2F10%2FHTTP%2FHTTP%E4%B9%8BCookie%E5%92%8CSession%E5%92%8CToken%2F</url>
    <content type="text"><![CDATA[认识HTTP—-Cookie和Session篇 彻底理解cookie，session，token 详解cookie、session和HTTP缓存 COOKIE和SESSION机制详解 TODO]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2017%2F04%2F06%2FHTTP%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTTP（HyperText Transfer Protocol 超文本传输协议)是互联网上应用最为广泛的一种网络协议，它是由万维网协会（World Wide Web Consortium）制定发布。 文章主要以一次HTTP请求的整个过程来讲解(DNS解析不讲)：HTTP 起源、TCP/IP 协议、建立 TCP 连接、客户端请求、服务端响应、断开 TCP 连接，文章最后还捎带讲了与 HTTP 相关知识。 简介起源今天我们能够在网络中畅游，都得益于一位计算机科学家蒂姆·伯纳斯·李的构想。1991年8月6日，蒂姆·伯纳斯·李在位于欧洲粒子物理研究所（CERN）的NeXT计算机上，正式公开运行世界上第一个Web网站（http://info.cern.ch ），建立起基本的互联网基础概念和技术体系，由此开启了网络信息时代的序幕。 伯纳斯·李的提案包含了网络的基本概念并逐步建立了所有必要的工具： 提出HTTP (Hypertext Transfer Protocol) 超文本传输协议，允许用户通过单击超链接访问资源； 提出使用HTML超文本标记语言(Hypertext Markup Language)作为创建网页的标准； 创建了统一资源定位器URL (Uniform Resource Locator)作为网站地址系统，就是沿用至今的http://www URL格式； 创建第一个Web浏览器，称为万维网浏览器，这也是一个Web编辑器； 创建第一个Web服务器（http://info.cern.ch）以及描述项目本身的第一个Web页面。 特点HTTP 协议一共有五大特点： 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由 Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie 和Session 孕育而生，后期再讲）。 TCP/IP协议我们经常听到一句话就是：HTTP是一个基于TCP/IP协议簇来传递数据。 如何理解上面那句话？我们来看看TCP/IP四层模型就明白了。 从上图我们可以清晰的看到HTTP使用的传输层协议为TCP协议，而网络层使用的是IP协议（当然还使用了很多其他协议），所以说HTTP是一个基于TCP/IP协议簇来传递数据。 同样我们可以看到 ping 走的 ICMP 协议，这也就是为什么有时候我们开 vps 可以上网，但是 ping google 却ping 不通的原因，因为走的是不同的协议。 那 TCP/IP 协议簇大致是如何工作的，我们再来看看下图： 我们可以看到在数据发送端是一层一层封装数据，数据接收端一层一层拆封，最后应用层获得数据。 建立TCP连接我们知道了TCP/IP协议簇大致的工作原理之后，我们来看看HTTP是如何建立连接的。 TCP包头信息前面咱们讲过HTTP是一个基于TCP/IP协议簇来传递数据，所以这HTTP建立连接也就是建立TCP连接，TCP如何建立连接，一起来看看TCP包信息结构吧。 TCP 报文包 = TCP 头信息 + TCP 数据体，而在 TCP 头信息中包含了 6 种控制位（上图红色框中），这六种标志位就代表着 TCP 连接的状态： URG：紧急数据（urgent data）—这是一条紧急信息 ACK：确认已收到 PSH：提示接收端应用程序应该立即从tcp接受缓冲区中读走数据 RST：表示要求对方重新建立连接 SYN：表示请求建立一个连接 FIN：表示通知对方本端要关闭连接了 建立连接过程了解了TCP包头信息之后，我们就可以正式看看TCP建立连接的三次握手了。 三次握手讲解： 客户端发送位码为 syn＝1 ,随机产生 seq number=1234567 的数据包到服务器，服务器由 SYN=1 知道客户端要求建立联机（客户端：我要连接你） 服务器收到请求后要确认联机信息，向 A 发送 ack number=(客户端的seq+1) , syn=1 , ack=1 , 随机产生seq=7654321 的包（服务器：好的，你来连吧） 客户端收到后检查 ack number 是否正确，即第一次发送的 seq number+1 ,以及位码 ack 是否为 1，若正确，客户端会再发送 ack number=(服务器的seq+1) , ack=1，服务器收到后确认 seq 值与 ack=1 则连接建立成功。（客户端：好的，我来了） 面试官：为什么 http 建立连接需要三次握手，不是两次或四次 答：三次是最少的安全次数，两次不安全，四次浪费资源 客户端请求客户端与服务器连接上了之后，客户端就可以开始向服务器请求资源，就可以开始发送HTTP请求了。 HTTP请求报文结构我们之前说过 TCP 报文包 = TCP 头信息 + TCP 数据体，TCP 头信息我们已经讲了，现在来讲 TCP 数据体，也就是我们的 HTTP 请求报文。 HTTP请求实例来看看实际的HTTP请求例子： ① 是请求方法，HTTP/1.1 定义的请求方法有 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE, 最常的两种 GET 和 POST，如果是 RESTful 接口的话一般会用到 GET、POST、DELETE、PUT ② 为请求对应的URL地址，它和报文头的 Host 属性组成完整的请求 URL ③ 是协议名称及版本号 ④ 是HTTP的报文头，报文头包含若干个属性，格式为 “属性名 : 属性值”，服务端据此获取客户端的信息 ⑤ 是报文体，它将一个页面表单中的组件值通过 param1=value1&amp;param2=value2 的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求 URL 也可以通过类似于 “/chapter15/user.html? param1=value1&amp;param2=value2” 的方式传递请求参数。 请求头参数非常多，就不一一说明，只说明两个低级的反扒参数： User-Agent：客户端使用的操作系统和浏览器的名称和版本，有些网站会限制请求浏览器 Referer：先前网页的地址，表示此请求来自哪里，有些网站会限制请求来源 服务端响应服务器在收到客户端请求处理完需要响应并返回给客户端，而HTTP响应报文结构与请求结构体一致。 HTTP响应报文结构 HTTP响应实例 响应状态码响应报文中我们重点关注下：服务器的响应状态码，面试也很容易问到，下面只列出分类，详细状态码自行上网查找了解。 断开连接在服务器响应完毕后，一次会话就结束了，请问这时候连接会断开吗？ 长短连接是否断开我们需要区分 HTTP 版本： 在 HTTP/1.0 版本的时候，客户端与服务器完成一个请求/响应之后，会将之前建立的 TCP 连接断开，下次请求的时候又要重新建立 TCP 连接，这也被称为短连接 在 HTTP1.0 发布仅半年后（1997年1月） ，HTTP/1.1 版本发布并带来一个新的功能：在客户端与服务器完成一次请求/响应之后，允许不断开 TCP 连接，这意味着下次请求就直接使用这个TCP 连接而不再需要重新握手建立新连接，这也被称为长连接 注意：长连接是指一次 TCP 连接允许多次 HTTP 会话，HTTP 永远都是一次请求/响应，会话结束，HTTP 本身不存在长连接之说。 早在 1999 年 HTTP1.1 就推广普及，所以现在浏览器在请求时请求头中都会携带一个参数：Connection:keep-alive，这表示浏览器要求与服务器建立长连接，而服务器也可以设置是否愿意建立长连接。 长连接优缺点对于服务器来说建立长连接有优点也有缺点： 优点：当网站中有大量静态资源（图片、css、js等）就可以开启长连接，这也几张图片就可以通过一次TCP连接发送。 缺点：当客户端请求一次时候不在请求，而服务器却开着长连接资源被占用着，这是严重浪费资源。 所以是否开启长连接，长连接时间都需要根据网站自身来合理设置。 ps：大家不要小看这一个 TCP 连接，在一次客户端 HTTP 完整的请求中（DNS寻址、建立TCP连接、请求、等待、解析网页、断开TCP连接）建立 TCP 连接占用的时间比还是很大的。 断开连接过程在建立TCP连接时是三次握手，而断开TCP连接是四次挥手！ 在前面讲 TCP/IP 协议时我们说过标志位：FIN 表示通知对方本端要关闭连接了，那断开连接为何需要四次挥手呢？ TODO 题外话面试必考题：http三次握手、四次挥手 面试官：为何建立连接需要三次握手而关闭连接却需要四次挥手。 TODO http2.0 HTTP/1.1 已经为我们服务了20年，而 HTTP/2.0 其实在 2015 就发布了，但是还没有推广开来，关于 HTTP/2.0 新特性也可以去网上查阅相关资料. http&amp;rpc因为 http 响应慢、请求头体积大等缺点，所以在微服务时代，大家都使用 rpc 来调用服务，rpc 相关概念感兴趣同学自行网上学习。 http&amp;httpshttp还有两个很大的缺点就是明文且不能保证完整性，所以目前会渐渐被HTTPS代替。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lighttpd+fastcgi]]></title>
    <url>%2F2017%2F03%2F31%2FHTTP%2Flighttpd-fastcgi%2F</url>
    <content type="text"><![CDATA[简介lighttpd 提供了一种外部程序调用的接口，即 FastCGI 接口。这是一种独立于平台和服务器的接口，它介于Web应用程序和Web服务器之间。 这就意味着能够在 Apache 服务器上运行的 FastCGI 程序，也一定可以无缝的在 lighttpd 上使用。 FastCGI介绍1）就像 CGI 一样，FastCGI 也是独立于编程语言的。2）就像 CGI 一样，FastCGI 程序运行在完全独立于核心 Web Server 之外的进程中，和 API 方式相比，提供了很大的安全性。（API会将程序代码与核心Web Server挂接在一起，这就意味着基于问题API的应用程序可能会使整个Web Server或另一个应用程序崩溃；一个恶意API还可以从核心Web Server或另一个应用程序中盗取安全密钥） 3) 虽然 FastCGI 不能一夜之间复制CGI的所有功能，但是 FastCGI 一直宣扬开放，这也使得我们拥有很多免费的 FastCGI 应用程序库（C/C++、Java、Perl、TCL）和免费的Server模块（Apache、ISS、Lighttpd）。 4) 就像 CGI 一样，FastCGI 并不依附于任何 Web Server 的内部架构，因此即使 Server 的技术实现变动，FastCGI 仍然非常稳定；而 API 设计是反映 Web Server 内部架构的，因此，一旦架构改变，API要随之变动。 5) FastCGI 程序可以运行在任何机器上，完全可以和 Web Server 不在一台机器上。这种分布式计算的思想可以确保可扩展性、提高系统可用性和安全性。 6) CGI 程序主要是对 HTTP 请求做计算处理，而 FastCGI 却还可以做得更多，例如模块化认证、授权检查、数据类型转换等等。在未来，FastCGI 还会有能力扮演更多角色。 7) FastCGI 移除了 CGI 程序的许多弊端。例如，针对每一个新请求，WebServer 都必须重启 CGI 程序来处理新请求，这导致 WebServer 的性能会大受影响。而 FastCGI 通过保持进程处理运行状态并持续处理请求的方式解决了该问题，这就将进程创建和销毁的时间节省了出来。 8) CGI 程序需要通过管道（pipe）方式与 Web Server 通信，而 FastCGI 则是通过 Unix-Domain-Sockets 或 TCP/IP 方式来实现与 Web Server 的通信。这确保了 FastCGI 可以运行在 Web Server 之外的服务器上。FastCGI 提供了 FastCGI 负载均衡器，它可以有效控制多个独立的 FastCGI Server 的负载，这种方式比 load-balancer+apache+mod_php 方式能够承担更多的流量。 FastCGI 模块若要 lighttpd 支持 fastcgi，则需要配置如下内容： 在 fastcgi.conf 中配置 1server.modules += ( &quot;mod_fastcgi&quot; ) 及在 module.conf 中配置 1include &quot;conf.d/fastcgi.conf&quot; FastCGI 配置选项lighttpd 通过 fastcgi 模块的方式实现了对 fastcgi 的支持，并且在配置文件中提供了三个相关的选项： 1） fastcgi.debug 可以设置一个从0到65535的值，用于设定 FastCGI 模块的调试等级。当前仅有0和1可用。1表示开启调试（会输出调试信息），0表示禁用。例如： 1fastcgi.debug = 1 2） fastcgi.map-extentsions 同一个 fastcgi server 能够映射多个扩展名，如 .php3 和 .php4 都对应 .php。例如： 1fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot; ) or for multiple 1fastcgi.map-extensions = ( &quot;.php3&quot; =&gt; &quot;.php&quot;, &quot;.php4&quot; =&gt; &quot;.php&quot; ) 3） fastcgi.server 这个配置是告诉 Web Server 将 FastCGI 请求发送到哪里，其中每一个文件扩展名可以处理一个类型的请求。负载均衡器可以实现对同一扩展名的多个对象的负载均衡。 fastcgi.server 的结构语法如下： 1234567891011121314151617181920( &lt;extension&gt; =&gt; ( [ &lt;name&gt; =&gt; ] ( # Be careful: lighty does *not* warn you if it doesn't know a specified option here (make sure you have no typos) "host" =&gt; &lt;string&gt; , "port" =&gt; &lt;integer&gt; , "socket" =&gt; &lt;string&gt;, # either socket or host+port "bin-path" =&gt; &lt;string&gt;, # optional "bin-environment" =&gt; &lt;array&gt;, # optional "bin-copy-environment" =&gt; &lt;array&gt;, # optional "mode" =&gt; &lt;string&gt;, # optional "docroot" =&gt; &lt;string&gt; , # optional if "mode" is not "authorizer" "check-local" =&gt; &lt;string&gt;, # optional "max-procs" =&gt; &lt;integer&gt;, # optional - when omitted, default is 4 "broken-scriptfilename" =&gt; &lt;boolean&gt;, # optional "kill-signal" =&gt; &lt;integer&gt;, # optional, default is SIGTERM(15) (v1.4.14+) ), ( "host" =&gt; ... ) )) 其中： extentsion ：文件名后缀或以”/”开头的前缀（也可为文件名）name ：这是一个可选项，表示handler的名称，在mod_status中用于统计功能，可以清晰的分辨出是哪一个handler处理了。 host ：FastCGI进程监听的IP地址。此处不支持hostname形式。port ：FastCGI进程所监听的TCP端口号bin-path ：本地FastCGI二进制程序的路径，当本地没有FastCGI正在运行时，会启动这个FastCGI程序。socket ：unix-domain-socket所在路径。mode ：可以选择FastCGI协议的模式，默认是“responder”，还可以选择authorizer。docroot ：这是一个可选项，对于responder模式来讲，表示远程主机docroot；对于authorizer模式来说，它表示MANDATORY，并且指向授权请求的docroot。check_local ：这是一个可选项，默认是enable。如果是enable，那么server会首先在本地（server.document-root）目录中检查被请求的文件是否存在，如果不存在，则给用户返回404（Not Found），而不会把这个请求传递给FastCGI。如果是disable，那么server不会检查本地文件，而是直接将请求转发给FastCGI。（disable的话，server从某种意义上说就变为了一个转发器）broken-scriptfilename ：以类似PHP抽取PATH_INFO的方式，抽取URL中的SCRIPT_FILENAME。 如果 bin-path 被设置了，那么： max-procs ：设置多少个FastCGI进程被启动bin-environment ：在FastCGI进程启动时设置一个环境变量bin-copy-environment ：清除环境，并拷贝指定的变量到全新的环境中。kill-signal ：默认的话，在停止FastCGI进程时，lighttpd会发送SIGTERM(-15)信号给子进程。此处可以设置发送的信号。 举例 ： 使用前缀来对应主机： 123456789fastcgi.server = ( "/remote_scripts/" =&gt; (( "host" =&gt; "192.168.0.3", "port" =&gt; 9000, "check-local" =&gt; "disable", "docroot" =&gt; "/" # remote server may use # it's own docroot ))) 如果有一个请求 “http://my.example.org/remote_scripts/test.cgi&quot;，那么server会将其转发给192.168.0.3的9000端口，并且 SCRIPT_NAME 会被赋值为 “/remote_scripts/test.cgi”。如果所设置的 handler 的末尾不是 “/” ，那么会被认为是一个文件。 负载均衡 ： FastCGI 模块提供了一种在多台 FastCGI 服务器间负载均衡的方法。 例如： 123456789fastcgi.server = ( ".php" =&gt; ( ( "host" =&gt; "10.0.0.2", "port" =&gt; 1030 ), ( "host" =&gt; "10.0.0.3", "port" =&gt; 1030 ) ) ) 为了更好的理解负载均衡实现的原理，建议你置 fastcgi.debug 为 1 。即使对于本机的多个 FastCGI ，你也会获得如下输出： 123456789101112proc: 127.0.0.1 1031 1 1 1 31454proc: 127.0.0.1 1028 1 1 1 31442proc: 127.0.0.1 1030 1 1 1 31449proc: 127.0.0.1 1029 1 1 2 31447proc: 127.0.0.1 1026 1 1 2 31438got proc: 34 31454release proc: 40 31438proc: 127.0.0.1 1026 1 1 1 31438proc: 127.0.0.1 1028 1 1 1 31442proc: 127.0.0.1 1030 1 1 1 31449proc: 127.0.0.1 1031 1 1 2 31454proc: 127.0.0.1 1029 1 1 2 31447 上述信息显示出了IP地址，端口号、当前链接数（也就是负载）（倒数第二列）、进程ID（倒数第一列）等等。整个输出信息总是以负载域来从小到大排序的。 参考文献 说说lighttpd的fastcgi Nginx + CGI/FastCGI + C/Cpp FastCGI+lighttpd开发之介绍和环境搭建 附：QC V3 PP 版本 lighttpd.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091$ cat /etc/qtilighttpd.conf # ------------------------------------------------------------------------------# Copyright (c) 2016 Qualcomm Technologies, Inc.# All Rights Reserved.# Confidential and Proprietary - Qualcomm Technologies, Inc.# ------------------------------------------------------------------------------server.document-root = "/opt/qcom/www"server.port = 80server.username = "apps"server.groupname = "apps"server.bind = "0.0.0.0"server.tag = "lighttpd"$SERVER["socket"] == "[::]:80" &#123; &#125;server.errorlog-use-syslog = "enable"accesslog.use-syslog = "enable"server.modules = ( "mod_access","mod_accesslog", "mod_cgi", "mod_fastcgi")fastcgi.debug = 1fastcgi.server = ( "/fsmoam" =&gt; ( "fsmoam.fcgi.handler" =&gt; ( "socket" =&gt; "/tmp/fsmoam.fcgi.socket", "check-local" =&gt; "disable", "bin-path" =&gt; "/opt/qcom/bin/tests/fsmWebServer --default-log-level=DEBUG", "max-procs" =&gt; 1) ))# mimetype mappingmimetype.assign = ( ".pdf" =&gt; "application/pdf", ".sig" =&gt; "application/pgp-signature", ".spl" =&gt; "application/futuresplash", ".class" =&gt; "application/octet-stream", ".ps" =&gt; "application/postscript", ".torrent" =&gt; "application/x-bittorrent", ".dvi" =&gt; "application/x-dvi", ".gz" =&gt; "application/x-gzip", ".pac" =&gt; "application/x-ns-proxy-autoconfig", ".swf" =&gt; "application/x-shockwave-flash", ".tar.gz" =&gt; "application/x-tgz", ".tgz" =&gt; "application/x-tgz", ".tar" =&gt; "application/x-tar", ".zip" =&gt; "application/zip", ".mp3" =&gt; "audio/mpeg", ".m3u" =&gt; "audio/x-mpegurl", ".wma" =&gt; "audio/x-ms-wma", ".wax" =&gt; "audio/x-ms-wax", ".ogg" =&gt; "audio/x-wav", ".wav" =&gt; "audio/x-wav", ".gif" =&gt; "image/gif", ".jpg" =&gt; "image/jpeg", ".jpeg" =&gt; "image/jpeg", ".png" =&gt; "image/png", ".xbm" =&gt; "image/x-xbitmap", ".xpm" =&gt; "image/x-xpixmap", ".xwd" =&gt; "image/x-xwindowdump", ".css" =&gt; "text/css", ".html" =&gt; "text/html", ".htm" =&gt; "text/html", ".js" =&gt; "text/javascript", ".asc" =&gt; "text/plain", ".c" =&gt; "text/plain", ".conf" =&gt; "text/plain", ".text" =&gt; "text/plain", ".txt" =&gt; "text/plain", ".dtd" =&gt; "text/xml", ".xml" =&gt; "text/xml", ".mpeg" =&gt; "video/mpeg", ".mpg" =&gt; "video/mpeg", ".mov" =&gt; "video/quicktime", ".qt" =&gt; "video/quicktime", ".avi" =&gt; "video/x-msvideo", ".asf" =&gt; "video/x-ms-asf", ".asx" =&gt; "video/x-ms-asf", ".wmv" =&gt; "video/x-ms-wmv", ".bz2" =&gt; "application/x-bzip", ".tbz" =&gt; "application/x-bzip-compressed-tar", ".tar.bz2" =&gt; "application/x-bzip-compressed-tar")index-file.names = ( "index.html" )cgi.assign = ( ".sh" =&gt; "/bin/sh" )]]></content>
      <tags>
        <tag>lighttpd</tag>
        <tag>FastCGI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lighttpd 配置https]]></title>
    <url>%2F2017%2F03%2F31%2FHTTP%2Flighttpd-%E9%85%8D%E7%BD%AEhttps%2F</url>
    <content type="text"><![CDATA[确定安装的lighttpd支持ssl版本信息中含有（ssl）字样的信息说明支持ssl，可以在终端输入如下查看： 123$ lighttpd -vlighttpd/1.4.35 (ssl) - a light and fast webserverBuild-Date: Apr 25 2017 10:25:18 生成自签名证书完整的ssl证书分为四个部分： CA根证书（root CA） 中级证书（Intermediate Certificate） 域名证书 证书秘钥（仅由开发者提供） 证书相当于公钥，pem相当于私钥。 Self-Signed Certificates：包含公钥和私钥的结合体，证书（公钥）会在连接请求的时候发给浏览器，以便浏览器解密和加密。 创建Self-Signed Certificates： 1$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes 上边的命令生成一个server.pem文件。 lighttpd.conf 配置1234$SERVER["socket"] == "[::]:443" &#123; ssl.engine = "enable" ssl.pemfile = "/mnt/flash/server.pem"&#125; 强制定向到HTTPS下面是 lighttpd.conf 文件中关于强制 HTTP 定向到 HTTPS 的部分配置： 1234567$HTTP["scheme"] == "http" &#123; # capture vhost name with regex conditiona -&gt; %0 in redirect pattern # must be the most inner block to the redirect rule $HTTP["host"] =~ ".*" &#123; url.redirect = (".*" =&gt; "https://%0$0") &#125;&#125; 此功能需要lighttpd mod_redirect 模块支持。使用此功能前确保模块已经安装。 lighttpd安全配置禁用 SSL Compression (抵御 CRIME 攻击) 1ssl.use-compression = "disable" 禁用 SSLv2 及 SSLv3 12ssl.use-sslv2 = "disable"ssl.use-sslv3 = "disable" 抵御 Poodle 和 SSL downgrade 攻击 需要支持 TLS-FALLBACK-SCSV 以自动开启此功能。下列 openSSL 版本包含对 TLS-FALLBACK-SCSV 的支持，lighttpd 会自动启用此特性。 OpenSSL 1.0.1 在 1.0.1j 及之后的版本中支持 OpenSSL 1.0.0 在 1.0.0o 及之后的版本中支持 OpenSSL 0.9.8 在 0.9.8zc 及之后的版本中支持 加密及交换算法 一份推介的配置： 1ssl.cipher-list = "EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH" 如果您需要兼容一些老式系统和浏览器 (例如 Windows XP 和 IE6)，请使用下面的： 1ssl.cipher-list = "EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4" 配置 Forward Secrecy 和 DHE 参数 生成强 DHE 参数： 12$ cd /etc/ssl/certs$ openssl dhparam -out dhparam.pem 4096 建议您使用性能强劲的平台生成此文件，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 openssl dhparam -out dhparam.pem 2048 命令生成 2048bit 的参数文件。 添加到 SSL 配置文件： 12ssl.dh-file = "/etc/ssl/certs/dhparam.pem"ssl.ec-curve = "secp384r1" 启用 HSTS 1234server.modules += ( "mod_setenv" )$HTTP["scheme"] == "https" &#123; setenv.add-response-header = ( "Strict-Transport-Security" =&gt; "max-age=63072000; includeSubdomains; preload")&#125; 参考资料Lighttpd]]></content>
      <tags>
        <tag>http</tag>
        <tag>lighttpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn 常用操作命令]]></title>
    <url>%2F2017%2F03%2F29%2FGit%2Fsvn-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[检出123456$ svn checkout http://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn checkout svn://路径(目录或文件的全路径) [本地目录全路径] --username 用户名# 也可以使用缩写# 例子：$ svn co svn://localhost/测试工具 /home/testtools --username wzhnsc$ svn co http://localhost/test/testapp --username wzhnsc 注 ：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。 不指定本地目录全路径，则检出到当前目录下。 导出（导出一个干净的不带.svn文件夹的目录树）1234567$ svn export [-r 版本号] http://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn export [-r 版本号] svn://路径(目录或文件的全路径) [本地目录全路径] --username 用户名$ svn export 本地检出的(即带有.svn文件夹的)目录全路径 要导出的本地目录全路径# 例子：$ svn export svn://localhost/测试工具 /home/testtools --username wzhnsc$ svn export svn://localhost/test/testapp --username wzhnsc$ svn export /home/testapp /home/testtools 注 ：第一种从版本库导出干净工作目录树的形式是指定URL， ​ 如果指定了修订版本号，会导出相应的版本， ​ 如果没有指定修订版本，则会导出最新的，导出到指定位置。 ​ 如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。 ​ 第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留， ​ 但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。 添加新文件1234567$ svn add 文件名# 注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！# 例子：$ svn add test.php # 添加test.php $ svn commit -m "添加我的测试用test.php" test.php$ svn add *.php # 添加当前目录下所有的php文件$ svn commit -m "添加我的测试用全部php文件" *.php 提交12345678910$ svn commit -m "提交备注信息文本" [-N] [--no-unlock] 文件名$ svn ci -m "提交备注信息文本" [-N] [--no-unlock] 文件名# 必须带上-m参数，参数可以为空，但是必须写上-m# 例子：$ svn commit -m "提交当前目录下的全部在版本控制下的文件" * # 注意这个*表示全部文件$ svn commit -m "提交我的测试用test.php" test.php$ svn commit -m "提交我的测试用test.php" -N --no-unlock test.php # 保持锁就用–no-unlock开关$ svn ci -m "提交当前目录下的全部在版本控制下的文件" * # 注意这个*表示全部文件$ svn ci -m "提交我的测试用test.php" test.php$ svn ci -m "提交我的测试用test.php" -N --no-unlock test.php # 保持锁就用–no-unlock开关 更新文件123456789101112$ svn update$ svn update -r 修正版本 文件名$ svn update 文件名# 例子：# 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本$ svn update # 将版本库中的文件 test.cpp 还原到修正版本（revision）200$ svn update -r 200 test.cpp# 更新与版本库同步。提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。$ svn update test.php 删除文件123456789$ svn delete svn://路径(目录或文件的全路径) -m "删除备注信息文本"# 推荐如下操作：$ svn delete 文件名 $ svn ci -m "删除备注信息文本"# 例子：$ svn delete svn://localhost/testapp/test.php -m "删除测试文件test.php"# 推荐如下操作：$ svn delete test.php $ svn ci -m "删除测试文件test.php" 加锁 / 解锁12345$ svn lock -m "加锁备注信息文本" [--force] 文件名 $ svn unlock 文件名# 例子：$ svn lock -m "锁信测试用test.php文件" test.php $ svn unlock test.php 比较差异12345678$ svn diff 文件名 $ svn diff -r 修正版本号m:修正版本号n 文件名# 例子：# 将修改的文件与基础版本比较$ svn diff test.php # 对修正版本号200 和 修正版本号201 比较差异$ svn diff -r 200:201 test.php 查看文件或者目录状态123456789$ svn st 目录路径/名# 目录下的文件和子目录的状态，正常状态不显示.# 【?：不在svn的控制中； M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 $ svn status 目录路径/名 $ svn -v 目录路径/名# 显示文件和子目录状态# 【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】$ svn status -v 目录路径/名 注 ：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 查看日志1234$ svn log 文件名# 例子：# 显示这个文件的所有修改记录，及其版本号的变化$ svn log test.php 查看文件详细信息123$ svn info 文件名# 例子：$ svn info test.php SVN 帮助1234# 全部功能选项$ svn help# 具体功能的说明$ svn help ci 查看版本库下的文件和目录列表1234567$ svn list svn://路径(目录或文件的全路径)$ svn ls svn://路径(目录或文件的全路径)# 例子：$ svn list svn://localhost/test# 显示svn://localhost/test目录下的所有属于版本库的文件和目录$ svn ls svn://localhost/test 创建纳入版本控制下的新目录12345$ svn mkdir 目录名$ svn mkdir -m "新增目录备注文本" http://目录全路径# 例子：$ svn mkdir newdir$ svn mkdir -m "Making a new dir." svn://localhost/test/newdir 注 ： 添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败” 1$ svn update 注 ：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir， ​ 再用svn mkdir newsubdir命令后，SVN会提示： ​ svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？ ​ svn: 无法创建目录“hello”: 文件已经存在 此时，用如下命令解决： svn add --non-recursive newsubdir​ 在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录 ​ 再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令， ​ SVN提示： ​ svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’, ​ path ‘/newdir/newsubdir ‘ 恢复本地修改12345678$ svn revert [--recursive] 文件名# 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。# 例子：# 丢弃对一个文件的修改$ svn revert foo.c# 恢复一整个目录的文件，. 为当前目录$ svn revert --recursive . 把工作拷贝更新到别的URL1234$ svn switch http://目录全路径 本地目录全路径# 例子：# (原为123的分支)当前所在目录分支到localhost/test/456$ svn switch http://localhost/test/456 . 解决冲突12345678910111213$ svn resolved [本地目录全路径]# 例子：$ svn updateC foo.cUpdated to revision 31.# 如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：$ lsfoo.cfoo.c.minefoo.c.r30foo.c.r31# 当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。# 你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。 不checkout而查看输出特定文件或URL的内容1234567891011$ svn cat http://文件全路径# 例子：$ svn cat http://localhost/test/readme.txt# 新建一个分支copy# 从branchA拷贝出一个新分支branchB$ svn copy branchA branchB -m "make B branch" # 合并内容到分支merge# 把对branchA的修改合并到分支branchB$ svn merge branchA branchB]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 使用指南]]></title>
    <url>%2F2017%2F03%2F28%2FHexo%2Fhexo-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[安装、初始化和配置准备工作 git node.js github 安装和初始化首先确定已经安装好了 nodejs 和 npm 以及 git 12345$ npm install hexo -g$ hexo init blog$ cd blog$ npm install$ hexo server 访问http://localhost:4000，会看到生成好的博客。 主目录结构12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- themes|-- .gitignore|-- package.json _config.yml 全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。 package.json hexo框架的参数和所依赖插件，如下： 12345678910111213141516171819&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.2.0" &#125;, "dependencies": &#123; "hexo": "^3.2.0", "hexo-generator-archive": "^0.1.4", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.0", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.2.0", "hexo-renderer-stylus": "^0.3.1", "hexo-renderer-marked": "^0.2.10", "hexo-server": "^0.2.0" &#125;&#125; scaffold scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 _config.yml文件 _config.yml 采用YAML语法格式，具体语法自行学习 。具体配置可以参考官方文档，_config.yml 文件中的内容，并对主要参数做简单的介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: John Doe #作者language: #语言timezone: #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #你的站点Urlroot: / #站点的根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式 permalink_defaults: #永久链接中各部分的默认值# Directory source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹 archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #是否显示草稿post_asset_folder: false #是否启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章highlight: #内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 #分页数量pagination_dir: page # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: git #类型，常用的git repo: https://github.com/nanshanyi/nanshanyi.github.io.git #github仓库的地址 注意如果页面中出现中文，应以UTF-8无BOM编码格式，所以不要用win自带的记事本，而是用notepad++这种支持编码转换的编辑器。 由于google在天朝大陆被墙，进入 themes\landscape\layout\_partial ，打开 head.ejs ，删掉第31行 fonts.googleapis.com 的链接。 下载下来 jQuery-2.0.3.min.js ，放到 themes\landscape\source\js 文件夹中。之后进入 themes\landscape\layout\_partial ，打开 after-footer.ejs ，将第17行的路径替换为 /js/jquery-2.0.3.min.js 。 至此大功告成。 写文章&amp;草稿文章命令行输入： 1$ hexo new post "new article" 之后在 soource/_posts 目录下面多了一个 new-article.md 的文件。 文章属性 Setting Description Default layout Layout post或page title 文章的标题 date 穿件日期 文件的创建日期 updated 修改日期 文件的修改日期 comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字 文件名 toc 是否开启目录 true reward 是否开启打赏 true 分类和标签12345categories: - 日记tags: - Hexo - node.js 摘要&lt;!--more--&gt; 之上的内容为摘要。 草稿草稿相当于很多博客都有的“私密文章”功能。 1$ hexo new draft "new draft" 会在 source/_drafts 目录下生成一个 new-draft.md 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 _drafts 目录之中。 如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server： 1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面： 1234$ hexo publish [layout] &lt;filename&gt;eg:$ hexo publish drafts hexo-使用指南 Blog中出入图片和音乐文章推介：Hexo 博客中插入音乐/视频 ​ 使用七牛为Hexo存储图片 [hexo主题中添加相册功能](http://www.cnblogs.com/xljzlw/p/5137622.html)​ 为 Hexo 主题添加多种图片样式(主题不错考虑移植) ​ Hexo折腾记——基本配置篇 ​ hexo博客进阶－相册和独立域名 插入图片基本分为两种办法** ： （1） 放在本地文件 首先在根目录下确认 _config.yml 中有 post_asset_folder:true 。在 hexo 目录，执行： 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 之后再使用 hexo new &#39;new&#39;创建新博客的时候，会在 source/_posts 里面创建 .md 文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。使用的时候 123![“图片描述”（可以不写）](/文件夹名/你的图片名字.JPG)例如：！[ ] (new/text.jpg) （2）放在七牛上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。 插入音乐 ： 可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把 12&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32"&gt;&lt;/iframe&gt;//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐 代码高亮highlight.js支持highlightjs官网 highlightjs主题风格 其他Hexo，Yilia主题添加站内搜索功能 为Hexo博客添加目录 Hexo站点中添加文章目录以及归档 使用LeanCloud平台为Hexo博客添加文章浏览量统计组件 使用hexo搭建静态博客 Hexo Docs中文 ： （二）基本用法]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+webpack+vuejs 搭建开发环境学习套路]]></title>
    <url>%2F2017%2F03%2F27%2Fnodejs-webpack-vuejs-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[官方文档官方手册 中文官网 vuejs 2.0 中文文档 ECMAScript 6 入门 node.js相关的中文文档及教程 Node.js中文网API Webpack 中文指南 webpack2.2中文文档 以上是提供的一些官方资料，下面开始我们的套路吧： 环境构建1.新建一个目录vuepro2.初始化 1234$ cd vuepro# 初始化的时候可以一路回车，在最后输入"yes"后会生成package.json文件$ npm init 3.安装模块，先装这么多，有需要再安装 1$ npm install vue webpack babel-loader babel-core babel-preset-env babel-cli babel-preset-es2015 html-webpack-plugin --save-dev 4.创建良好的目录层级 12$ mkdir src$ cd src &amp;&amp; mkdir -p html jssrc webapp html放置模板文件，jssrc放置js文件，最终编译好的文件放置在webapp目录里，这个目录也就是我们网站的目录。 5.在项目根目录下创建webpack配置文件：webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738var HtmlWebpackPlugin = require('html-webpack-plugin');var webpack=require("webpack");module.exports =&#123; entry: &#123; //入口文件 "index":__dirname+'/src/jssrc/index.js', &#125;, output: &#123; path: __dirname+'/src/webapp/js', //输出文件夹 filename:'[name].js' //最终打包生成的文件名(只是文件名，不带路径的哦) &#125;, /*resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;,*/ externals: &#123; &#125;, module:&#123; loaders:[ &#123;test:/\.js$/,loader:"babel-loader",query:&#123;compact:true&#125;&#125;, //这里肯定要加入n个loader 譬如vue-loader、babel-loader、css-loader等等 ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; filename: __dirname+'/src/webapp/index.html', //目标文件 template: __dirname+'/src/html/index.html', //模板文件 inject:'body', hash:true, //代表js文件后面会跟一个随机字符串,解决缓存问题 chunks:["index"] &#125;) ]&#125; 6.同样在根目录下创建babel配置文件：.babelrc 123&#123; &quot;presets&quot; : [&quot;es2015&quot;]&#125; 然后就可以在webpack里面配置loader，我们上面webpack配置中已经写了： 1234loaders:[ &#123;test:/\.js$/,loader:"babel-loader",query:&#123;compact:true&#125;&#125;, // 经过测试旧版用的是loader:"babel",在新版中用的是loader:"babel-loader" ] 这句话意思就是：凡是 .js 文件都使用 babel-loader , 并且压缩。 学习vue最简单的一个套路思考：数据如何渲染？ 套路如下： 首先要有个数据块标记 vue里面可以像模板引擎一样写上 {\{name\}} 其中 name 就是变量名 接下来进行实战练习 index.htm l如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="me"&gt; 我的年龄是&#123;age&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.js 如下： 123456import Vue from "vue"; //会去node_modules\vue\package.jsonnew Vue(&#123; el:"#me", data:&#123;age:18&#125;&#125;) 至此，我们需要用 webpack 打包，打包到 webapp 目录下。 需要修改2个地方： (1)因为我们的 webpack 不是全局安装的，所以不能直接执行 webpack 命令，我们这里借助 npm 来执行。所以需要修改项目根目录下的 package.json 文件，加入： 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack"&#125;, 表示：执行build，就会去node_modules.bin\下去寻找webpack命令。build 这个名字是自定义的。 (2)还需要修改 webpack 配置文件：webpack.config.js 12345resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;, 我们之前把这个注释掉了，现在打开。此处的意义是找到 node_modules/vue/dist/vue.js 最后，我们就来打包，看看结果是怎样的？ 终端里还是cd到项目根目录下，执行： 1$ npm run build index.html 就是打包之后的模板文件，js/index.js 就是打包之后的js文件，在 index.html 被引用了。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="me"&gt; 我的年龄是&#123;age&#125; &lt;/div&gt;&lt;script type="text/javascript" src="js/index.js?43c73980e35f1569ef72"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预览一下index.html: 这样就完成了 vueJS 的一个简单案列]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github 博客多终端同步]]></title>
    <url>%2F2017%2F03%2F20%2FHexo%2FHexo-Github-%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[原文链接 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。下面是详细的步骤讲解： 1. 准备条件安装了Node.js,Git,Hexo环境完成Github与本地Hexo的对接这部分大家可以参考史上最详细的Hexo博客搭建图文教程 配置好这些，就可以捋起袖子大干一场了！ 2. 在其中一个中单操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示： 123456789101112131415161718# 初始化本地仓库$ git init# 将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件$ git add source$ git commit -m "Blog Source Hexo"# 新建hexo分支$ git branch hexo# 切换到hexo分支上$ git checkout hexo# 将本地与Github项目对接$ git remote add origin https://github.com/yourname/yourname.github.io.git# push到Github项目的hexo分支上$ git push origin hexo 这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。 3. 另一终端完成clone和push更新此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置 123456789101112131415161718192021222324# 将Github中hexo分支clone到本地$ git clone -b hexo https://github.com/yourname/yourname.github.io.git# 切换到刚刚clone的文件夹内$ cd yourname.github.io# cheackout 远程代码到本地hexo分支$ git checkout -b hexo origin/hexo# 注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init$ npm install# 新建一个.md文件，并编辑完成自己的博客内容$ hexo new post "new blog name"# 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客$ git add source$ git commit -m "XX"# 更新分支$ git push origin hexo# push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master$ hexo d -g 4. 不同终端间愉快地玩耍在不同的终端已经做完配置，就可以愉快的分享自己更新的博客进入自己相应的文件夹 123456789101112# 先pull完成本地与远端的融合$ git pull origin hexo$ hexo new post " new blog name"$ git add source$ git commit -m "XX"$ git push origin hexo$ hexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Git Submodule管理子模块]]></title>
    <url>%2F2017%2F01%2F29%2FGit%2Fgit-submodule%2F</url>
    <content type="text"><![CDATA[【Git】子模块：一个仓库包含另一个仓库 如何在大型项目中使用Git子模块开发 git子模块 到目前为止,将您的大项目分解为子项目.现在使用以下命令将每个子项目添加到主项目： 1$ git submodule add &lt;url&gt; 项目添加到您的仓库后,您必须初始化并更新它. 12$ git submodule init$ git submodule update 从Git 1.8.2开始,新选项 –remote 被添加 1$ git submodule update --remote --merge 将从每个子模块的上游获取最新的更改,将它们合并,并检查子模块的最新版本. 使用场景基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，但是这个library怎么和git在一起方便管理呢？ 我们需要解决下面几个问题： 如何在git项目中导入library库? library库在其他的项目中被修改了可以更新到远程的代码库中? 其他项目如何获取到library库最新的提交? 如何在clone的时候能够自动导入library库? 解决以上问题，可以考虑使用git的 Submodule来解决。 什么是Submodule?git Submodule 是一个很好的多项目使用共同类库的工具，他允许类库项目做为repository,子项目做为一个单独的git项目存在父项目中，子项目可以有自己的独立的commit，push，pull。而父项目以Submodule的形式包含子项目，父项目可以指定子项目header，父项目中会的提交信息包含Submodule的信息，再clone父项目的时候可以把Submodule初始化。 在项目中使用Submodule使用git命令可以直接添加Submodule： 1$ git submodule add git@github.com:xxx.git pod-library 使用 git status命令可以看到 1$ git status 12345On branch masterChanges to be committed: new file: .gitmodules new file: pod-library 可以看到多了两个需要提交的文件：.gitmodules和 pod-library .gitmodules 内容包含Submodule的主要信息，指定reposirory,指定路径: 123[submodule &quot;pod-library&quot;] path = pod-library url = git@github.com:xxx/pod-library.git 可以看到记录了子项目的目录和子项目的git地址信息。 pod-libray内容只保护子项目的commit id，就能指定到对于的git header上,例如: 1Subproject commit 4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5 4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5就是子项目的commit id，父项目的git并不会记录Submodule的文件变动，它是按照commit git指定Submodule的git header。 另外,这两个文件都需要提交到父项目的git中。 还可以这样使用命令添加Submodule 123$ git add .gitmodules pod-ibrary$ git commit -m "pod-library submodule"$ git submodule init 修改Submodule首先需要确认有对Submodule的commit权限。 进入Submodule目录里面: 1$ cd pod-library/ 修改其中的一个文件看下文件的可以用git status查看变动: 12$ git statusmodified: pod-library/UseAFHTTP.h 提交Submodule的更改内容： 1$ git commit -a -m'test submodule' 然后push 到远程服务器: 1$ git push 然后再回到父目录,提交Submodule在父项目中的变动： 1234$ cd ..$ git statuson branch mastermodified: pod-library (new commits) 可以看到pod-library中已经变更为Submodule最新的commit id: 1Subproject commit 330417cf3fc1d2c42092b20506b0d296d90d0b5f 需要把Submodule的变动信息推送到父项目的远程服务器 12$ git commit -m'update submodule'$ git push 这样就把子模块的变更信息以及子模块的变更信息提交到远程服务器了，从远程服务器上更新下来的内容就是最新提交的内容了。 更新Submodule更新Submodule有两种方式: 在父项目的目录下直接运行 1$ git submodule foreach git pull 在Submodule的目录下面更新 12$ cd pod-library$ git pull 可以看到在Submodule的目录中,使用git和单独的一个项目是一样的,注意更新Submodule的时候如果有新的commit id产生，需要在父项目产生一个新的提交，pod-libray文件中的 Subproject commit会变为最新的commit id。 clone Submoduleclone Submodule有两种方式 一种是采用递归的方式clone整个项目，一种是clone父项目，再更新子项目。 采用递归参数 --recursive 1$ git clone git@github.com:xxx.git --recursive 输出结果： 123456789101112131415161718loning into &apos;pod-project&apos;...remote: Counting objects: 57, done.remote: Compressing objects: 100% (45/45), done.remote: Total 57 (delta 13), reused 49 (delta 8), pack-reused 0Receiving objects: 100% (57/57), 18.79 KiB | 0 bytes/s, done.Resolving deltas: 100% (13/13), done.Checking connectivity... done.Submodule &apos;pod-library&apos; (git@github.com:xxx.git) registered for path &apos;pod-library&apos;Cloning into &apos;pod-library&apos;...remote: Counting objects: 34, done.remote: Compressing objects: 100% (25/25), done.remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.Resolving deltas: 100% (8/8), done.Checking connectivity... done.Submodule path &apos;pod-library&apos;: checked out &apos;330417cf3fc1d2c42092b20506b0d296d90d0b5f&apos; 可以看到init Submodule 会自动被clone下来 第二种方法先clone父项目，再初始化Submodule 123$ git clone git@github.com:xxx/pod-project.git$ cd pod-project$ git submodule init 输出: 12Submodule &apos;pod-library&apos; (git@github.com:xxx/pod-library.git) registered for path &apos;pod-library&apos; 更新Submodule: 1$ git submodule update 运行结果： 12345678Cloning into &apos;pod-library&apos;...remote: Counting objects: 34, done.remote: Compressing objects: 100% (25/25), done.remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.Resolving deltas: 100% (8/8), done.Checking connectivity... done.Submodule path &apos;pod-library&apos;: checked out &apos;330417cf3fc1d2c42092b20506b0d296d90d0b5f&apos; 删除Submodulegit 并不支持直接删除Submodule需要手动删除对应的文件: 1234$ cd pod-project$ git rm --cached pod-library$ rm -rf pod-library$ rm .gitmodules 更改git的配置文件config: 1$ vim .git/config 可以看到Submodule的配置信息： 12[submodule &quot;pod-library&quot;] url = git@github.com:xxx/pod-library.git 删除submodule相关的内容,然后提交到远程服务器: 1$ git commit -a -m 'remove pod-library submodule']]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令清单]]></title>
    <url>%2F2017%2F01%2F27%2FGit%2Fgit-common-list%2F</url>
    <content type="text"><![CDATA[我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]二、配置Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot;三、增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]四、代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...五、分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]六、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]七、查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog八、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all九、撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop十、其他# 生成一个可供发布的压缩包 $ git archive]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用规范流程]]></title>
    <url>%2F2017%2F01%2F27%2FGit%2Fgit-using-standard-process%2F</url>
    <content type="text"><![CDATA[团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。 下面是ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。 第一步：新建分支首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考《Git分支管理策略》）。 # 获取主干最新代码 $ git checkout master $ git pull # 新建一个开发分支myfeature $ git checkout -b myfeature第二步：提交分支commit分支修改后，就可以提交commit了。 $ git add --all $ git status $ git commit --verbosegit add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。 git status 命令，用来查看发生变动的文件。 git commit 命令的 verbose 参数，会列出 diff 的结果。 第三步：撰写提交信息提交commit时，必须给出完整扼要的提交信息，下面是一个范本。 Present-tense summary under 50 characters * More information about commit (under 72 characters). * More information about commit (under 72 characters). http://project.management-system.com/ticket/123第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。 第四步：与主干同步分支的开发过程中，要经常与主干保持同步。 $ git fetch origin $ git rebase origin/master第五步：合并commit分支开发完成后，很可能有一堆 commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。 那么，怎样才能将多个 commit 合并呢？这就要用到 git rebase 命令。 $ git rebase -i origin/mastergit rebase 命令的 i 参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。 pick 07c5abd Introduce OpenPGP and teach basic usage pick de9b1eb Fix PostChecker::Post#urls pick 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend # Rebase 8db7e8b..fa20af3 onto 8db7e8b # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out上面的互动界面，先列出当前分支最新的4个 commit（越下面越新）。每个 commit 前面有一个操作命令，默认是 pick，表示该行 commit 被选中，要进行 rebase 操作。 4个commit的下面是一大堆注释，列出可以使用的命令。 pick：正常选中 reword：选中，并且修改提交信息； edit：选中，rebase时会暂停，允许你修改这个commit（参考这里） squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令 上面这6个命令当中，squash 和 fixup 可以用来合并 commit。先把需要合并的 commit 前面的动词，改成 squash（或者s）。 pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls s 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。 # This is a combination of 3 commits. # The first commit&apos;s message is: Introduce OpenPGP and teach basic usage # This is the 2nd commit message: Fix PostChecker::Post#urls # This is the 3rd commit message: Hey kids, stop all the highlighting如果将第三行的 squash 命令改成 fixup 命令。 pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls f 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。 # This is a combination of 3 commits. # The first commit&apos;s message is: Introduce OpenPGP and teach basic usage # This is the 2nd commit message: Fix PostChecker::Post#urls # This is the 3rd commit message: # Hey kids, stop all the highlightingPony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。 $ git reset HEAD~5 $ git add . $ git commit -am &quot;Here&apos;s the bug fix that closes #28&quot; $ git push --forcesquash 和 fixup 命令，还可以当作命令行参数使用，自动合并commit。 $ git commit --fixup $ git rebase -i --autosquash 这个用法请参考http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html，这里就不解释了。 第六步：推送到远程仓库合并commit后，就可以推送当前分支到远程仓库了。 $ git push --force origin myfeaturegit push 命令要加上 force 参数，因为 rebase 以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送。 第七步：发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review，确认可以合并到 master。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 学习笔记]]></title>
    <url>%2F2016%2F12%2F23%2FDocker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Docker基本命令常用Docker命令 1234567891011121314151617181920# 开启Docker守护进程调试模式$ sudo docker daemon -D# 查看Docker信息$ sudo docker info # 停止或者启动Docker$ sudo service docker stop/start # 以命令行模式运行一个容器$ sudo docker run -i -t ubuntu /bin/bash # 给容器命名$ sudo docker run --name Micheal_container -i -t ubuntu /bin/bash# 启动或者停止运行的容器$ sudo docker start/stop Micheal_container # 附着到正在运行的容器$ sudo docker attach Micheal_container 创建守护式容器 1$ sudo docker run --name daemon_dave -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done" 上面的docker run 使用了-d参数，因此Docker会将容器放到后台运行。 Docker日志 1234567891011121314# 获取守护式容器的日志$ sudo docker logs daemon_dave# 跟踪守护式容器的日志$ sudo docker logs -f daemon_dave# 获取日志的最后10行$ sudo docker logs --tail 10 daemon_dave # 跟踪某个容器的最新日志$ sudo docker logs --tail 0 -f daemon_dave# -t 标志为每条日志项加上时间戳$ sudo docker logs -ft daemon_dave Docker日志驱动 1$ sudo docker run --log-driver="syslog" --name daemon_dave -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done" 使用syslog将会禁用docker logs命令，并且将所有容器的日志输出都重定向到Syslog。 查看容器内的进程 1$ sudo docker top daemon_dave Docker统计信息 1$ sudo docker stats daemon_dave daemon_kate daemon_clear daemon_sarah 以上命令可以看到一个守护容器的列表，以及他们的CPU、内存、网络I/O以及存储I/O的性能和指标。这对快速监控一台主机上的一组容器非常有用。 在容器内部运行进程 1$ sudo docker exec -d daemon_dave touch /etc/new_config_file -d表示需要运行一个后台进程 12# 在容器内运行交互命令$ sudo docker exec -t -i daemon_dave /bin/bash 自动重启容器 1$ sudo docker run --restart=always --name daemon_dave -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done" --restart标志被设置为always。无论容器的退出代码是什么，Docker都会自动重启改容器。除了always，还可以将这个标志设为on-failure，这样，只有当容器的退出代码为非0值的时候，才会自动重启。另外，on-failure还接受一个可选的重启次数参数，--restart=on-failure:5,Docker会尝试自动重启改容器，最多重启5次。 深入容器 1$ sudo docker inspect daemon_dave docker inspect命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置以及很多有用的数据。可以使用-f或者--format标志来选定查看结果。 1$ sudo docker inspect --format='&#123;.State.Running&#125;' daemon_dave 查看多个容器 1$ sudo docker inspect --format '&#123;.Name&#125; &#123;.State.Running&#125;' daemon_dave Micheal_container 删除容器​ 1234$ sudo docker rm daemon_dave# 删除所有容器$ sudo docker rm `sudo docker ps -a -q` 列出所有镜像 1$ sudo docker images 拉去镜像 1$ sudo docker pull ubuntu:16.04 运行一个带标签的Docker镜像 1$ sudo docker run -i -t --name new_container ubuntu:16.04 /bin/bash 查找镜像 1$ sudo docker search puppet 构建镜像 使用docker commit命令 使用docker build命令和Dockerfile文件 用Docker的commit命令创建镜像 123456789101112131415$ sudo docker run -i -t ubuntu /bin/bash# 接下来安装需要安装的工具，安装完成后exit退出容器, eg：$ apt-get -yqq update$ apt-get -y install apache2# 指定提交修改过的容器的ID（可以通过docker ps -l -q命令得到刚创建的容器的ID）$ sudo docker commit 4aab3cecb76 micheal/apache2 # 检查新创建的镜像sudo docker images micheal/apache2 # 提交另一个新定制容器# -m 选项用来指定新创建的镜像的提交信息，-a 用来列出该镜像的作者信息。$ sudo docker commit -m"A new custom image" -a"Micheal" 4aab3cecb76 micheal/apache2:webserver 用Dockerfile构建镜像 Dockerfile文件示例： 123456# Vsersion: 0.0.1FROM ubuntu:16.04MAINTAINER Micheal "miaopei@baicells.com"RUN apt-get -yqq update &amp;&amp; apt-get -y install nginxRUN echo 'Hi, I an in your container' &gt; /usr/share/nginx/html/index.htmlEXPOSE 80 Dockerfile中的指令会按照顺序从上到下执行，所以根据需要合理安排指令的顺序。 如果Dockerfile由于某些原因没有正常结束，那么用户得到了一个可以使用的镜像。这对调试非常有帮助：可以基于改镜像运行一个具备交互功能的容器，使用最后创建的镜像对为什么用户指令会失败进行调试。 每个Dockerfile的第一条指令必须是FROM,FROM指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，这个镜像被称为基础镜像。 MAINTAINER指令告诉Docker镜像的作者是谁，以及作者的电子邮件。有助于标识镜像的所有者和联系方式。 默认情况下，RUN指令会在shell里使用命令包装器/bin/sh -c来执行，如果是在一个不支持shell的平台上运行或者不希望在shell中运行（比如避免shell字符串篡改），也可以使用exec格式的RUN指令，如下所示： 1RUN [ "apt-get", " install", "-y", "nginx" ] EXPOSE指令告诉Docker该容器内的应用程序将会使用该容器的指定端口。 基于Dockerfile构建新镜像 12345678$ sudo docker build -t="micheal/static_web" .$ sudo docker build -t="micheal/static_web:v1" .# 这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件$ sudo docker build -t="micheal/static_web:v1" git@github.com:micheal/docker_static_web # 忽略Dockerfile的构建缓存$ sudo docker build --no-cache -t="micheal/static_web" . 查看镜像 1234567# 列出Docker镜像$ sudo docker images# 查看镜像每一层，以及创建这些层的Dockerfile指令$ sudo docker history micheal/static_web $ sudo docker run -d -p 80 --name statix_web micheal/static_web nginx -g "daemon off;" nginx -g “daemon off;”,这将以前台的方式启动Nginx。 -p标志用来控制Docker在运行时应该公开那些网络端口给外部（宿主机）。运行一个容器时，Docker可以通过两种方式来在宿主机上分配端口。 Docker可以在宿主机上随机选择一个位于32768 ~ 61000的一个比较大的端口号来映射到容器中的80端口上。 可以在Docker宿主机只指定一个具体的端口号来映射到容器中的80端口上。 查看Docker端口映射情况 1234567$ sudo docker ps -l# 返回宿主机中映射的端口$ sudo socker port static_web 80 # -p会将容器内的80端口绑定到宿主机的8080端口上$ sudo docker run -d -p 8080:80 --name statix_web micheal/static_web nginx -g "daemon off;" Dockerfile指令 CMD CMD指令用于指定一个容器启动时要运行的命令。这有点儿类似于RUN指令，只是RUN指令是指定容器镜像被构建时要运行的命令，而CMD是指定容器被启动时要运行的命令。 1CMD ["/bin/bash/", "-l"] ENTRYPOINT ENTRYPOINT和CMD指令非常类似，我们可在docker run命令行中覆盖CMD指令，而ENTRYPOINT指令提供的命令则不容易在启动容器的时候被覆盖。 可以组合使用ENTRYPOINT和CMD指令来完成一些巧妙的工作。 12ENTRYPOINT ["/usr/sbin/nginx"]CMD ["-h"] WORKDIR WORKDIR指令用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，ENTRYPOINT和/或CMD指定的程序会在这个目录下执行。 1234WORKDIR /opt/webapp/dbRUN bundle installWORKDIR /opt/webappENTRYPOINT ["rackup"] 可以通过-w标志在运行时覆盖工作目录 1$ sudo docker run -ti -w /var/log ubuntu pwd/var/log ENV ENV指令用来在镜像构建过程中设置环境变量。这些变量会持久保存到从我们镜像创建的任何容器中。 1ENV RVM_PATH /home/rvm 也可以使用docker run命令行的-e标志来传递环境变量。这些环境变量只会在运行时有效。 1$ sudo docker run -ti -e "WEB_PORT=8080" ubuntu env USER USER指令用来指定该镜像会以什么样的用户身份来运行。我们可以指定用户名或者UID以及组或GID，甚至是两者的组合。 123456USER userUSER user:groupUSER uidUSER uid:gidUSER user:gidUSER uid:group 也可以在docker run命令行中通过-u标志覆盖该指令指定的值。 VOLUME VOLUME指令用来向基于镜像创建的容器添加卷。一个卷可以存在于一个或者多个容器内特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能。 卷可以在容器间共享和重用 一个容器可以不是必须和其他容器共享卷 对卷的修改是立即生效的 对卷的修改不会对更新镜像产生影响 卷会一直存在直到没有任何容器再使用它 卷功能让我们可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许我们在多个容器间共享这些内容，我们可以利用此功能来测试容器和内部应用程序代码，管理日志，或者处理容器内部的数据库。 1VOLUME ["/opt/project"] 这条指令将会基于此镜像的任何容器创建一个名为/opt/project的挂载点。 也可以通过指定数组的方式指定多个卷 1VOLUME ["/opt/project", "/data"] ADD ADD指令用来将构建环境下的文件和目录复制到镜像中。不能对构建目录或者上下文之外的文件进行ADD操作。 12ADD software.lic /opt/application/software.licADD latest.tar.gz /var/www/wordpress/ //这条指令会将归档文件解开到指定的目录下 COPY COPY指令非常类似ADD，它们根本不同是COPY只关心构建上下文中复制本地文件，而不会去做文件提取（extraction）和解压（decompression）的工作。 1COPY conf.d/ /etc/apache2/ LABEL LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现 12LABEL version="1.0"LABEL location="New York" type="Data Center" role="Web Server" 可以使用docker inspect命令查看容器标签 1$ sudo docker inspect micheal/apache2 STOPSIGNAL STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器。 ARG ARG指令用来定义可以在docker build命令运行时传递给构建运行时的变量，我们只需要在构建时使用–build-arg标志即可。用户只能在构建时指定在Dockerfile文件汇总定义过的参数。 1234ARG buildARG webapp_user=user$ docker build --build-arg build=1234 -t micheal/webapp . ONBUILD ONBUILD指令能为镜像添加触发器（trigger）。当一个镜像被用做其他镜像的基础镜像时（比如用户的镜像需要从某未准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本），该镜像中的触发器将会被执行。 触发器会在构建过程中插入新指令，我们可以认为这些指令是紧跟在FROM之后指定的。触发器可以是任何构建指令。 12ONBUILD ADD . /app/srcONBUILD RUN cd /app/src/ &amp;&amp; make 上面的代码将会在创建的镜像中加入ONBUILD触发器，ONBUILD指令可以在镜像上运行docker inspect命令查看。 Docker Networking 容器之间的连接用网络创建，这被称为Docker Networking。Docker Networking允许用户创建自己的网络，容器可以通过这个网上互相通信。更重要的是，现在容器可以跨越不同的宿主机来通信，并且网络配置可以更灵活的定制。Docker Networking也和Docker Compose以及Swarm进行了集成。 要想使用Docker网络，需要先创建一个网络，然后在这个网络下启动容器。 1$ sudo docker network create app 这里使用docker network命令创建了一个桥接网络，命名为app。可以使用docker network inspect命令查看新创建的这个网络。 1$ sudo docker network inspect app 我们可以看到这个新网络是一个本地的桥接网络（这非常像docker0网络），而且现在没有容器再这个网络中运行。 可以使用docker network ls命令列出当前系统中所有的网络。 1$ sudo docker network ls 也可以使用 docker network rm命令删除一个Docker网络。 在Docker网络中创建Redis容器 1$ sudo docker run -d --net=app --name db micheal/redis --net标志指定了新容器将会在那个网络中运行。 1$ sudo docker network inspect app 将已有容器连接到Docker网络 1$ sudo docker network connect app db2 可以通过docker network disconnect 命令断开一个容器与指定网络的连接 1$ sudo docker network disconnect app db2 通过Docker链接连接容器 启动一个Redis容器 1$ sudo docker run -d --name redis micheal/redis 注意：这里没有公开容器的任何端口。一会就能看到这么做的原因。 链接Redis容器 1$ sudo docker run -p 4567 --name webapp --link redis:db -t -i -v $PWD/webapp_redis:/opt/webapp micheal/sinatra /bin/bash 这个命令做了不少事情，我们逐一解释。首先，我们使用-p标志公开4567端口，这样就能从外面访问web应用程序。 我们还使用--name标志给容器命名为webapp，并且使用了-v标志把web应用程序目录作为卷挂载到了容器里。 然而，这次我们使用了一个新标志--link。--link标志创建了两个容器间的客户-服务链接。这个标志需要两个参数：一个是要链接的容器的名字，另一个是链接的别名。这个例子中我们创建了客户联系，webapp容器是客户，redis容器是“服务”，并且为这个服务增加了db作为别名。这个别名让我们可以一致地访问容器公开信息，而无须关注底层容器的名字。链接让服务容器有能力与客户容器通信，并且能分享一些连接细节，这些细节有助于在应用程序中配置并使用这个链接。 连接也能得到一些安全上的好处。注意，启动 Redis 容器时，并没有使用-p标志公开Redis的端口。因为不需要这么做。通过把容器链接在一起，可以让客户直接访问任意服务容器的公开端口（即客户webapp容器可以连接到服务redis容器的6379端口）。更妙的是，只有使用--link标志链接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，现在我们已经拥有一个非常安全的模型。通过这个安全模型，就可以限制容器化应用程序被攻击面，减少应用暴露的网络。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题个性化设置]]></title>
    <url>%2F2016%2F12%2F23%2FHexo%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hexo + GitHub (Coding) Pages 搭建博客 Hexo的Next主题个性化设置（一）——基础设置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++设计模式(李建忠视频笔记)]]></title>
    <url>%2F2016%2F07%2F16%2FProgram-C%2FC%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%8E%E5%BB%BA%E5%BF%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[【设计模式】C++设计模式（全26讲） 设计模式的软件处理的核心：抽象稳定，隔离变化。实现可扩展、灵活、低耦合、稳定的框架。 设计模式简介目标： 理解松耦合设计思想 掌握面向对象设计原则 掌握重构技法改善设计 掌握GOF 核心设计模式 什么是设计模式 “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。——Christopher Alexander 从面向对象谈起底层思维：向下，如何把握机器底层从微观理解对象构造 语言构造 编译转换 内存模型 运行时机制 抽象思维：向上，如何将我们的周围世界抽象为程序代码 面向对象 组件封装 设计模式 架构模式 深入理解面向对象向下：深入理解三大面向对象机制 封装，隐藏内部实现 继承，复用现有代码 多态，改写对象行为 向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计” 软件设计固有的复杂性 建筑商从来不会去想给一栋已建好的100层高的楼房底下再新修一个小地下室——这样做花费极大而且注定要失败。然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。 ——Object-Oriented Analysis and Design with Applications 软件设计复杂的根本原因变化 客户需求的变化 技术平台的变化 开发团队的变化 市场环境的变化 …… 如何解决复杂性？分解 人们面对复杂性有一个常见的做法：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题。 抽象 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。 结构化 VS. 面向对象 软件设计的目标什么是好的软件设计？软件设计的金科玉律：复用！ 面向对象设计原则面向对象设计，为什么？变化是复用的天敌！面向对象设计最大的优势在于：抵御变化！ 重新认识面向对象理解隔离变化 从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小 各司其职 从微观层面来看，面向对象的方式更强调各个类的“责任” 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责 对象是什么？ 从语言实现层面来看，对象封装了代码和数据。 从规格层面讲，对象是一系列可被使用的公共接口。 从概念层面讲，对象是某种拥有责任的抽象。 面向对象设计原则 依赖倒置原则（DIP） 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。 开放封闭原则（OCP） 对扩展开放，对更改封闭。 类模块应该是可扩展的，但是不可修改。 单一职责原则（SRP） 一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 Liskov 替换原则（LSP） 子类必须能够替换它们的基类(IS-A)。 继承表达类型抽象。 接口隔离原则（ISP） 不应该强迫客户程序依赖它们不用的方法。 接口应该小而完备。 优先使用对象组合，而不是类继承 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则只要求被组合的对象具有良好定义的接口，耦合 度低。 封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合。 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的 接口。 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。 面向接口设计产业强盛的标志：接口标准化! 将设计原则提升为设计经验 设计习语 Design Idioms Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 设计模式 Design Patterns Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 架构模式 Architectural Patterns Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。 GOF-23 模式分类从目的来看： 创建型（Creational）模式：将对象的部分创建工作延迟到子 类或者其他对象，从而应对需求变化为对象创建时具体类型实 现引来的冲击。 结构型（Structural）模式：通过类继承或者对象组合获得更灵 活的结构，从而应对需求变化为对象的结构带来的冲击。 行为型（Behavioral）模式：通过类继承或者对象组合来划分 类与对象间的职责，从而应对需求变化为多个交互的对象带来 的冲击。 从范围来看： 类模式处理类与子类的静态关系。 对象模式处理对象间的动态关系。 从封装变化角度对模式分类 组件协作： Template Method – 模板方法 Observer / Event – 观察者模式 Strategy – 策略模式 单一职责： Decorator – 装饰器模式 Bridge – 桥接模式 对象创建: Factory Method – 工厂方法 Abstract Factory – 抽象工厂 Prototype – 原型模式 Builder – 构建器模式 – 目前已经用的不多 对象性能： Singleton – 单件模式 Flyweight – 享元模式 接口隔离: Façade – 门面模式 Proxy – 代理模式 Mediator – 中介者模式 – 目前已经用的不多 Adapter – 适配器模式 状态变化： Memento – 备忘录模式 – 目前已经用的不多 State – 状态模式 数据结构： Composite – 组合模式 Iterator – 迭代器模式 – 目前已经用的不多 Chain of Resposibility – 职责链模式 – 目前已经用的不多 行为变化： Command – 命令行模式 – 目前已经用的不多 Visitor – 访问器模式 – 目前已经用的不多 领域问题： Interpreter – 解析器模式 – 目前已经用的不多 重构获得模式 Refactoring to Patterns 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对 象设计”指是那些可以满足 “应对变化，提高复用”的设计 。 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “寻找变化点，然后在变化点处应用设计模式，从而来更好地应对 需求的变化”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计 模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。 重构关键技法 静态 –&gt; 动态 早绑定 –&gt; 晚绑定 继承 –&gt; 组合 编译时依赖 –&gt; 运行时依赖 紧耦合 –&gt; 松耦合 Template Method 模板方法模式“组件协作” 模式: 现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。 典型模式 Template Method Observer / Event Strategy 动机（Motivation） 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？ 模式定义 定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化) 到子类中。Template Method使得子类可以不改变 (复用) 一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。 ——《设计模式》GoF 结构（Structure） 要点总结 Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本 实现结构。 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。 示例示例 code 12 Strategy 策略模式“组件协作” 模式: 现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。 典型模式 Template Method Observer / Event Strategy 动机（Motivation） 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？ 模式定义 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。 ——《设计模式》GoF 结构（Structure） 要点总结 Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。 Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。 示例示例 code 12 Observer 观察者模式“组件协作” 模式: 现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。 典型模式 Template Method Observer / Event Strategy 动机（Motivation） 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。 模式定义 定义对象间的一种一对多（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 ——《设计模式》GoF 结构（Structure） 要点总结 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。 观察者自己决定是否需要订阅通知，目标对象对此一无所知。 Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。 示例示例 code 12 Decorator 装饰模式 – 继承和组合同时使用“单一职责” 模式: 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。 典型模式 Decorator Bridge 动机（Motivation） 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？ 模式定义 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。 ——《设计模式》GoF 结构（Structure） 要点总结 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。 Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。 Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。 示例示例 code 12 Bridge 桥模式“单一职责” 模式: 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。 典型模式 Decorator Bridge 动机（Motivation） 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度， 乃至多个纬度的变化。 如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？ 模式定义 将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。 ——《设计模式》GoF 结构（Structure） 要点总结 Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。 Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。 Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。 示例示例 code 12 Factory Method工厂方法“对象创建” 模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 典型模式 Factory Method Abstract Factory Prototype Builder 动机（Motivation） 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？ 模式定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。 ——《设计模式》GoF 结构（Structure） 要点总结 Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。 Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。 Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。 示例示例 code 12 Abstract Factory 抽象工厂“对象创建” 模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 典型模式 Factory Method Abstract Factory Prototype Builder 动机（Motivation） 在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？ 模式定义 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。 ——《设计模式》GoF 结构（Structure） 要点总结 如果没有应对“多系列对象构建”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。 “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。 Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。 示例示例 code 12 Prototype 原型模式“对象创建” 模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 典型模式 Factory Method Abstract Factory Prototype Builder 动机（Motivation） 在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。 如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？ 模式定义 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。——《设计模式》GoF 结构（Structure） 要点总结 Prototype 模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求“易变类”拥有“稳定的接口”。 Prototype 模式对于“如何创建易变的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活的动态创建“拥有某些稳定接口”的新对象——所需工作仅仅时注册一个新类的对象（即原型），然后在任何需要的地方Clone。 Prototype 模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。 示例示例 code 12 Builder 构建器“对象创建” 模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 典型模式 Factory Method Abstract Factory Prototype Builder 动机（Motivation） 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？ 模式定义 将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。 ——《设计模式》GoF 结构（Structure） 要点总结 Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 “分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) 。 示例示例 code 12 Singleton 单件模式“对象性能” 模式 面向对象很好的解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。 典型模式 Singleton Flyweight 动机（Motivation） 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？ 这应该是类设计者的责任，而不是使用者的责任。 模式定义 保证一个类仅有一个实例，并提供一个该实例的全局访问点。——《设计模式》GoF 结构（Structure） 要点总结 Singleton 模式中的实例构造器可以设置为 protected 以允许子类派生。 Singleton 模式一般不要支持拷贝构造和 Clone 接口，因为这有可能导致多个对象实例，与 Singleton模式的初衷违背。 如何实现多线程环境下安全的 Singleton？ 注意对双检查锁的正确实现。 示例示例 code 12 Flyweight 享元模式“对象性能” 模式 面向对象很好的解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。 典型模式 Singleton Flyweight 动机（Motivation） 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行是代价——主要指内存需求方面的代价。 如何在避免大量细粒度对象问题的同时，让外部客户程序任然能够透明地使用面向对象的方式来进行操作？ 模式定义 运用共享技术有效地支持大量细粒度的对象。——《设计模式》GoF 结构（Structure） 要点总结 面向对象很好的解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight 主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。 Flyweight 采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。 示例示例 code 12 Facade 门面模式“接口隔离” 模式 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。 典型模式 Facade Proxy Adapter Mediator 系统间耦合的复杂度 动机（Motivation） 上述A方案的问题在于组件的客户和组件各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？ 模式定义 为子系统的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF 结构（Structure） 要点总结 从客户程序的角度来看，Facade 模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种 “解耦” 的效果——内部子系统的任何变化不会影响到 Facade 接口的变化。 Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade 很多时候更是一种架构设计模式。 Facade 设计模式并非一个集装箱，可以任意的放进任何多个对象。Facade 模式中组件的内部应该是 “相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。 示例示例 code 12 Proxy 代理模式“接口隔离” 模式 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。 典型模式 Facade Proxy Adapter Mediator 动机（Motivation） 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。 如何在不失去透明操作对象的同事来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。 模式定义 为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。——《设计模式》GoF 结构（Structure） 要点总结 “增加一层间接层” 是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的 proxy 对象便是解决这一问题的常用手段。 具体 proxy 设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如 copy-on-write 技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做 proxy。 Proxy 并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。 示例示例 code 12 Adapter 适配器“接口隔离” 模式 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。 典型模式 Facade Proxy Adapter Mediator 动机（Motivation） 在软件系统中，由于应用环境的变化，常常需要将 “一些现存的对象” 放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。 如何应对这种 “迁移的变化”？ 如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？ 模式定义 将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——《设计模式》GoF 结构（Structure） 要点总结 Adapter 模式主要应用于 “希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。 GoF 23 定义了两种 Adapter 模式的实现结构：对象适配器和类适配器。但类适配器采用 “多继承” 的实现方式，一般不推荐使用。对象适配器采用 “对象组合” 的方式，更符合松耦合精神。 Adapter 模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的 “现存对象” 作为新的接口方法参数，来达到适配的目的。 示例示例 code 12 Mediator 中介者“接口隔离” 模式 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。 典型模式 Facade Proxy Adapter Mediator 动机（Motivation） 在软件构建过程中，进程会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。 在这种情况下，我们可以使用一个 “中介对象” 来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。 模式定义 用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖–&gt;运行时依赖），从而使得其耦合松散（管理变化），而且可以独立地改变它们之间的交互。——《设计模式》GoF 结构（Structure） 要点总结 将多个对象间复杂的关联关系解耦，Mediator 模式将多个对象间的控制逻辑进行集中管理，变 “多个对象相互关联” 为 “多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。 随着控制逻辑的复杂化，Mediator 具体对象的实现可能相当复杂。这个时候可以对 Mediator 对象进行分解处理。 Facade 模式是解耦系统间（单向）的对象关联关系；Mediator 模式是解耦系统内各个对象之间（双向）的关联关系。 示例示例 code 12 State 状态模式“状态变化” 模式 在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化” 模式为这一问题提供了一种解决方案。 典型模式 State Memento 动机（Motivation） 在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。 如何在运行时根据对象的状态来透明的更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？ 模式定义 允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。——《设计模式》GoF 结构（Structure） 要点总结 State 模式将所有与一个特定状态相关的行为都放入一个 State 的子类对象中，在对象状态切换时，切换相应的对象；但同时维持 State 的接口，这样实现了具体操作与状态转换之间的解耦。 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。 如果 State 对象没有实例变量，那么各个上下文可以共享同一个 State 对象，从而节省对象开销。 示例示例 code 12 Memento 备忘录“状态变化” 模式 在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化” 模式为这一问题提供了一种解决方案。 典型模式 State Memento 动机（Motivation） 在软件构建过程中，某些对象的状态在转换过程中，可能由于某些需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。 如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。 模式定义 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。——《设计模式》GoF 结构（Structure） 要点总结 备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。 Memento 模式的核心是信息隐藏，即 Originator 需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。 由于现代语言运行时（如C#、Java等）都具有相当的对象序列化支持，因此往往采用效率较高、又容易正确实现的序列化方案来实现 Memento 模式。 示例示例 code 12 Composite 组合模式“数据结构” 模式 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。 典型模式 Composite Iterator Chain Of Resposibility 动机（Motivation） 在软件在某些情况下，客户代码过多的依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。 如何将 “客户代码与复杂的对象容器结构” 解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？ 模式定义 将对象组合成树形结构以表示 “部分—整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。——《设计模式》GoF 结构（Structure） 要点总结 Composite 模式采用树形结构来实现普遍存在的对象容器，从而将 “一对多” 的关系转化为 “一对一” 的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。 将 “客户代码与复杂的对象容器结构” 解耦是 Composite 的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能 “应对变化”。 Composite 模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。 示例示例 code 12 Iterator 迭代器“数据结构” 模式 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。 典型模式 Composite Iterator Chain Of Resposibility 动机（Motivation） 在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明的访问其中包含的元素；同时这种 “透明遍历” 也为 “同一种算法在多种集合对象上进行操作” 提供了可能。 使用面向对象技术将这种遍历机制抽象为 “迭代器对象” 为 “应对变化中的集合对象” 提供了一种优雅的方式。 模式定义 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。——《设计模式》GoF 结构（Structure） 要点总结 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。 示例示例 code 12 Chain Of Resposibility 职责链“数据结构” 模式 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。 典型模式 Composite Iterator Chain Of Resposibility 动机（Motivation） 在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少的带来请求发送者与接受者的紧耦合。 如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。 模式定义 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递请求，直到有一个对象处理它位置。——《设计模式》GoF 结构（Structure） 要点总结 Chain Of Resposibility 模式的应用场合在于 “一个请求可能有多个接受者，但是最后真正的接受者只有一个”， 这时候请求发送者接受者的耦合有可能出现 “变化脆弱” 的症状，职责链的目的就是将二者解耦，从而更好的应对变化。 应用了 Chain Of Resposibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受者对象的责任，而不是发出请求的对象的责任。 示例示例 code 12 Command 命令模式“行为变化” 模式 在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化” 模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。 典型模式 Command Visitor 动机（Motivation） 在软件构建的过程中，“行为请求者” 与 “行为实现者” 通常呈现一种 “紧耦合”。 但在某些场合——比如需要对行为进行 “记录、撤销/重（undo/redo）、事务” 等处理，这种无法抵御变化的紧耦合是不适合的。 在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 模式定义 将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。——《设计模式》GoF 结构（Structure） 要点总结 Command 模式的根本目的在于将 “行为请求者” 与 “行为实现者” 解耦，在面向对象语言中，常见的实现手段是 “将行为抽象为对象”。 实现 Command 接口的具体命令对象 ConcreateCommand 有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个 “命令” 封装为一个 “复合命令” MacroCommand。 Command 模式与 C++ 中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command 以面向对象中的 “接口 - 实现” 来定义行为接口规范，更严格，但有性能损失；C++ 函数对象以函数签名来定义行为接口规范，更灵活，性能更高。 示例示例 code 12 Visitor 访问器“行为变化” 模式 在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化” 模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。 典型模式 Command Visitor 动机（Motivation） 在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。 如何在不更改类层次结构的前提下，在运行是根据需要透明的为类层次结构上的各个类动态添加新的操作，从而避免上述问题？ 模式定义 表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。——《设计模式》GoF 结构（Structure） 要点总结 Visitor 模式通过所谓双重分发（double dispatch）来实现在不更改（不添加新的操作 - 编译时）Element 类层次结构的前提下，在运行时透明的为类层次结构上的各个类动态添加新的操作（支持变化）。 所谓双重分发即 Visitor 模式中间包括了两个多态分发（注意其中的多态机制）：第一个为 accept 方法的多态辨析；第二个为 visitElementX 方法的多态辨析。 Visitor 模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致 Visitor 类的改变。因此Visitor模式适用于 “Element类层次结构稳定，而其中的操作却经常面临频繁改动”。 示例示例 code 12 Interpreter 解析器“领域规则” 模式 在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出该领域下的一般性解决方案。 典型模式 Interpreter 动机（Motivation） 在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将会面临非常频繁的变化。 在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解析器来解释这样的句子，从而达到解决问题的目的。 模式定义 给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。——《设计模式》GoF 结构（Structure） 要点总结 Interpreter 模式的应用场合是 Interpreter 模式应用中的难点，只有满足 “业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题” 才适合使用 Interpreter 模式。 使用 Interpreter 模式来表示文法规则，从而可以使用面向对象技巧来方便的 “扩展” 文法。 Interpreter 模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter 模式会产生比较大的类层次结构，需要求助于语法分析器这样的标准工具。 示例示例 code 12 设计模式总结一个目标 管理变化，提高复用！ 两种手段 分解 vs. 抽象 八大原则 依赖倒置原则（DIP） 开放封闭原则（OCP） 单一职责原则（SRP） Liskov 替换原则（LSP） 接口隔离原则（ISP） 对象组合优于类继承 封装变化点 面向接口编程 重构技法 静态 –&gt; 动态 早绑定 –&gt; 晚绑定 继承 –&gt; 组合 编译时依赖 –&gt; 运行时依赖 紧耦合 –&gt; 松耦合 从封装变化角度对模式分类 C++ 对象模型 关注变化点和稳定点 什么时候不用模式 代码可读性很差时 需求理解还很浅时 变化没有显现时 不是系统的关键依赖点 项目没有复用价值时 项目将要发布时 经验之谈 不要为模式而模式 关注抽象类 &amp; 接口 理清变化点和稳定点 审视依赖关系 要有 Framework 和 Application 的区隔思维 良好的设计是演化的结果 设计模式成长之路 “手中无剑，心中无剑”：见模式而不知 “手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式 “手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式 “手中无剑，心中有剑”：忘掉模式，只有原则 重点 任何基类都要实现虚析构函数。 eg. virtual ~Library(){} 将一些步骤延迟到子类中，其实就是定义一个虚函数让子类去实现或者重写这个函数。 虚函数和纯虚函数（纯虚函数子类必须实现，虚函数基类必须实现） 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。 定义一个函数为纯虚函数，才代表函数没有被实现。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。 定义纯虚函数就是为了让基类不可实例化化，因为实例化这样的抽象数据结构本身并没有意义。或者给出实现也没有意义 Template Method 机制 – 虚函数的多态性 看类图的时候要养成标注那些是稳定的那些是变化的。 扩展就是继承+多态 继承表明子类遵循基类定义的规范 Reference 软件设计模式概述 虚函数和纯虚函数的区别 C++ 封装、继承、多态、重载、覆盖、隐藏基本概念详解 C++封装继承多态总结 手把手带你深入浅出神秘的设计模式 看懂UML类图和时序图]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb原理剖析]]></title>
    <url>%2F2016%2F07%2F15%2FProgram-C%2Fleveldb%2F</url>
    <content type="text"><![CDATA[在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。 Jeff Dean其人：http://research.google.com/people/jeff/index.html，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。 Sanjay Ghemawat其人：http://research.google.com/people/sanjay/index.html，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。 LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。 LevelDb 剖析之一：介绍LevelDb有如下一些特点： 首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。 其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。 再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。 另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。 除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。 LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。 LevelDb剖析之二：整体架构LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。 本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。 LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象： 从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。 LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。 Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。 当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。 SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。 SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意： 图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1 的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。 Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。 以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。 LevelDb剖析之三：log文件上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。 下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。 在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理 记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。 假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。 从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。 LevelDb剖析之四：SSTable文件SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。 本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。 LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。 上图展示了一个 .sst 文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。 以上是 .sst 的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了 .sst 文件的内部逻辑解释。 从上图可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。 LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。 图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。 文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。 上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。 从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。 “重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。 在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。 上面讲的这些就是.sst文件的全部内部奥秘。 LevelDb剖析之五：MemTable详解LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。 LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。 需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。 SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。 SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。 关于SkipList的详细介绍可以参考这篇文章，skip-list原理解析讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。 SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。 LevelDb剖析之六 写入与删除记录在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。 本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。 图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。 从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。 levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。 LevelDb剖析之七：读取记录LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。 假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。 LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。 那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。 为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”www.samecity.com&quot; value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”www.samecity.com&quot; value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”www.samecity.com&quot;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。 前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。 SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。 最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。 从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。 LevelDb剖析之八：Compaction操作前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。 levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。 LevelDb包含其中两种，minor和major。 我将为大家详细叙述其机理。 先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。 当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。 我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。 levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。 如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。 也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。 图8.2说明了这一过程。 Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。 那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。 LevelDb剖析之九 levelDb中的Cache书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。 levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。 图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。 比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。 Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。 如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。 LevelDb剖析之十 Version、VersionEdit、VersionSetVersion 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？ 当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。 当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。 VersionSet 是所有Version的集合，管理着所有存活的Version。 VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。 Version0 +VersionEdit–&gt;Version1 VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。 leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。 比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。 leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。 注：本文参考了这篇文章：http://www.samecity.com/blog/Index.asp?SortID=12参考资料：1.维基百科 2.google code]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理并发之二：libevent的eventbuffer]]></title>
    <url>%2F2016%2F07%2F12%2FProgram-C%2Flibevent%2F</url>
    <content type="text"><![CDATA[bufferevent这个结构体 1234567891011struct bufferevent &#123; struct event_base *ev_base; const struct bufferevent_ops *be_ops; struct event ev_read; struct event ev_write; struct evbuffer *input; struct evbuffer *output; bufferevent_data_cb readcb; bufferevent_data_cb writecb; bufferevent_event_cb errorcb;&#125; 可以看出 struct bufferevent 内置了两个 event（读/写）和对应的缓冲区。当有数据被读入(input)的时候，readcb 被调用，当 output 被输出完成的时候，writecb 被调用，当网络 I/O 出现错误，如链接中断，超时或其他错误时，errorcb 被调用。使用 bufferevent 的过程： 1. 设置sock为非阻塞的 1// eg: evutil_make_socket_nonblocking(fd); 2. 使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base 函数原型为： 1234struct bufferevent * bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options) // eg: struct bufferevent *bev; // bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); 3. 设置读写对应的回调函数 函数原型为： 12345void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg) // eg. bufferevent_setcb(bev, readcb, NULL, errorcb, NULL); 4. 启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的 函数原型： 12int bufferevent_enable(struct bufferevent *bufev, short event) // eg. bufferevent_enable(bev, EV_READ|EV_WRITE); 5. 进入bufferevent_setcb回调函数： 在readcb里面从input中读取数据，处理完毕后填充到output中； writecb对于服务端程序，只需要readcb就可以了，可以置为NULL； errorcb 用于处理一些错误信息。 针对这些使用过程进入源码进行分析： 1. bufferevent_socket_new 在bufferevent_init_common中调用evbuffer_new()初始化input和output 在event_assign中初始化bufferevent中的ev_read和ev_write事件。 在evbuffer_add_cb中给output添加了一个callback bufferevent_socket_outbuf_cb 2. bufferevent_setcb 该函数的作用主要是赋值，把该函数后面的参数，赋值给第一个参数 struct bufferevent *bufev 定义的变量 3. bufferevent_enable 调用event_add将读写事件加入到事件监听队列中。 对bufferevent常用的几个函数进行分析： 12345char *evbuffer_readln(struct evbuffer*buffer, size_t *n_read_out,enum evbuffer_eol_style eol_style);//含义：Read a single line from an evbuffer.//返回值：读到的一行内容 1234int evbuffer_add(struct evbuffer *buf,const void *data, size_t datlen);// 含义：将数据添加到evbuffer的结尾// 返回值：成功返回0，失败返回-1 1234int evbuffer_remove(struct evbuffer*buf, void *data, size_t datlen);// 含义：从evbuffer读取数据到data// 返回值：成功返回0，失败返回-1 123size_t evbuffer_get_length(const structevbuffer *buf);// 含义：返回evbuffer中存储的字节长度 暂时先分析到这里，下面是代码，客户端发送消息： 12HTTP/1.0, Client 0 send Message:Request: Hello Server! over 服务端一条消息收完成后，会回复： 1Response ok! Hello Client! 服务端从bufferevent中取出消息是按行取的。代码可能有不完善的地方，由于才疏学浅，研究时间短（3天），希望高手提出宝贵意见。 buffer_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;netinet/in.h&gt; #include &lt;sys/socket.h&gt; #include &lt;fcntl.h&gt; #include &lt;event2/event.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;assert.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; void do_read(evutil_socket_t fd, short events, void *arg); //struct bufferevent内建了两个event(read/write)和对应的缓冲区(struct evbuffer *input, *output)，并提供相应的函数用来操作缓冲区(或者直接操作bufferevent) //接收到数据后，判断是不一样一条消息的结束，结束标志为"over"字符void readcb(struct bufferevent *bev, void *ctx) &#123; printf("called readcb!\n"); struct evbuffer *input, *output; char *request_line; size_t len; //其实就是取出bufferevent中的input input = bufferevent_get_input(bev); //其实就是取出bufferevent中的output output = bufferevent_get_output(bev); size_t input_len = evbuffer_get_length(input); printf("input_len: %d\n", input_len); size_t output_len = evbuffer_get_length(output); printf("output_len: %d\n", output_len); while(1)&#123; //从evbuffer前面取出一行，用一个新分配的空字符结束 //的字符串返回这一行,EVBUFFER_EOL_CRLF表示行尾是一个可选的回车，后随一个换行符 request_line = evbuffer_readln(input, &amp;len, EVBUFFER_EOL_CRLF); if(NULL == request_line)&#123; printf("The first line has not arrived yet.\n"); free(request_line);//之所以要进行free是因为 line = mm_malloc(n_to_copy+1))，在这里进行了malloc break; &#125; else &#123; printf("Get one line date: %s\n", request_line); //用于判断是不是一条消息的结束 if(strstr(request_line, "over") != NULL) &#123; char *response = "Response ok! Hello Client!\r\n"; //Adds data to an event buffer evbuffer_add(output, response, strlen(response)); printf("服务端接收一条数据完成，回复客户端一条消息: %s\n", response); free(request_line); break; &#125; &#125; free(request_line); &#125; size_t input_len1 = evbuffer_get_length(input); printf("input_len1: %d\n", input_len1); size_t output_len1 = evbuffer_get_length(output); printf("output_len1: %d\n\n", output_len1); &#125; void errorcb(struct bufferevent *bev, short error, void *ctx) &#123; if (error &amp; BEV_EVENT_EOF) &#123; /* connection has been closed, do any clean up here */ printf("connection closed\n"); &#125;else if (error &amp; BEV_EVENT_ERROR)&#123; /* check errno to see what error occurred */ printf("some other error\n"); &#125; else if (error &amp; BEV_EVENT_TIMEOUT) /* must be a timeout event handle, handle it */ printf("Timed out\n"); &#125; bufferevent_free(bev); &#125;void do_accept(evutil_socket_t listener, short event, void *arg) &#123; struct event_base *base = arg; struct sockaddr_storage ss; socklen_t slen = sizeof(ss); int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen); if (fd &lt; 0)&#123; perror("accept"); &#125;else if (fd &gt; FD_SETSIZE)&#123; close(fd); &#125;else &#123; struct bufferevent *bev; evutil_make_socket_nonblocking(fd); //使用bufferevent_socket_new创建一个struct bufferevent*bev， //关联该sockfd，托管给event_base //BEV_OPT_CLOSE_ON_FREE表示释放bufferevent时关闭底层传输端口。 //这将关闭底层套接字，释放底层bufferevent等 bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); //设置读写对应的回调函数 bufferevent_setcb(bev, readcb, NULL, errorcb, NULL); bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE); //启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。 //正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的 bufferevent_enable(bev, EV_READ|EV_WRITE); &#125; &#125; void run(void)&#123; evutil_socket_t listener; struct sockaddr_in sin; struct event_base *base; struct event *listener_event; base = event_base_new(); if (!base) return; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(8000); listener = socket(AF_INET, SOCK_STREAM, 0); evutil_make_socket_nonblocking(listener); #ifndef WIN32&#123; int one = 1; setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(one)); &#125; #endif if(bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0)&#123; perror("bind"); return; &#125; if (listen(listener, 16)&lt;0)&#123; perror("listen"); return; &#125; listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base); event_add(listener_event, NULL); event_base_dispatch(base); &#125; int main(int argc, char **argv)&#123; setvbuf(stdout, NULL, _IONBF, 0); run(); return 0; &#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程编程]]></title>
    <url>%2F2016%2F07%2F11%2FProgram-C%2Fmulti-thread%2F</url>
    <content type="text"><![CDATA[怎么样才算得上熟悉多线程编程？ C++多线程模型与锁 了解进程线程的基本概念，能用一种语言在一个平台上实现一个多线程的例子。（这些不会还写熟悉多线程就太大无畏了） 了解为什么要用Mutex之类的工具做锁来同步和保护资源。弄懂诸如racing condition，死锁之类的概念。50%公司的见面题，用来砍死大无畏。 了解编译器优化带来的影响，了解cache的影响，了解volatile，memory barrier之类的概念。如果是主Java的话，去了解一下JVM的内存模型。以上这些偏硬偏系统端的公司喜欢问，不过由于太基础，稍稍好奇一点的多线程领域程序员都应该会了解，否则略显大无畏。 了解一下你主攻平台＋语言所提供的工具库，知道常用的工具的用法和使用场景：Mutex，Semaphore，原子操作集，Condition Variable，spin lock。这几个算是比较常用的，在各个平台＋语言也都有对应实现。老实说，spinlock，condition variable是我工作里从没用过的，但是也被问过，其他几个都太常用了，如果是java的话再多看一组Executor相关的，以及Java多线程相关的keywords，和object本身提供的同步函数，wait notify之类的，在主Java的公司问过。 了解常用的多线程设计范式，比如读写锁（Reader/Writer Lock，非常经典的范式，有偏向读和写的不同变形，至少被要求写过3次），生产消费范式（写过2次），一些常用容器的实现，比如BlockingQueue（写过3次）或者concurrentHashmap（写过2次）。如果是主Java的话可以看看JDK的实现。熟悉一下一些算不上多线程设计模式的小技巧，比如传递只读对象可以避免加锁，或者Copy传递以防外部修改之类的（讨论环节被问过）。另外值得特别一提的一个小细节是，Singleton的线程安全是个很有意思而且容易出错的话题，值得一看（只被问过一次，不过我答挂了，所以印象及其深）。还有可能会问的是一些有趣的小场景让你实现一些功能需要线程安全，无法特别准备，但是你能了解上面说的这些范式，不傻的话大多数都能想出来。如果和我一样多线程方面是主Java的话，记得Doug Lea的书写的很明白，不过不记得当时读完的是哪本，70%可能是下面这个http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601否则就是Concurrent Programming in Java: Design Principles and Pattern (2nd Edition): Doug Lea: 0785342310092: Amazon.com: Books 这个大致是一些公司对多线程部分的要求，如果应聘者声称熟悉这个部分。上面所有点都是本人面试被问到的，基本上能看完上面这些，可以做到不用很心虚在简历上写自己熟悉多线程而不会被揭穿。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理并发之一：LINUX Epoll 机制介绍]]></title>
    <url>%2F2016%2F07%2F08%2FProgram-C%2Flinux-epoll%2F</url>
    <content type="text"><![CDATA[Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选，Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。 其实在 Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（Process Per Connection，简称 PPC），TPC（Thread Per Connection）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的… 常用模型的缺点如果不摆出来其他模型的缺点，怎么能对比出 Epoll 的优点呢。 PPC/TPC 模型这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是 PPC 是为它开了一个进程，而 TPC 开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程 / 线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。 select模型 最大并发数限制，因为一个进程所打开的 FD（文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048，因此 Select 模型的最大并发数就被相应限制了。自己改改这个FD_SETSIZE？想法虽好，可是先看看下面吧… 效率问题，select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了？？！！ 内核 / 用户空间 内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法。 poll 模型基本上效率和 select 是相同的，select 缺点的 2 和 3 它都没有改掉。 Epoll 的提升把其他模型逐个批判了一下，再来看看 Epoll 的改进之处吧，其实把 select 的缺点反过来那就是 Epoll 的优点了。 Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大，具体数目可以 cat /proc/sys/fs/file-max 察看。 效率提升，Epoll 最大的优点就在于它只管你 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。 内存拷贝，Epoll 在这点上使用了 “共享内存”，这个内存拷贝也省略了。 Epoll为什么高效Epoll 的高效和其数据结构的设计是密不可分的，这个下面就会提到。 首先回忆一下 select 模型，当有 I/O 事件到来时，select 通知应用程序有事件到了快去处理，而应用程序必须轮询所有的 FD 集合，测试每个 FD 是否有事件发生，并处理事件； 代码像下面这样： 123456789101112int res = select(maxfd+1, &amp;readfds, NULL, NULL, 120);if(res &gt; 0)&#123; for(int i = 0; i &lt; MAX_CONNECTION; i++) &#123; if(FD_ISSET(allConnection[i],&amp;readfds)) &#123; handleEvent(allConnection[i]); &#125; &#125;&#125;// if(res == 0) handle timeout, res &lt; 0 handle error Epoll 不仅会告诉应用程序有 I/0 事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个 FD 集合。 12345intres = epoll_wait(epfd, events, 20, 120);for(int i = 0; i &lt; res;i++)&#123; handleEvent(events[n]);&#125; Epoll 关键数据结构前面提到 Epoll 速度快和其数据结构密不可分，其关键数据结构就是： 1234567891011struct epoll_event &#123; __uint32_t events; // Epoll events epoll_data_t data; // User datavariable&#125;;typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t; 结构体 epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件. 其中 epoll_data 联合体用来保存触发事件的某个文件描述符相关的数据. 例如一个 client 连接到服务器，服务器通过调用 accept 函数可以得到于这个 client 对应的 socket 文件描述符，可以把这文件描述符赋给 epoll_data 的 fd 字段以便后面的读写操作在这个文件描述符上进行。epoll_event 结构体的 events 字段是表示感兴趣的事件和被触发的事件可能的取值为： EPOLLIN ：表示对应的文件描述符可以读； EPOLLOUT：表示对应的文件描述符可以写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读 EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET：表示对应的文件描述符有事件发生； ET 和 LT 模式 LT(level triggered) 是缺省的工作方式，并且同时支持 block 和 no-block socket. 在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的 select/poll 都是这种模型的代表。 ET (edge-triggered) 是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知(only once)，不过在 TCP 协议中，ET 模式的加速效用仍需要更多的 benchmark 确认。 ET 和 LT 的区别在于 LT 事件不会丢弃，而是只要读 buffer 里面有数据可以让用户读，则不断的通知你。而 ET 则只在事件发生之时通知。可以简单理解为 LT 是水平触发，而 ET 则为边缘触发。 ET 模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用 ET 模式,需要一直 read/write 直到出错为止, 很多人反映为什么采用 ET 模式只接收了一部分数据就再也得不到通知了, 大多因为这样; 而 LT 模式是只要有数据没有处理就会一直通知下去的. 使用 Epoll既然 Epoll 相比 select 这么好，那么用起来如何呢？会不会很繁琐啊…先看看下面的三个函数吧，就知道 Epoll 的易用了。 1int epoll_create(int size); 生成一个 Epoll 专用的文件描述符，其实是申请一个内核空间，用来存放你想关注的 socket fd 上是否发生以及发生了什么事件。size 就是你在这个 Epoll fd 上能关注的最大 socket fd 数，大小自定，只要内存足够。 1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的 fd 到 epfd 中； EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件； EPOLL_CTL_DEL：从 epfd 中删除一个 fd； 第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事 1int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout); 等待 I/O 事件的发生；参数说明： epfd: 由 epoll_create() 生成的 Epoll 专用的文件描述符； epoll_event: 用于回传代处理事件的数组； maxevents: 每次能处理的事件数； timeout: 等待 I/O 事件发生的超时值； 返回发生事件数。 测试程序首先对服务端和客户端做下说明： 我想实现的是客户端和服务端并发的程序，客户端通过配置并发数，说明有多少个用户去连接服务端。 客户端会发送消息：”Client: i send message Hello Server!”，其中 i 表示哪一个客户端；收到消息：”Recv Server Msg Content:%s\n”。 例如： 123发送：Client: 1 send message "Hello Server!"接收：Recv Derver Msg Content:Hello, client fd: 6服务端收到后给客户端回复消息："Hello, client fd: i"，其中 i 表示服务端接收的 fd, 用户区别是哪一个客户端。接收客户端消息："Terminal Received Msg Content:%s\n" 例如： 12发送：Hello, client fd: 6接收：Terminal Received Msg Content:Client: 1 send message "Hello Server!" 备注：这里在接收到消息后，直接打印出消息，如果需要对消息进行处理（如果消息处理比较占用时间，不能立即返回，可以将该消息放入一个队列中，然后开启一个线程从队列中取消息进行处理，这样的话不会因为消息处理而阻塞 epoll）。libenent 好像对这种有 2 中处理方式，一个就是回调，要求回调函数，不占用太多的时间，基本能立即返回，另一种好像也是一个队列实现的，这个还需要研究。 服务端代码说明： 服务端在绑定监听后，开启了一个线程，用于负责接收客户端连接，加入到 epoll 中，这样只要 accept 到客户端的连接，就将其 add EPOLLIN 到 epoll 中，然后进入循环调用 epoll_wait，监听到读事件，接收数据，并将事件修改为 EPOLLOUT；反之监听到写事件，发送数据，并将事件修改为EPOLLIN。 服务器代码： 12345678910111213141516171819202122232425262728293031323334//cepollserver.h #ifndef C_EPOLL_SERVER_H #define C_EPOLL_SERVER_H #include &lt;sys/epoll.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;fcntl.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;pthread.h&gt; #define _MAX_SOCKFD_COUNT 65535 class CEpollServer &#123; public: CEpollServer(); ~CEpollServer(); bool InitServer(const char* chIp, int iPort); void Listen(); static void ListenThread( void* lpVoid ); void Run(); private: int m_iEpollFd; int m_isock; pthread_t m_ListenThreadId;// 监听线程句柄 &#125;; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include "cepollserver.h" using namespace std; CEpollServer::CEpollServer() &#123; &#125; CEpollServer::~CEpollServer() &#123; close(m_isock); &#125; bool CEpollServer::InitServer(const char* pIp, int iPort) &#123; m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT); //设置非阻塞模式 int opts = O_NONBLOCK; if(fcntl(m_iEpollFd,F_SETFL,opts)&lt;0) &#123; printf("设置非阻塞模式失败!\n"); return false; &#125; m_isock = socket(AF_INET,SOCK_STREAM,0); if ( 0 &gt; m_isock ) &#123; printf("socket error!\n"); return false; &#125; sockaddr_in listen_addr; listen_addr.sin_family=AF_INET; listen_addr.sin_port=htons ( iPort ); listen_addr.sin_addr.s_addr=htonl(INADDR_ANY); listen_addr.sin_addr.s_addr=inet_addr(pIp); int ireuseadd_on = 1;//支持端口复用 setsockopt(m_isock, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, sizeof(ireuseadd_on) ); if ( bind ( m_isock, ( sockaddr * ) &amp;listen_addr,sizeof ( listen_addr ) ) !=0 ) &#123; printf("bind error\n"); return false; &#125; if ( listen ( m_isock, 20) &lt;0 ) &#123; printf("listen error!\n"); return false; &#125; else &#123; printf("服务端监听中...\n"); &#125; // 监听线程，此线程负责接收客户端连接，加入到epoll中 if ( pthread_create( &amp;m_ListenThreadId, 0, ( void * ( * ) ( void * ) ) ListenThread, this ) != 0 ) &#123; printf("Server 监听线程创建失败!!!"); return false; &#125; &#125; // 监听线程 void CEpollServer::ListenThread( void* lpVoid ) &#123; CEpollServer *pTerminalServer = (CEpollServer*)lpVoid; sockaddr_in remote_addr; int len = sizeof (remote_addr); while ( true ) &#123; int client_socket = accept (pTerminalServer-&gt;m_isock, ( sockaddr * ) &amp;remote_addr,(socklen_t*)&amp;len ); if ( client_socket &lt; 0 ) &#123; printf("Server Accept失败!, client_socket: %d\n", client_socket); continue; &#125; else &#123; struct epoll_event ev; ev.events = EPOLLIN | EPOLLERR | EPOLLHUP; ev.data.fd = client_socket; //记录socket句柄 epoll_ctl(pTerminalServer-&gt;m_iEpollFd, EPOLL_CTL_ADD, client_socket, &amp;ev); &#125; &#125; &#125; void CEpollServer::Run() &#123; while ( true ) &#123; struct epoll_event events[_MAX_SOCKFD_COUNT]; int nfds = epoll_wait( m_iEpollFd, events, _MAX_SOCKFD_COUNT, -1 ); for (int i = 0; i &lt; nfds; i++) &#123; int client_socket = events[i].data.fd; char buffer[1024];//每次收发的字节数小于1024字节 memset(buffer, 0, 1024); if (events[i].events &amp; EPOLLIN)//监听到读事件，接收数据 &#123; int rev_size = recv(events[i].data.fd,buffer, 1024,0); if( rev_size &lt;= 0 ) &#123; cout &lt;&lt; "recv error: recv size: " &lt;&lt; rev_size &lt;&lt; endl; struct epoll_event event_del; event_del.data.fd = events[i].data.fd; event_del.events = 0; epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del); &#125; else &#123; printf("Terminal Received Msg Content:%s\n",buffer); struct epoll_event ev; ev.events = EPOLLOUT | EPOLLERR | EPOLLHUP; ev.data.fd = client_socket; //记录socket句柄 epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev); &#125; &#125; else if(events[i].events &amp; EPOLLOUT)//监听到写事件，发送数据 &#123; char sendbuff[1024]; sprintf(sendbuff, "Hello, client fd: %d\n", client_socket); int sendsize = send(client_socket, sendbuff, strlen(sendbuff)+1, MSG_NOSIGNAL); if(sendsize &lt;= 0) &#123; struct epoll_event event_del; event_del.data.fd = events[i].data.fd; event_del.events = 0; epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del); &#125; else &#123; printf("Server reply msg ok! buffer: %s\n", sendbuff); struct epoll_event ev; ev.events = EPOLLIN | EPOLLERR | EPOLLHUP; ev.data.fd = client_socket; //记录socket句柄 epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev); &#125; &#125; else &#123; cout &lt;&lt; "EPOLL ERROR\n" &lt;&lt;endl; epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, events[i].data.fd, &amp;events[i]); &#125; &#125; &#125; &#125; 客户端代码： 说明：测试是两个并发进行测试，每一个客户端都是一个长连接。代码中在连接服务器（ConnectToServer）时将用户 ID 和 socketid 关联起来。用户 ID 和 socketid 是一一对应的关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#ifndef _DEFINE_EPOLLCLIENT_H_ #define _DEFINE_EPOLLCLIENT_H_ #define _MAX_SOCKFD_COUNT 65535 #include&lt;iostream&gt; #include &lt;sys/epoll.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;fcntl.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;errno.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/time.h&gt; #include &lt;string&gt; using namespace std; /** * @brief 用户状态 */ typedef enum _EPOLL_USER_STATUS_EM &#123; FREE = 0, CONNECT_OK = 1,//连接成功 SEND_OK = 2,//发送成功 RECV_OK = 3,//接收成功 &#125;EPOLL_USER_STATUS_EM; /*@brief *@CEpollClient class 用户状态结构体 */ struct UserStatus &#123; EPOLL_USER_STATUS_EM iUserStatus;//用户状态 int iSockFd;//用户状态关联的socketfd char cSendbuff[1024];//发送的数据内容 int iBuffLen;//发送数据内容的长度 unsigned int uEpollEvents;//Epoll events &#125;; class CEpollClient &#123; public: /** * @brief * 函数名:CEpollClient * 描述:构造函数 * @param [in] iUserCount * @param [in] pIP IP地址 * @param [in] iPort 端口号 * @return 无返回 */ CEpollClient(int iUserCount, const char* pIP, int iPort); /** * @brief * 函数名:CEpollClient * 描述:析构函数 * @return 无返回 */ ~CEpollClient(); /** * @brief * 函数名:RunFun * 描述:对外提供的接口，运行epoll类 * @return 无返回值 */ int RunFun(); private: /** * @brief * 函数名:ConnectToServer * 描述:连接到服务器 * @param [in] iUserId 用户ID * @param [in] pServerIp 连接的服务器IP * @param [in] uServerPort 连接的服务器端口号 * @return 成功返回socketfd,失败返回的socketfd为-1 */ int ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort); /** * @brief * 函数名:SendToServerData * 描述:给服务器发送用户(iUserId)的数据 * @param [in] iUserId 用户ID * @return 成功返回发送数据长度 */ int SendToServerData(int iUserId); /** * @brief * 函数名:RecvFromServer * 描述:接收用户回复消息 * @param [in] iUserId 用户ID * @param [in] pRecvBuff 接收的数据内容 * @param [in] iBuffLen 接收的数据长度 * @return 成功返回接收的数据长度，失败返回长度为-1 */ int RecvFromServer(int iUserid,char *pRecvBuff,int iBuffLen); /** * @brief * 函数名:CloseUser * 描述:关闭用户 * @param [in] iUserId 用户ID * @return 成功返回true */ bool CloseUser(int iUserId); /** * @brief * 函数名:DelEpoll * 描述:删除epoll事件 * @param [in] iSockFd socket FD * @return 成功返回true */ bool DelEpoll(int iSockFd); private: int m_iUserCount;//用户数量； struct UserStatus *m_pAllUserStatus;//用户状态数组 int m_iEpollFd;//需要创建epollfd int m_iSockFd_UserId[_MAX_SOCKFD_COUNT];//将用户ID和socketid关联起来 int m_iPort;//端口号 char m_ip[100];//IP地址 &#125;; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include "cepollclient.h" CEpollClient::CEpollClient(int iUserCount, const char* pIP, int iPort) &#123; strcpy(m_ip, pIP); m_iPort = iPort; m_iUserCount = iUserCount; m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT); m_pAllUserStatus = (struct UserStatus*)malloc(iUserCount*sizeof(struct UserStatus)); for(int iuserid=0; iuserid&lt;iUserCount ; iuserid++) &#123; m_pAllUserStatus[iuserid].iUserStatus = FREE; sprintf(m_pAllUserStatus[iuserid].cSendbuff, "Client: %d send message \"Hello Server!\"\r\n", iuserid); m_pAllUserStatus[iuserid].iBuffLen = strlen(m_pAllUserStatus[iuserid].cSendbuff) + 1; m_pAllUserStatus[iuserid].iSockFd = -1; &#125; memset(m_iSockFd_UserId, 0xFF, sizeof(m_iSockFd_UserId)); &#125; CEpollClient::~CEpollClient() &#123; free(m_pAllUserStatus); &#125; int CEpollClient::ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort) &#123; if( (m_pAllUserStatus[iUserId].iSockFd = socket(AF_INET,SOCK_STREAM,0) ) &lt; 0 ) &#123; cout &lt;&lt;"[CEpollClient error]: init socket fail, reason is:"&lt;&lt;strerror(errno)&lt;&lt;",errno is:"&lt;&lt;errno&lt;&lt;endl; m_pAllUserStatus[iUserId].iSockFd = -1; return m_pAllUserStatus[iUserId].iSockFd; &#125; struct sockaddr_in addr; bzero(&amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(uServerPort); addr.sin_addr.s_addr = inet_addr(pServerIp); int ireuseadd_on = 1;//支持端口复用 setsockopt(m_pAllUserStatus[iUserId].iSockFd, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, sizeof(ireuseadd_on)); unsigned long ul = 1; ioctl(m_pAllUserStatus[iUserId].iSockFd, FIONBIO, &amp;ul); //设置为非阻塞模式 connect(m_pAllUserStatus[iUserId].iSockFd, (const sockaddr*)&amp;addr, sizeof(addr)); m_pAllUserStatus[iUserId].iUserStatus = CONNECT_OK; m_pAllUserStatus[iUserId].iSockFd = m_pAllUserStatus[iUserId].iSockFd; return m_pAllUserStatus[iUserId].iSockFd; &#125; int CEpollClient::SendToServerData(int iUserId) &#123; sleep(1);//此处控制发送频率，避免狂打日志，正常使用中需要去掉 int isendsize = -1; if( CONNECT_OK == m_pAllUserStatus[iUserId].iUserStatus || RECV_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123; isendsize = send(m_pAllUserStatus[iUserId].iSockFd, m_pAllUserStatus[iUserId].cSendbuff, m_pAllUserStatus[iUserId ].iBuffLen, MSG_NOSIGNAL); if(isendsize &lt; 0) &#123; cout &lt;&lt;"[CEpollClient error]: SendToServerData, send fail, reason is:"&lt;&lt;strerror(errno)&lt;&lt;",errno is:"&lt;&lt;errno&lt; &lt;endl; &#125; else &#123; printf("[CEpollClient info]: iUserId: %d Send Msg Content:%s\n", iUserId, m_pAllUserStatus[iUserId].cSendbuff ); m_pAllUserStatus[iUserId].iUserStatus = SEND_OK; &#125; &#125; return isendsize; &#125; int CEpollClient::RecvFromServer(int iUserId,char *pRecvBuff,int iBuffLen) &#123; int irecvsize = -1; if(SEND_OK == m_pAllUserStatus[iUserId].iUserStatus) &#123; irecvsize = recv(m_pAllUserStatus[iUserId].iSockFd, pRecvBuff, iBuffLen, 0); if(0 &gt; irecvsize) &#123; cout &lt;&lt;"[CEpollClient error]: iUserId: " &lt;&lt; iUserId &lt;&lt; "RecvFromServer, recv fail, reason is:"&lt;&lt;strerror(errn o)&lt;&lt;",errno is:"&lt;&lt;errno&lt;&lt;endl; &#125; else if(0 == irecvsize) &#123; cout &lt;&lt;"[warning:] iUserId: "&lt;&lt; iUserId &lt;&lt; "RecvFromServer, STB收到数据为0，表示对方断开连接,irecvsize:"&lt;&lt;ire cvsize&lt;&lt;",iSockFd:"&lt;&lt; m_pAllUserStatus[iUserId].iSockFd &lt;&lt; endl; &#125; else &#123; printf("Recv Server Msg Content:%s\n", pRecvBuff); m_pAllUserStatus[iUserId].iUserStatus = RECV_OK; &#125; &#125; return irecvsize; &#125; bool CEpollClient::CloseUser(int iUserId) &#123; close(m_pAllUserStatus[iUserId].iSockFd); m_pAllUserStatus[iUserId].iUserStatus = FREE; m_pAllUserStatus[iUserId].iSockFd = -1; return true; &#125; int CEpollClient::RunFun() &#123; int isocketfd = -1; for(int iuserid=0; iuserid&lt;m_iUserCount; iuserid++) &#123; struct epoll_event event; isocketfd = ConnectToServer(iuserid, m_ip, m_iPort); if(isocketfd &lt; 0) cout &lt;&lt;"[CEpollClient error]: RunFun, connect fail" &lt;&lt;endl; m_iSockFd_UserId[isocketfd] = iuserid;//将用户ID和socketid关联起来 event.data.fd = isocketfd; event.events = EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP; m_pAllUserStatus[iuserid].uEpollEvents = event.events; epoll_ctl(m_iEpollFd, EPOLL_CTL_ADD, event.data.fd, &amp;event); &#125; while(1) &#123; struct epoll_event events[_MAX_SOCKFD_COUNT]; char buffer[1024]; memset(buffer,0,1024); int nfds = epoll_wait(m_iEpollFd, events, _MAX_SOCKFD_COUNT, 100 );//等待epoll事件的产生 for (int ifd=0; ifd&lt;nfds; ifd++)//处理所发生的所有事件 &#123; struct epoll_event event_nfds; int iclientsockfd = events[ifd].data.fd; cout &lt;&lt; "events[ifd].data.fd: " &lt;&lt; events[ifd].data.fd &lt;&lt; endl; int iuserid = m_iSockFd_UserId[iclientsockfd];//根据socketfd得到用户ID if( events[ifd].events &amp; EPOLLOUT ) &#123; int iret = SendToServerData(iuserid); if( 0 &lt; iret ) &#123; event_nfds.events = EPOLLIN|EPOLLERR|EPOLLHUP; event_nfds.data.fd = iclientsockfd; epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds); &#125; else &#123; cout &lt;&lt;"[CEpollClient error:] EpollWait, SendToServerData fail, send iret:"&lt;&lt;iret&lt;&lt;",iuserid:"&lt;&lt;iuser id&lt;&lt;",fd:"&lt;&lt;events[ifd].data.fd&lt;&lt;endl; DelEpoll(events[ifd].data.fd); CloseUser(iuserid); &#125; &#125; else if( events[ifd].events &amp; EPOLLIN )//监听到读事件，接收数据 &#123; int ilen = RecvFromServer(iuserid, buffer, 1024); if(0 &gt; ilen) &#123; cout &lt;&lt;"[CEpollClient error]: RunFun, recv fail, reason is:"&lt;&lt;strerror(errno)&lt;&lt;",errno is:"&lt;&lt;errno&lt;&lt;e ndl; DelEpoll(events[ifd].data.fd); CloseUser(iuserid); &#125; else if(0 == ilen) &#123; cout &lt;&lt;"[CEpollClient warning:] server disconnect,ilen:"&lt;&lt;ilen&lt;&lt;",iuserid:"&lt;&lt;iuserid&lt;&lt;",fd:"&lt;&lt;events[ ifd].data.fd&lt;&lt;endl; DelEpoll(events[ifd].data.fd); CloseUser(iuserid); &#125; else &#123; m_iSockFd_UserId[iclientsockfd] = iuserid;//将socketfd和用户ID关联起来 event_nfds.data.fd = iclientsockfd; event_nfds.events = EPOLLOUT|EPOLLERR|EPOLLHUP; epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds); &#125; &#125; else &#123; cout &lt;&lt;"[CEpollClient error:] other epoll error"&lt;&lt;endl; DelEpoll(events[ifd].data.fd); CloseUser(iuserid); &#125; &#125; &#125; &#125; bool CEpollClient::DelEpoll(int iSockFd) &#123; bool bret = false; struct epoll_event event_del; if(0 &lt; iSockFd) &#123; event_del.data.fd = iSockFd; event_del.events = 0; if( 0 == epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del) ) &#123; bret = true; &#125; else &#123; cout &lt;&lt;"[SimulateStb error:] DelEpoll,epoll_ctl error,iSockFd:"&lt;&lt;iSockFd&lt;&lt;endl; &#125; m_iSockFd_UserId[iSockFd] = -1; &#125; else &#123; bret = true; &#125; return bret; &#125; 服务器主程序： 12345678910111213#include &lt;iostream&gt; #include "cepollserver.h" using namespace std; int main() &#123; CEpollServer theApp; theApp.InitServer("127.0.0.1", 8000); theApp.Run(); return 0; &#125; 客户端主程序： 1234567891011121314151617181920#include "cepollclient.h" int main(int argc, char *argv[]) &#123; CEpollClient *pCEpollClient = new CEpollClient(2, "127.0.0.1", 8000); if(NULL == pCEpollClient) &#123; cout&lt;&lt;"[epollclient error]:main init"&lt;&lt;"Init CEpollClient fail"&lt;&lt;endl; &#125; pCEpollClient-&gt;RunFun(); if(NULL != pCEpollClient) &#123; delete pCEpollClient; pCEpollClient = NULL; &#125; return 0; &#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 代码优化小贴士]]></title>
    <url>%2F2016%2F07%2F06%2FProgram-C%2Fc-code-opt%2F</url>
    <content type="text"><![CDATA[虽然对于优化C代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。 整型数 / Integers 在我们知道使用的数不可能是负数的时候，应该使用unsigned int取代int，一些处理器处理整数算数运算的时候unsigned int比int快，于是，在一个紧致的循环里面定义一个整型变量，最好这样写代码： register unsigned int variable_name; 然而，我们不能保证编译器会注意到那个register关键字，也有可能，对某种处理器来说，有没有unsigned是一样的。这两个关键字并不是可以在所有的编译器中应用。**记住，整形数运算要比浮点数运算快得多，因为处理器可以直接进行整型数运算，浮点数运算需要依赖于外部的浮点数处理器或者浮点数数学库。**我们处理小数的时候要精确点些（比如我们在做一个简单的统计程序时），要限制结果不能超过100，要尽可能晚的把它转化成浮点数。 还有一个整形提升的问题，比如下面这个例子： size_t n = 10; int i ; for(i = -1; i < n; ++i) { printf("%d\n",i); } 这段代码实际上什么也不会输出，因为size_t是unsigned int类型，i会自动转换成unsigned int就变成了一个很大的正数，所以和n比较自然什么都不会输出。 在算术运算中，char和short会自动转换成int，转换的原则就是如果int类型能过包括操作数类型的所有范围，则操作数（比如unsigned short）转换成int，否则转换成unsigned int，int和long类型运算以此类推，**总是向着精度更高、位更长的类型转换。** 除法和余数 / Division and Remainder 在标准的处理器中，根据分子和分母的不同，一个32位的除法需要20-140个时钟周期来执行完成，等于一个固定的时间加上每个位被除的时间。 Time (分子/ 分母) = C0 + C1* log2 (分子/分母) = C0 + C1 * (log2 (分子) &#8211; log2 (分母)). 现在的ARM处理器需要消耗20+4.3N个时钟周期，这是一个非常费时的操作，要尽可能的避免。在有些情况下，除法表达式可以用乘法表达是来重写。比方说，(a/b)&gt;c可以写成a&gt;(c*b),条件是我们已经知道b为非负数而且b*c不会超过整型数的取值范围。如果我们能够确定其中的一个操作数为unsigned，那么使用无符号除法将会更好，因为它要比有符号除法快得多。 合并除法运算和取余运算 / Combining division and remainder 在一些情况下，除法运算和取余运算都需要用到，在这种情况下，编译器会将除法运算和取余运算合并，因为除法运算总是同时返回商和余数。如果两个运算都要用到，我们可以将他们写到一起。 typedef unsigned int uint; uint div32u (uint a) { return a / 32; } int div32s (int a) { return a / 32; } 这两种除法都会避免调用除法函数（进行移位操作），另外，无符号的除法要比有符号的除法使用更少的指令。有符号的除法要耗费更多的时间，因为这种除法是使最终结果趋向于零的，而移位则是趋向于负无穷。 取模运算的替换 / An alternative for modulo arithmetic 我们一般使用取余运算进行取模，不过，有时候使用 if 语句来重写也是可行的。考虑下面的两个例子： uint modulo_func1 (uint count) { return (++count % 60); } uint modulo_func2 (uint count) { if (++count &gt;= 60) count = 0; return (count); } 第二个例子要比第一个更可取，因为由它产生的代码会更快，注意：这只是在count取值范围在0 – 59之间的时候才行。 但是我们可以使用如下的代码（笔者补充）实现等价的功能： uint modulo_func3 (uint count) { if (++count &gt;= 60) count %= 60; return (count); } 使用数组索引 / Using array indices 假设你要依据某个变量的值，设置另一个变量的取值为特定的字符，你可能会这样做： switch(queue) { case 0 : letter = &#039;W&#039;; break; case 1 : letter = &#039;S&#039;; break; case 2 : letter = &#039;U&#039;; break; } 或者这样： if(queue == 0) letter = &#039;W&#039;; else if ( queue == 1 ) letter = &#039;S&#039;; else letter = &#039;U&#039;; 有一个简洁且快速的方式是简单的将变量的取值做成一个字符串索引，例如： static char *classes = &quot;WSU&quot;; letter = classes[queue]; 全局变量 / Global variables 全局变量不会被分配在寄存器上，修改全局变量需要通过指针或者调用函数的方式间接进行。所以编译器不会将全局变量存储在寄存器中，那样会带来额外的、不必要的负担和存储空间。所以在比较关键的循环中，我们要不使用全局变量。**** **如果一个函数要频繁的使用全局变量，我们可以使用局部变量，作为全局变量的拷贝，这样就可以使用寄存器了。条件是本函数调用的任何子函数不使用这些全局变量。** 举个例子： int f(void); int g(void); int errs; void test1(void) { errs += f(); errs += g(); } void test2(void) { int localerrs = errs; localerrs += f(); localerrs += g(); errs = localerrs; } 可以看到test1()中每次加法都需要读取和存储全局变量errs，而在test2()中，localerrs分配在寄存器上，只需要一条指令。 使用别名 / Using Aliases 考虑下面的例子： void func1( int *data ) { int i; for(i = 0; i &lt; 10; i++) anyfunc(*data, i); } 即使*data从来没有变化，编译器却不知道anyfunc()没有修改它，于是程序每次用到它的时候，都要把它从内存中读出来，可能它只是某些变量的别名，这些变量在程序的其他部分被修改。如果能够确定它不会被改变，我们可以这样写： void func1( int *data ) { int i; int localdata; localdata = *data; for(i=0; i&lt;10; i++) anyfunc(localdata, i); } 这样会给编译器优化工作更多的选择余地。 活跃变量和泄漏 / Live variables and spilling 寄存器的数量在每个处理器当中都是固定的，所以在程序的某个特定的位置，可以保存在寄存器中的变量的数量是有限制的。有些编译器支持“生命周期分割”（live-range splitting），也就是说在函数的不同部分，变量可以被分配到不同的寄存器或者内存中。变量的生存范围被定义成：起点是对该变量的一次空间分配，终点是在下次空间分配之前的最后一次使用之间。在这个范围内，变量的值是合法的，是活的。在生存范围之外，变量不再被使用，是死的，它的寄存器可以供其他变量使用，这样，编译器就可以安排更多的变量到寄存器当中。 可分配到寄存器的变量需要的寄存器数量等于经过生命范围重叠的变量的数目，如果这个数目超过可用的寄存器的数量，有些变量就必须被暂时的存储到内存中。这种处理叫做“泄漏(spilling)”。 编译器优先释放最不频繁使用的变量，将释放的代价降到最低。可以通过以下方式避免变量的“释放”： 限制活跃变量的最大数目：通常可以使用简单小巧的表达式，在函数内部不使用太多的变量。把大的函数分割成更加简单的、更加小巧的多个函数，也可能会有所帮助。 使用关键字register修饰最经常使用的变量：告诉编译器这个变量将会被经常用到，要求编译器使用非常高的优先级将此变量分配到寄存器中。尽管如此，在某些情况下，变量还是可能被泄漏。 变量类型 / Variable Types C编译器支持基本的变量类型：char、short、int、long(signed、unsigned)、float、double。为变量定义最恰当的类型，非常重要，因为这样可以减少代码和数据的长度，可以非常显著的提高效率。 局部变量 / Local variables 如果可能，局部变量要避免使用char和short。对于char和short类型，编译器在每次分配空间以后，都要将这种局部变量的尺寸减少到8位或16位。这对于符号变量来说称为符号扩展，对无符号变量称为无符号扩展。这种操作是通过将寄存器左移24或16位，然后再有符号（或无符号的）右移同样的位数来实现的，需要两条指令（无符号字节变量的无符号扩展需要一条指令）。 这些移位操作可以通过使用int和unsigned int的局部变量来避免。这对于那些首先将数据调到局部变量然后利用局部变量进行运算的情况尤其重要。即使数据以8位或16位的形式输入或输出，把他们当作32位来处理仍是有意义的。 我们来考虑下面的三个例子函数： int wordinc (int a) { return a + 1; } short shortinc (short a) { return a + 1; } char charinc (char a) { return a + 1; } 他们的运算结果是相同的，但是第一个代码片断要比其他片断运行的要快。 指针 / Pointers 如果可能，我们应该使用结构体的引用作为参数，也就是结构体的指针，否则，整个结构体就会被压入堆栈，然后传递，这会降低速度。程序适用值传递可能需要几K字节，而一个简单的指针也可以达到同样的目的，只需要几个字节就可以了。 如果在函数内部不会改变结构体的内容，那么就应该将参数声明为const型的指针。举个例子： void print_data_of_a_structure (const Thestruct *data_pointer) { ...printf contents of the structure... } 这个例子代码告知编译器在函数内部不会改变外部结构体的内容，访问他们的时候，不需要重读。还可以确保编译器捕捉任何修改这个只读结构体的代码，给结构体以额外的保护。 指针链 / Pointer chains 指针链经常被用来访问结构体的信息，比如，下面的这段常见的代码： typedef struct { int x, y, z; } Point3; typedef struct { Point3 *pos, *direction; } Object; void InitPos1(Object *p) { p-&gt;pos-&gt;x = 0; p-&gt;pos-&gt;y = 0; p-&gt;pos-&gt;z = 0; } 代码中，处理器在每次赋值操作的时候都要重新装载p-&gt;pos，因为编译器不知道p-&gt;pos-&gt;x不是p-&gt;pos的别名。更好的办法是将p-&gt;pos缓存成一个局部变量，如下： void InitPos2(Object *p) { Point3 *pos = p-&gt;pos; pos-&gt;x = 0; pos-&gt;y = 0; pos-&gt;z = 0; } 另一个可能的方法是将Point3结构体包含在Object结构体中，完全避免指针的使用。 条件的执行 / Conditional Execution 条件执行主要用在if语句中，同时也会用到由关系运算(&lt;,==,&gt;等)或bool运算(&amp;&amp;, !等)组成的复杂的表达式。尽可能的保持if和else语句的简单是有好处的，这样才能很好的条件化。关系表达式应该被分成包含相似条件的若干块。 下面的例子演示了编译器如何使用条件执行： int g(int a, int b, int c, int d) { if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &lt; 0 &amp;&amp; d &lt; 0) //分组化的条件被捆绑在一起 return a + b + c + d; return -1; } 条件被分组，便以其能够条件化他们。 Boolean表达式和范围检查 / Boolean Expressions &amp; Range checking 有一种常见的boolean表达式被用来检查是否一个变量取值在某个特定的范围内，比方说，检查一个点是否在一个窗口内。 bool PointInRectangelArea (Point p, Rectangle *r) { return (p.x &gt;= r-&gt;xmin &amp;&amp; p.x &lt; r-&gt;xmax &amp;&amp; p.y &gt;= r-&gt;ymin &amp;&amp; p.y &lt; r-&gt;ymax); } 这里还有一个更快的方法：把(x &gt;= min &amp;&amp; x &lt; max) 转换成 (unsigned)(x-min) &lt; (max-min). 尤其是min为0时，更为有效。下面是优化后的代码： bool PointInRectangelArea (Point p, Rectangle *r) { return ((unsigned) (p.x - r-&gt;xmin) &lt; r-&gt;xmax &amp;&amp; (unsigned) (p.y - r-&gt;ymin) &lt; r-&gt;ymax); } Boolean表达式&amp;与零的比较 / Boolean Expressions &amp; Compares with zero 在比较(CMP)指令后，相应的处理器标志位就会被设置。这些标志位也可以被其他的指令设置，诸如MOV, ADD, AND, MUL, 也就是基本的数学和逻辑运算指令（数据处理指令）。假如一条数据处理指令要设置这些标志位，那么N和Z标志位的设置方法跟把数字和零比较的设置方法是一样的。N标志位表示结果是不是负数，Z标志位表示结果是不是零。 在C语言中，处理器中的N和Z标志位对应的有符号数的关系运算符是x &lt; 0, x &gt;= 0, x == 0, x != 0，无符号数对应的是x == 0, x != 0 (or x &gt; 0)。 C语言中，每用到一个关系运算符，编译器就会产生一个比较指令。如果关系运算符是上面的其中一个，在数据处理指令紧跟比较指令的情况下，编译器就会将比较指令优化掉。比如： int aFunction(int x, int y) { if (x + y &lt; 0) return 1; else return 0; } 这样做，会在关键循环中节省比较指令，使代码长度减少，效率增加。C语言中没有借位(carry)标志位和溢出(overflow)标志位的概念，所以如果不使用内嵌汇编语言，要访问C和V标志位是不可能的。尽管如此，编译器支持借位标志位（无符号数溢出），比方说： int sum(int x, int y) { int res; res = x + y; if ((unsigned) res &lt; (unsigned) x) // carry set? // res++; return res; } 惰性评估计算 / Lazy Evaluation Exploitation 在类似与这样的 if(a&gt;10 &amp;&amp; b=4) 语句中, 确保AND表达式的第一部分最有可能为false, 结果第二部分极有可能不被执行. 用switch() 代替if&#8230;else&#8230;，在条件选择比较多的情况下，可以用if…else…else…，像这样： if( val == 1) dostuff1(); else if (val == 2) dostuff2(); else if (val == 3) dostuff3(); 使用switch可以更快： switch( val ) { case 1: dostuff1(); break; case 2: dostuff2(); break; case 3: dostuff3(); break; } 在if语句中，即使是最后一个条件成立，也要先判断所有前面的条件是否成立。Switch语句能够去除这些额外的工作。如果你不得不使用if…else，那就把最可能的成立的条件放在前面。 二分分解 / Binary Breakdown 把判断条件做成二进制的风格，比如，不要使用下面的列表： if(a == 1) { } else if(a == 2) { } else if(a == 3) { } else if(a == 4) { } else if(a == 5) { } else if(a == 6) { } else if(a == 7) { } else if(a == 8) { } } 而采用： if(a &lt;= 4) { if(a == 1) { } else if(a == 2) { } else if(a == 3) { } else if(a == 4) { } } else { if(a == 5) { } else if(a == 6) { } else if(a == 7) { } else if(a == 8) { } } 甚至： if(a &lt;= 4) { if(a &lt;= 2) { if(a == 1) { /* a is 1 */ } else { /* a must be 2 */ } } else { if(a == 3) { /* a is 3 */ } else { /* a must be 4 */ } } } else { if(a &lt;= 6) { if(a == 5) { /* a is 5 */ } else { /* a must be 6 */ } } else { if(a == 7) { /* a is 7 */ } else { /* a must be 8 */ } } } 慢速、低效： c = getch(); switch(c){ case &#039;A&#039;: { do something; break; } case &#039;H&#039;: { do something; break; } case &#039;Z&#039;: { do something; break; } } 快速、高效： c = getch(); switch(c) { case 0: { do something; break; } case 1: { do something; break; } case 2: { do something; break; } } 以上是两个case语句之间的比较 switch语句和查找表 / Switch statement vs. lookup tables switch语句通常用于以下情况： 调用几个函数中的一个 设置一个变量或返回值 执行几个代码片断中的一个 如果case表示是密集的，在使用switch语句的前两种情况中，可以使用效率更高的查找表。比如下面的两个实现汇编代码转换成字符串的例程： char * Condition_String1(int condition) { switch(condition) { case 0: return &quot;EQ&quot;; case 1: return &quot;NE&quot;; case 2: return &quot;CS&quot;; case 3: return &quot;CC&quot;; case 4: return &quot;MI&quot;; case 5: return &quot;PL&quot;; case 6: return &quot;VS&quot;; case 7: return &quot;VC&quot;; case 8: return &quot;HI&quot;; case 9: return &quot;LS&quot;; case 10: return &quot;GE&quot;; case 11: return &quot;LT&quot;; case 12: return &quot;GT&quot;; case 13: return &quot;LE&quot;; case 14: return &quot;&quot;; default: return 0; } } char * Condition_String2(int condition) { if((unsigned) condition &gt;= 15) return 0; return &quot;EQNECSCCMIPLVSVCHILSGELTGTLE&quot; + 3 * condition; } 第一个例程需要240个字节，第二个只需要72个。 循环终止 / Loop termination 如果不加留意地编写循环终止条件，就可能会给程序带来明显的负担。我们应该尽量使用“倒数到零”的循环，使用简单的循环终止条件。循环终止条件相对简单，程序在执行的时候也会消耗相对少的时间。拿下面两个计算n!的例子来说，第一个例子使用递增循环，第二个使用递减循环。 int fact1_func (int n) { int i, fact = 1; for (i = 1; i &lt;= n; i++) fact *= i; return (fact); } int fact2_func(int n){ int i, fact = 1; for (i = n; i != 0; i–) fact *= i; return (fact);} 结果是，第二个例子要比第一个快得多。 更快的for()循环 / Faster for() loops 这是一个简单而有效的概念，通常情况下，我们习惯把for循环写成这样： for( i = 0; i &lt; 10; i++){ ... } i 值依次为：0,1,2,3,4,5,6,7,8,9 在不在乎循环计数器顺序的情况下，我们可以这样： for( i = 10; i--; ) { ... } i 值依次为: 9,8,7,6,5,4,3,2,1,0,而且循环要更快 这种方法是可行的，因为它是用更快的i&#8211;作为测试条件的，也就是说“i是否为非零数，如果是减一，然后继续”。相对于原先的代码，处理器不得不“把i减去10，结果是否为非零数，如果是，增加i，然后继续”，在紧密循环(tight loop)中，这会产生显著的区别。 这种语法看起来有一点陌生，却完全合法。循环中的第三条语句是可选的（无限循环可以写成这样for(;;)）,下面的写法也可以取得同样的效果： for(i = 10; i; i--){} 或者: for(i = 10; i != 0; i--){} 我们唯一要小心的地方是要记住循环需要停止在0（如果循环是从50-80，这样做就不行了），而且循环的计数器为倒计数方式。 另外，我们还可以把计数器分配到寄存器上，可以产生更为有效的代码。这种将循环计数器初始化成循环次数，然后递减到零的方法，同样适用于while和do语句。 混合循环/ Loop jamming 在可以使用一个循环的场合，决不要使用两个。但是如果你要在循环中进行大量的工作，超过处理器的指令缓冲区，在这种情况下，使用两个分开的循环可能会更快，因为有可能这两个循环都被完整的保存在指令缓冲区里了。 //原先的代码 for(i = 0; i &lt; 100; i++){ stuff(); } for(i = 0; i &lt; 100; i++){ morestuff(); } //更好的做法 for(i = 0; i &lt; 100; i++){ stuff(); morestuff(); } 函数循环 / Function Looping 调用函数的时候，在性能上就会付出一定的代价。不光要改变程序指针，还要将那些正在使用的变量压入堆栈，分配新的变量空间。为了提高程序的效率，在程序的函数结构上，有很多工作可以做。保证程序的可读性的同时，还要尽量控制程序的大小。 如果一个函数在一个循环中被频繁调用，就可以考虑将这个循环放在函数的里面，这样可以免去重复调用函数的负担，比如： for(i = 0 ; i &lt; 100 ; i++) { func(t,i); } void func(int w, d) { lots of stuff. } 可以写成： func(t); void func(w) { for(i = 0; i &lt; 100; i++) { //lots of stuff. } } 展开循环 / Loop unrolling 为了提高效率，可以将小的循环解开，不过这样会增加代码的尺寸。循环被拆开后，会降低循环计数器更新的次数，减少所执行的循环的分支数目。如果循环只重复几次，那它完全可以被拆解开，这样，由循环所带来的额外开销就会消失。 比如: for(i = 0; i &lt; 3; i++){ something(i); } //更高效的方式： something(0); something(1); something(2); 因为在每次的循环中，i 的值都会增加，然后检查是否有效。编译器经常会把这种简单的循环解开，前提是这些循环的次数是固定的。对于这样的循环： for(i = 0; i &lt; limit; i++) { ... } 就不可能被拆解，因为我们不知道它循环的次数到底是多少。不过，将这种类型的循环拆解开并不是不可能的。 与简单循环相比，下面的代码的长度要长很多，然而具有高得多的效率。选择8作为分块大小，只是用来演示，任何合适的长度都是可行的。例子中，循环的成立条件每八次才被检验一次，而不是每次都要检验。如果需要处理的数组的大小是确定的，我们就可以使用数组的大小作为分块的大小（或者是能够整除数组长度的数值）。不过，分块的大小跟系统的缓存大小有关。 #include&lt;stdio.H&gt; #define BLOCKSIZE (8) int main(void){ int i = 0; int limit = 33; /* could be anything */ int blocklimit; /* The limit may not be divisible by BLOCKSIZE, go as near as we can first, then tidy up. */ blocklimit = (limit / BLOCKSIZE) * BLOCKSIZE; /* unroll the loop in blocks of 8 */ while(i &amp;lt; blocklimit) { printf(&amp;quot;process(%d)\n&amp;quot;, i); printf(&amp;quot;process(%d)\n&amp;quot;, i+1); printf(&amp;quot;process(%d)\n&amp;quot;, i+2); printf(&amp;quot;process(%d)\n&amp;quot;, i+3); printf(&amp;quot;process(%d)\n&amp;quot;, i+4); printf(&amp;quot;process(%d)\n&amp;quot;, i+5); printf(&amp;quot;process(%d)\n&amp;quot;, i+6); printf(&amp;quot;process(%d)\n&amp;quot;, i+7); /* update the counter */ i += 8; } /* * There may be some left to do. * This could be done as a simple for() loop, * but a switch is faster (and more interesting) */ if( i &amp;lt; limit ) { /* Jump into the case at the place that will allow * us to finish off the appropriate number of items. */ switch( limit - i ) { case 7 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 6 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 5 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 4 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 3 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 2 : printf(&amp;quot;process(%d)\n&amp;quot;, i); i++; case 1 : printf(&amp;quot;process(%d)\n&amp;quot;, i); } } return 0;} &nbsp; 计算非零位的个数 / counting the number of bits set 例1：测试单个的最低位，计数，然后移位。 //example1 int countbit1(uint n) { int bits = 0; while (n != 0) { if(n &amp; 1) bits++; n &gt;&gt;= 1; } return bits; } 例2：先除4，然后计算被4处的每个部分。循环拆解经常会给程序优化带来新的机会。 //example - 2 int countbit2(uint n) { int bits = 0; while (n != 0) { if (n &amp; 1) bits++; if (n &amp; 2) bits++; if (n &amp; 4) bits++; if (n &amp; 8) bits++; n &gt;&gt;= 4; } return bits; } 尽早地退出循环 / Early loop breaking 通常没有必要遍历整个循环。举例来说，在数组中搜索一个特定的值，我们可以在找到我们需要值之后立刻退出循环。下面的例子在10000个数字中搜索-99。 found = FALSE; for(i=0;i&lt;10000;i++) { if(list[i] == -99) { found = TRUE; } } if(found) printf(&quot;Yes, there is a -99. Hooray!\n&quot;); 这样做是可行的，但是不管这个被搜索到的项目出现在什么位置，都会搜索整个数组。跟好的方法是，再找到我们需要的数字以后，立刻退出循环。 found = FALSE; for(i = 0; i &lt; 10000; i++) { if( list[i] == -99 ) { found = TRUE; break; } } if( found ) printf(&quot;Yes, there is a -99. Hooray!\n&quot;); 如果数字出现在位置23上，循环就会终止，忽略剩下的9977个。 函数设计 / Function Design 保持函数短小精悍，是对的。这可以使编译器能够跟高效地进行其他的优化，比如寄存器分配。 调用函数的开销 / Function call overhead 对处理器而言，调用函数的开销是很小的，通常，在被调用函数所进行的工作中，所占的比例也很小。能够使用寄存器传递的函数参数个数是有限制的。这些参数可以是整型兼容的（char,short,int以及float都占用一个字），或者是4个字以内的结构体（包括2个字的double和long long）。假如参数的限制是4，那么第5个及后面的字都会被保存到堆栈中。这会增加在调用函数是存储这些参数的，以及在被调用函数中恢复这些参数的代价。 int f1(int a, int b, int c, int d) { return a + b + c + d; } int g1(void) { return f1(1, 2, 3, 4); } int f2(int a, int b, int c, int d, int e, int f) { return a + b + c + d + e + f; } ing g2(void) { return f2(1, 2, 3, 4, 5, 6); } g2函数中，第5、6个参数被保存在堆栈中，在f2中被恢复，每个参数带来2次内存访问。 最小化参数传递的开销 / Minimizing parameter passing overhead 为了将传递参数给函数的代价降至最低，我们可以： 尽可能确保函数的形参不多于四个，甚至更少，这样就不会使用堆栈来传递参数。 如果一个函数形参多于四个，那就确保在这个函数能够做大量的工作，这样就可以抵消由传递堆栈参数所付出的代价。 用指向结构体的指针作形参，而不是结构体本身。 把相关的参数放到一个结构里里面，然后把它的指针传给函数，可以减少参数的个数，增加程序的可读性。 将long类型的参数的个数降到最小，因为它使用两个参数的空间。对于double也同样适用。 避免出现参数的一部分使用寄存器传输，另一部分使用堆栈传输的情况。这种情况下参数将被全部压到堆栈里。 避免出现函数的参数个数不定的情况。这种情况下，所有参数都使用堆栈。 叶子函数 / Leaf functions 如果一个函数不再调用其他函数，这样的函数被称为叶子函数。在许多应用程序中，大约一半的函数调用是对叶子函数的调用。叶子函数在所有平台上都可以得到非常高效的编译，因为他们不需要进行参数的保存和恢复。在入口压栈和在出口退栈的代价，跟一个足够复杂的需要4个或者5个参数的叶子函数所完成的工作相比，是非常小的。如果可能的话，我们就要尽量安排经常被调用的函数成为叶子函数。函数被调用的次数可以通过模型工具（profiling facility）来确定。这里有几种方法可以确保函数被编译成叶子函数： 不调用其他函数：包括那些被转换成调用C语言库函数的运算，比如除法、浮点运算。 使用关键字__inline修饰小的函数。 内联函数 / Inline functions 对于所有调试选项，内嵌函数是被禁止的。使用inline关键字修饰函数后，跟普通的函数调用不同，代码中对该函数的调用将会被函数体本身代替。这会使代码更快，另一方面它会影响代码的长度，尤其是内嵌函数比较大而且经常被调用的情况下。 __inline int square(int x) { return x * x; } double length(int x, int y){ return sqrt(square(x) + square(y)); } 使用内嵌函数有几个优点： 没有调用函数的开销。 因为函数被直接代替，没有任何额外的开销，比如存储和恢复寄存器。 更低的参数赋值开销。 参数传递的开销通常会更低，因为它不需要复制变量。如果其中一些参数是常量，编译器还可以作进一步的优化。 内嵌函数的缺点是如果函数在许多地方被调用，将会增加代码的长度。长度差别的大小非常依赖于内嵌函数的大小和调用的次数。 仅将少数关键函数设置成内嵌函数是明智的。如果设置得当，内嵌函数可以减少代码的长度，一次函数调用需要一定数量的指令，但是，使用优化过的内嵌函数可以编译成更少的指令。 使用查找表 / Using Lookup Tables 有些函数可以近似成查找表，这样可以显著的提高效率。查找表的精度一般比计算公式的精度低，不过在大多数程序中，这种精度就足够了。 许多信号处理软件（比如MODEM调制软件）会大量的使用sin和cos函数，这些函数会带来大量的数学运算。对于实时系统来说，精度不是很重要，sin/cos查找表显得更加实用。使用查找表的时候，尽量将相近的运算合并成一个查找表，这样要比使用多个查找表要更快和使用更少的空间。 浮点运算 / Floating-Point Arithmetic 尽管浮点运算对于任何处理器来讲都是很费时间的，有的时候，我们还是不得不用到浮点运算，比方说实现信号处理。尽管如此，编写浮点运算代码的时候，我们要牢记： 浮点除法是慢的 除法要比加法或者乘法慢两倍，我们可以把被一个常数除的运算写成被这个数的倒数乘（比如，x=x/3.0写成x=x*(1.0/3.0)）。倒数的计算在编译阶段就被完成。 使用float代替double Float型变量消耗更少的内存和寄存器，而且因为它的低精度所以具有更高的效率。在精度足够的情况下，就要使用float。 不要使用先验函数（transcendental functions）， 先验函数（比如sin，cos，log）是通过使用一系列的乘法和加法实现的，所以这些运算会比普通的乘法慢10倍以上。 简化浮点表达式 编译器在整型跟浮点型混合的运算中不会进行太多的优化。比如3 * (x / 3) 不会被优化成x，因为浮点运算通常会导致精度的降低，甚至表达式的顺序都是重要的： (a + b) + c 不等于 a + (b + c)。因此，进行手动的优化是有好处的。 不过，在特定的场合下，浮点运算的效率达不到指定的水平，这种情况下，最好的办法可能是放弃浮点运算，转而使用定点运算。当变量的变化范围足够的小，定点运算要比浮点运算精度更高、速度更快。 其他的技巧 / Misc tips 一般情况下，可以用存储空间换取时间。你可以缓存那些经常用到的数据，而不是每次都重新计算、或者重新装载。比如sin/cos表，或者伪随机数的表（如果你不是真的需要随机数，你可以在开始的时候计算1000个，在随后的代码中重复利用就是了） 尽量少的使用全局变量。 将一个文件内部的变量声明成静态的，除非它有必要成为全局的。 不要使用递归。递归可以使代码非常整齐和美观，但会产生大量的函数调用和开销。 访问单维数组要比多维数组快 使用#defined宏代替经常用到的小函数。 引用/References Writing Efficient C for ARM Document number: ARM DAI 0034A Issued: January 1998 Copyright Advanced RISC Machines Ltd. (ARM) 1998 Richard&#8217;s C Optimization page OR: How to make your C, C++ or Java program run faster with little effort. Code Optimization Using the GNU C Compiler By Rahul U Joshi. Compile C Faster on Linux [Christopher W. Fraser (Microsoft Research), David R. Hanson (Princeton University)] CODE OPTIMIZATION &#8211; COMPILER [1] [2][Thanks to Craig Burley for the excellent comments. Thanks to Timothy Prince for the note on architectures with Instruction Level Parallelism]. An Evolutionary Analysis of GNU C Optimizations [Using Natural Selection to Investigate Software Complexities by Scott Robert Ladd. Updated: 16 December 2003] 其他网络资源 / Other URLs http://www.xs4all.nl/~ekonijn/loopy.html http://www.public.asu.edu/~sshetty/Optimizing_Code_Manual.doc http://www.abarnett.demon.co.uk/tutorial.html &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 本文翻译自： codeproject，感谢codingwu的整理，转载请注明出处。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言高级编程指南]]></title>
    <url>%2F2016%2F07%2F03%2FProgram-C%2Fc-advaced-programming%2F</url>
    <content type="text"><![CDATA[整形溢出和提升大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子, 你觉得输出结果是什么: 123456789101112int main(int argc, char** argv) &#123; long i = -1; if (i &lt; sizeof(i)) &#123; printf("OK\n"); &#125; else &#123; printf("error\n"); &#125; return 0;&#125; 当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因为sizeof操作返回的是一个 size_t类型的无符号数。 在C99/C11标准里写道: “If the operand that has unsigned integer type has rank greater orequal to the rank of the type of the other operand, then the operandwith signed integer type is converted to the type of the operand withunsigned integer type.” 在 C 标准里面 size_t 至少是一个 16 位的无符号整数, 对于给定的架构 size_t 一般对应 long, 所以sizeof（int）和 size_t 至少相等, 这就带来了可移植性的问题, C 标准没有定义 short, int, long, longlong 的大小, 只是说明了他们的最小长度, 对于 x86_64 架构, long 在Linux下是 64 位, 而在 64 位 Windows 下是 32 位。一般的方法是采用固定长度的类型比如定义在 C99 头文件stdint.h中的uint16_t, int32_t, uint_least16_t, uint_fast16_t 等。 如果 int 可以表示原始类型的所有值,那么这个操作数会转换成 int, 否则他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536, 但是在 16 位系统返回 0。 123456uint32_t sum()&#123; uint16_t a = 65535; uint16_t b = 1; return a+b;&#125; 对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。 char c = 128; char d = 129; printf(&quot;%d,%d\n&quot;,c,d); 内存管理和分配malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取决与系统实现。malloc(0) 返回一个空指针或者 unique pointer, 如果 size 是表达式的运算结果, 确保没有整形溢出。 “If the size of the space requested is 0, the behavior isimplementation- defined: the value returned shall be either a nullpointer or a unique pointer.” 12345678size_t computed_size;if (elem_size &amp;&amp; num &gt; SIZE_MAX / elem_size) &#123; errno = ENOMEM; err(1, "overflow");&#125;computed_size = elem_size*num; malloc 不会给分配的内存初始化，如果要对新分配的内存初始化，可以用 calloc 代替 malloc, 一般情况下给序列分配相等大小的元素时, 用 calloc 来代替用表达式计算大小, calloc 会把内存初始化为 0。 realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。 “In case of failure realloc shall return NULL and leave provided memoryobject intact. Thus it is important not only to check for integeroverflow of size argument, but also to correctly handle object size ifrealloc fails.” 下面这段代码可以带你领会 malloc, calloc，realloc, free 的用法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;errno.h&gt;#define VECTOR_OK 0#define VECTOR_NULL_ERROR 1#define VECTOR_SIZE_ERROR 2#define VECTOR_ALLOC_ERROR 3struct vector &#123; int *data; size_t size;&#125;;int create_vector(struct vector *vc, size_t num) &#123; if (vc == NULL) &#123; return VECTOR_NULL_ERROR; &#125; vc-&gt;data = 0; vc-&gt;size = 0; /* check for integer and SIZE_MAX overflow */ if (num == 0 || SIZE_MAX / num &lt; sizeof(int)) &#123; errno = ENOMEM; return VECTOR_SIZE_ERROR; &#125; vc-&gt;data = calloc(num, sizeof(int)); /* calloc faild */ if (vc-&gt;data == NULL) &#123; return VECTOR_ALLOC_ERROR; &#125; vc-&gt;size = num * sizeof(int); return VECTOR_OK;&#125;int grow_vector(struct vector *vc) &#123; void *newptr = 0; size_t newsize; if (vc == NULL) &#123; return VECTOR_NULL_ERROR; &#125; /* check for integer and SIZE_MAX overflow */ if (vc-&gt;size == 0 || SIZE_MAX / 2 &lt; vc-&gt;size) &#123; errno = ENOMEM; return VECTOR_SIZE_ERROR; &#125; newsize = vc-&gt;size * 2; newptr = realloc(vc-&gt;data, newsize); /* realloc faild; vector stays intact size was not changed */ if (newptr == NULL) &#123; return VECTOR_ALLOC_ERROR; &#125; /* upon success; update new address and size */ vc-&gt;data = newptr; vc-&gt;size = newsize; return VECTOR_OK;&#125; 避免重大错误 使用未初始化的变量 C 语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和 C++ 不同，C++ 保证所有变量在使用之前都得到初始化，Java 尽量保证 变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。 free 错误 对空指针调用 free, 对不是由 malloc family 函数分配的指针调用 free,或者对已经调用 free 的指针再次调用 free。 一开始初始化指针为 NULL 可以减少错误, GCC 和 Clang 编译器有 -Wuninitialized 选项来对未初始化的变量显示警告信息, 另外不要将同一个指针用于静态变量和动态变量。 1234567char *ptr = NULL;void nullfree(void **pptr) &#123; void *ptr = *pptr; assert(ptr != NULL) free(ptr); *pptr = NULL;&#125; 对空指针解引用，数组越界访问 对 NULL 指针或者 free’d 内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如 Java 里的 array 就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改 ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中 cost is terrible。 违反类型规则 把 int* 指针 cast 成 float*，然后对它解引用，在 C 里面会引发 undefined behavior，C 规定这种类型的转换需要使用 memset，C++ 里面有个 reinterpret_cast 函数用于无关类型之间的转换，reinterpret_cast &lt;new_type&gt; (expression) 防止内存泄漏内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用 free 来释放内存，常用的几种方法如下： 在程序启动的时候分配 在程序启动的时候分配需要的 heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。 使用变长数组（VLA） 如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字 C 标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大 VLA 内存是 SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。 使用引用计数 引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加 1, 每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子： 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define MAX_REF_OBJ 100#define RC_ERROR -1struct mem_obj_t&#123; void *ptr; uint16_t count;&#125;;static struct mem_obj_t references[MAX_REF_OBJ];static uint16_t reference_count = 0;/* create memory object and return handle */uint16_t create(size_t size)&#123; if (reference_count &gt;= MAX_REF_OBJ) return RC_ERROR; if (size)&#123; void *ptr = calloc(1, size); if (ptr != NULL)&#123; references[reference_count].ptr = ptr; references[reference_count].count = 0; return reference_count++; &#125; &#125; return RC_ERROR;&#125;/* get memory object and increment reference counter */void* retain(uint16_t handle)&#123; if(handle &lt; reference_count &amp;&amp; handle &gt;= 0)&#123; references[handle].count++; return references[handle].ptr; &#125; else &#123; return NULL; &#125;&#125;/* decrement reference counter */void release(uint16_t handle)&#123; printf("release\n"); if(handle &lt; reference_count &amp;&amp; handle &gt;= 0)&#123; struct mem_obj_t *object = &amp;references[handle]; if (object-&gt;count &lt;= 1)&#123; printf("released\n"); free(object-&gt;ptr); reference_count--; &#125; else &#123; printf("decremented\n"); object-&gt;count--; &#125; &#125;&#125; C++ 标准库有个 auto_ptr 智能指针，能够自动释放指针所指对象的内存，C++ boost 库有个boost::shared_ptr 智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子： “Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.” 123456789101112131415#include &lt;boost/smart_ptr.hpp&gt;#include &lt;iostream&gt;int main()&#123; // Basic useage boost::shared_ptr&lt;int&gt; p1(new int(10)); std::cout &lt;&lt; "ref count of p1: " &lt;&lt; p1.use_count() &lt;&lt; std::endl; boost::shared_ptr&lt;int&gt; p2(p1); // or p2 = p1; std::cout &lt;&lt; "ref count of p1: " &lt;&lt; p1.use_count() &lt;&lt; std::endl; *p1 = 999; std::cout &lt;&lt; "*p2: " &lt;&lt; *p2 &lt;&lt; std::endl; p2.reset(); std::cout &lt;&lt; "ref count of p1: " &lt;&lt; p1.use_count() &lt;&lt; std::endl; return 0;&#125; 内存池，有利于减少内存碎片，看下面这个例子： 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;struct mem_pool_t&#123; void* ptr;//指向内存池起始地址 size_t size;//内存池大小 size_t used;//已用内存大小&#125;;//create memory poolstruct mem_pool_t* create_pool(size_t size)&#123; mem_pool_t* pool=calloc(1,sizeof(struct men_pool_t)); if(pool!=NULL)&#123; void* mem=calloc(1,size); if(mem!=NULL)&#123; pool-&gt;ptr=mem; pool-&gt;size=size; pool-&gt;used=0; return pool; &#125; &#125; return NULL;&#125;//allocate memory from poolvoid* pool_alloc(mem_pool_t* pool,size_t size)&#123; if(pool=NULL) return NULL; size_t bytes_left=pool-&gt;size-pool-&gt;used; if(size&amp;&amp;size&lt;=bytes_left)&#123; void* mem=pool-&gt;ptr+pool-&gt;used; pool-&gt;used+=size; return mem; &#125; return NULL；&#125;／／release memory of the poolvoid pool_free(mem_pool_t* pool)&#123; if(pool!=NULL)&#123; free(pool-&gt;ptr); free(pool); &#125;&#125; 垃圾回收机制 引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是 MARK AND SWEEP 算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。 Java 采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA 的垃圾回收和C++ 的析构函数又不一样，C++ 保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而 JAVA 不能保证对象一定被析构。 指针和数组我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是 const 的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个 const 左值，指向地一个元素的 const 指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。 但是也有例外，什么情况下数组名不是一个指针呢？ 当它是 sizeof 操作符的操作数时，返回数组占的内存字节数 当它是取地址操作 &amp; 的操作数时，返回一个数组的地址 看下面这个例子： 1234567891011short a[] = &#123;1,2,3&#125;;short *pa;short (*px)[];void init()&#123; pa = a; px = &amp;a; printf("a:%p; pa:%p; px:%p\n", a, pa, px); printf("a[1]:%i; pa[1]:%i (*px)[1]:%i\n", a[1], pa[1],(*px)[1]);&#125; a 是一个 short 类型数组，pa 是一个指向 short 类型的指针，px 呢？ px 是一个指向数组类型的指针，在 a 被赋值给 pa 之前，他的值被转换成一个指向数组第一个元素的指针，下面那个 a 却没有转换，因为遇到的是 &amp; 操作符。 数组下标 a[1] 等价于 (a+1), 和 p[1] 一样，也指向 *(p+1)，但是两者还是有区别的，a 是一个数组，它实际上存储的是第一个元素的地址，所以数组 a 是用来定位第一个元素的，而 pa 不一样，它就是一个指针，不是用来定位的。 再比如： 1234567int a[10];int b[10];int *a;c=&amp;a[0]; //c是指向数组a地一个元素的指针c=a; //a自动转换成指向第一个元素的指针，实际上是指针拷贝b=a; //非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组a=c; //非法的，你不能修改const指针的值]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPlusPlus 设计模式]]></title>
    <url>%2F2016%2F06%2F28%2FProgram-C%2Fcplus-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%2F</url>
    <content type="text"><![CDATA[【设计模式】C++设计模式（全26讲） 单例模式 单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。 定义一个单例类： 私有化它的构造函数，以防止外界创建单例类的对象； 使用类的私有静态指针变量指向类的唯一实例； 使用一个公有的静态方法获取该实例。 懒汉模式 即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。 需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的 if 语句，从而non thread safety. 使用double-check来保证thread safety.但是如果处理大量数据时，该锁才成为严重的性能瓶颈。 1. 静态成员实例的懒汉模式： 12345678910111213141516171819202122class Singleton&#123;public: static Singleton* getInstance();private: static Singleton* m_instance; Singleton()&#123;&#125;&#125;;Singleton* Singleton::getInstance()&#123; if(NULL == m_instance) &#123; Lock();//借用其它类来实现，如boost if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance;&#125; 2. 内部静态实例的懒汉模式： 12345678910111213class SingletonInside&#123;public: static SingletonInside* getInstance() &#123; Lock(); // not needed after C++0x static SingletonInside instance; UnLock(); // not needed after C++0x return instance; &#125;private: SingletonInside()&#123;&#125;&#125;; 饿汉模式 即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。 由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。 故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。 饿汉模式： 1234567891011121314class SingletonStatic&#123;public: static const SingletonStatic* getInstance() &#123; return m_instance; &#125;private: static const SingletonStatic* m_instance; SingletonStatic()&#123;&#125;&#125;;//外部初始化 before invoke mainconst SingletonStatic* SingletonStatic::m_instance = new SingletonStatic; m_pInstance 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？ 单例模式 - 线程安全 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;&gt;using namespace std; class Singleton &#123;public: static Singleton *GetInstance(); private: Singleton() &#123; cout &lt;&lt; "Singleton ctor" &lt;&lt; endl; &#125; ~Singleton() &#123; cout &lt;&lt; "Singleton dtor" &lt;&lt; endl; &#125; static Singleton *m_pInstance; class Garbo &#123; public: ~Garbo() &#123; if (Singleton::m_pInstance) &#123; cout &lt;&lt; "Garbo dtor" &lt;&lt; endl; delete Singleton::m_pInstance; &#125; &#125; &#125;; static Garbo garbo; &#125;; Singleton::Garbo Singleton::garbo; // 一定要初始化，不然程序结束时不会析构garboSingleton *Singleton::m_pInstance = NULL;Singleton *Singleton::GetInstance()&#123; if (m_pInstance == NULL) m_pInstance = new Singleton; return m_pInstance; &#125; int main()&#123; Singleton *p1 = Singleton::GetInstance(); Singleton *p2 = Singleton::GetInstance(); if (p1 == p2) cout &lt;&lt; "p1 == p2" &lt;&lt; endl; return 0;&#125; 12345# 输出结果如下：Singleton ctorp1 == p2Garbo dtorSingleton dtor 类 CGarbo 被定义为 CSingleton 的私有内嵌类，以防该类被在其他地方滥用。 程序运行结束时，系统会调用 CSingleton的 静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。 使用这种方法释放单例对象有以下特征： 在单例类内部定义专有的嵌套类； 在单例类内定义私有的专门用于释放的静态成员； 利用程序在结束时析构全局变量的特性，选择最终的释放时机； 使用单例的代码不需要任何操作，不必关心对象的释放。 工厂模式 在C++中利用反射和简单工厂模式实现业务模块解耦 用一个单独的类来做创造实例的过程，就是工厂。 简单工厂模式简单工厂模式基本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class AbstractProduct &#123;public: virtual ~AbstractProduct() &#123;&#125; virtual void Operation() = 0;&#125;;class ProductA : public AbstractProduct &#123;public: void Operation() &#123; cout &lt;&lt; "ProductA" &lt;&lt; endl; &#125;&#125;;class ProductB : public AbstractProduct &#123;public: void Operation() &#123; cout &lt;&lt; "ProductB" &lt;&lt; endl; &#125;&#125;;class Factory &#123;public: AbstractProduct* createProduct(char product) &#123; AbstractProduct* ap = NULL; switch(product) &#123; case 'A': ap = new ProductA(); break; case 'B': ap = new ProductB(); break; &#125; return ap; &#125;&#125;;int main() &#123; Factory* f = new Factory(); AbstractProduct* apa = f-&gt;createProduct('A'); apa-&gt;Operation(); // ProductA AbstractProduct* apb = f-&gt;createProduct('B'); apb-&gt;Operation(); // ProductB delete apa; delete apb; delete f; return 0;&#125; 12345678910111213class OperationFactory &#123;public: Operation createOperate(string operate) &#123; Operation oper = null; switch (operate) &#123; case "+": oper = new OperationAdd(); break; case "-": oper = new OperationSub(); break; case "*": oper = new OperationMul(); break; case "/": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125;; 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。 工厂方法模式工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。 工厂方法模式基本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;class Product &#123;public: virtual ~Product()&#123;&#125; virtual void Operation() = 0;&#125;;class ConcreteProductA : public Product &#123;public: void Operation() &#123; cout &lt;&lt; "ConcreteProductA" &lt;&lt; endl; &#125;&#125;;class ConcreteProductB : public Product &#123;public: void Operation() &#123; cout &lt;&lt; "ConcreteProductB" &lt;&lt; endl; &#125;&#125;;class Creator&#123;public: virtual Product* FactoryMethod() = 0; virtual ~Creator()&#123;&#125;&#125;;class ConcreteCreatorA : public Creator &#123;public: Product* FactoryMethod() &#123; return new ConcreteProductA(); &#125;&#125;;class ConcreteCreatorB : public Creator &#123;public: Product* FactoryMethod() &#123; return new ConcreteProductB(); &#125;&#125;;int main() &#123; Creator* ca = new ConcreteCreatorA(); Product* pa = ca-&gt;FactoryMethod(); pa-&gt;Operation(); // ConcreteProductA Creator* cb = new ConcreteCreatorB(); Product* pb = cb-&gt;FactoryMethod(); pb-&gt;Operation(); // ConcreteProductB delete ca; delete pa; delete cb; delete pb; return 0;&#125; 把简单工厂模式中的工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，就变成了一个工厂抽象接口和多个具体生成对象的工厂。 这样整个工厂和产品体系就没有修改，而只是扩展，符合开放 - 封闭原则。 抽象工厂模式抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式基本代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;using namespace std;class AbstractProductA &#123;public: virtual ~AbstractProductA()&#123;&#125; virtual void Operation() = 0;&#125;;class ProductA1 : public AbstractProductA &#123;public: void Operation() &#123; cout &lt;&lt; "ProductA1" &lt;&lt; endl; &#125;&#125;;class ProductA2 : public AbstractProductA &#123;public: void Operation() &#123; cout &lt;&lt; "ProductA2" &lt;&lt; endl; &#125;&#125;;class AbstractProductB &#123;public: virtual ~AbstractProductB()&#123;&#125; virtual void Operation() = 0;&#125;;class ProductB1 : public AbstractProductB &#123;public: void Operation() &#123; cout &lt;&lt; "ProductB1" &lt;&lt; endl; &#125;&#125;;class ProductB2 : public AbstractProductB &#123;public: void Operation() &#123; cout &lt;&lt; "ProductB2" &lt;&lt; endl; &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractProductA* CreateProductA() = 0; virtual AbstractProductB* CreateProductB() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class ConcreteFactory1 : public AbstractFactory &#123;public: ProductA1* CreateProductA() &#123; return new ProductA1(); &#125; ProductB1* CreateProductB() &#123; return new ProductB1(); &#125;&#125;;class ConcreteFactory2 : public AbstractFactory &#123;public: ProductA2* CreateProductA() &#123; return new ProductA2(); &#125; ProductB2* CreateProductB() &#123; return new ProductB2(); &#125;&#125;;int main() &#123; AbstractFactory* af1 = new ConcreteFactory1(); // 具体工厂创建对应的具体产品 AbstractProductA* apa1 = af1-&gt;CreateProductA(); // 工厂1创建产品A apa1-&gt;Operation(); // ProductA1 AbstractProductB* apb1 = af1-&gt;CreateProductB(); // 工厂1创建产品B apb1-&gt;Operation(); // ProductB1 AbstractFactory* af2 = new ConcreteFactory2(); AbstractProductA* apa2 = af2-&gt;CreateProductA(); // 工厂2创建产品A apa2-&gt;Operation(); // ProductA2 AbstractProductB* apb2 = af2-&gt;CreateProductB(); // 工厂2创建产品B apb2-&gt;Operation(); // ProductB2 delete apa1; delete apa2; delete af1; delete apb1; delete apb2; delete af2; return 0;&#125; 抽象工厂函数的优缺点 优点： 易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。 让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。 缺点：增加新的产品时需要改动多处代码。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview STL]]></title>
    <url>%2F2016%2F06%2F18%2FProgram-C%2FSTL%2F</url>
    <content type="text"><![CDATA[STL网站 github . huihut/note/STL.md cplusplus . stl cppreference . C++ 参考手册 CSDN专栏：STL学习笔记 组成 容器（containers） 算法（algorithms） 迭代器（iterators） 仿函数（functors） 配接器（adapters） 空间配置器（allocator） 容器（containers） 序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted） 关联式容器（associattive containers） arrayarray是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。 与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。 零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。 与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。 数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。 1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。 12 iterator end() noexcept;const_iterator end() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。 12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。 12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept; Example 1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; "myarray contains"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cbegin（）const noexcept; Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） 1const_reverse_iterator crbegin（）const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。 1const_reverse_iterator crend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。 1constexpr size_type size（）noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; "size of myints:" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; "sizeof(myints):" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125; Possible Output 12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。 1constexpr size_type max_size() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; "size of myints: " &lt;&lt; myints.size() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size of myints: " &lt;&lt; myints.max_size() &lt;&lt; '\n'; return 0;&#125; Output 12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。 1constexpr bool empty() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; "first " &lt;&lt; (first.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; std::cout &lt;&lt; "second " &lt;&lt; (second.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; return 0;&#125; Output: 12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference operator[] (size_type n);const_reference operator[] (size_type n) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference at ( size_type n );const_reference at ( size_type n ) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference front();const_reference front() const; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference back();const_reference back() const; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。 由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。 12 value_type* data() noexcept;const value_type* data() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = "Test string"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\n'; return 0;&#125; Output 1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。 1void fill (const value_type&amp; val); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; "myarray contains:"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。 与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。 1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;()))); Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; "first:"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。 123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; "first element in myarray: " &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; "\n"; std::cout &lt;&lt; "first element in mytuple: " &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; "\n"; return 0;&#125; Output 12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。 123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; "a and b are equal\n"; if (b!=c) std::cout &lt;&lt; "b and c are not equal\n"; if (b&lt;c) std::cout &lt;&lt; "b is less than c\n"; if (c&gt;b) std::cout &lt;&lt; "c is greater than b\n"; if (a&lt;=b) std::cout &lt;&lt; "a is less than or equal to b\n"; if (a&gt;=b) std::cout &lt;&lt; "a is greater than or equal to b\n"; return 0;&#125; Output 123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。 就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。 在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。 相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。 因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。 与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。 针对 vector 的各种常见操作的复杂度（效率）如下： 随机访问 - 常数 O(1) 在尾部增删元素 - 平摊（amortized）常数 O(1)}} 增删元素 - 至 vector 尾部的线性距离 O(n)}} 1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。 12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; "The contents of fifth are:"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。 1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。 123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar = foo; foo = std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;; return 0;&#125; Output 12Size of foo: 0Size of bar: 3 vector::beginvector::endvector::rbeginvector::rendvector::cbeginvector::cendvector::rcbeginvector::rcendvector::size返回vector中元素的数量。 这是vector中保存的实际对象的数量，不一定等于其存储容量。 1size_type size() const noexcept; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; "0. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; "1. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; "2. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.pop_back(); std::cout &lt;&lt; "3. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; return 0;&#125; Output 12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制， 这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。 1size_type max_size() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; myvector.size() &lt;&lt; "\n"; std::cout &lt;&lt; "capacity: " &lt;&lt; myvector.capacity() &lt;&lt; "\n"; std::cout &lt;&lt; "max_size: " &lt;&lt; myvector.max_size() &lt;&lt; "\n"; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。 如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。 如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。 如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。 注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; "myvector contains:"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。 1size_type capacity() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; (int) myvector.size() &lt;&lt; '\n'; std::cout &lt;&lt; "capacity: " &lt;&lt; (int) myvector.capacity() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size: " &lt;&lt; (int) myvector.max_size() &lt;&lt; '\n'; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0） 1bool empty() const noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "total: " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1total: 55 vector::reserve请求vector容量至少足以包含n个元素。 如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。 在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。 这个函数对vector大小没有影响，也不能改变它的元素。 1void reserve (size_type n); Example 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; "making foo grow:\n"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; "making bar grow:\n"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; return 0;&#125; Possible output 1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。 该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。 1void shrink_to_fit(); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; "1. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.resize(10); std::cout &lt;&lt; "2. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; "3. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; return 0;&#125; Possible output 1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[]vector::atvector::frontvector::backvector::datavector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。 在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。 在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。 在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。 所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。 1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il); Example 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; "Size of first: " &lt;&lt; int (first.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of second: " &lt;&lt; int (second.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of third: " &lt;&lt; int (third.size()) &lt;&lt; '\n'; return 0;&#125; Output 123Size of first: 7Size of second: 5Size of third: 3 补充：vector::assign 与 vector::operator= 的区别： vector::assign 实现源码 12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125; vector::operator= 实现源码 12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "myvector stores " &lt;&lt; int(myvector.size()) &lt;&lt; " numbers.\n"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "The elements of myvector add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); Example 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // "it" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; "myvector contains:"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 501 502 503 300 300 400 400 200 100 100 100 补充：insert 迭代器野指针错误： 123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125; 改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。 这有效地减少了被去除的元素的数量，从而破坏了容器的大小。 由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; "myvector contains:"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。 在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。 请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。 1void swap (vector&amp; x); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; "foo contains:"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "bar contains:"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。 不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating 1void clear() noexcept; Example 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125; Output 12345678950 50 50 50 50v1 size = 5v1 capacity = 5v1 size = 0v1 capacity = 511 22v1 size = 2v1 capacity = 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。 12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args); Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; "myvector contains:"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。 这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。 该元素是通过调用allocator_traits :: construct来转换args来创建的。 与push_back相比，emplace_back可以避免额外的复制和移动操作。 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; "I am being constructed.\n"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; "I am being moved.\n"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; "emplace_back:\n"; elections.emplace_back("Nelson Mandela", "South Africa", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; "\npush_back:\n"; reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936)); std::cout &lt;&lt; "\nContents:\n"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was re-elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125;&#125; Output 12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。 1allocator_type get_allocator() const noexcept; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; "The allocated array contains:"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125; Output 1The allocated array contains: 0 1 2 3 4 relational operators (vector)swap (vector)vector dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。 因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。 两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。 对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。 deque上常见操作的复杂性（效率）如下： 随机访问 - 常数O(1) 在结尾或开头插入或移除元素 - 摊销不变O(1) 插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容： Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; "The contents of fifth are:"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地增加了一个容器的大小。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "mydeque stores " &lt;&lt; (int) mydeque.size() &lt;&lt; " numbers.\n"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。 这有效地增加了一个容器的大小。 12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; "mydeque contains:"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; "The elements of mydeque add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。 这破坏了被删除的元素。 1void pop_front(); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; "Popping out the elements in mydeque:"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; "\nThe final size of mydeque is " &lt;&lt; int(mydeque.size()) &lt;&lt; '\n'; return 0;&#125; Output 12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。 12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表 之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。 与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。 的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。 该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; "first:" ; for (int&amp; x: first) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x: second) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "third:"; for (int&amp; x: third) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fourth:"; for (int&amp; x: fourth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fifth:"; for (int&amp; x: fifth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "sixth:"; for (int&amp; x: sixth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Possible output 1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_listforward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。 返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。 12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。 一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。 返回的价值不得解除引用。 1const_iterator cbefore_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 19 77 2 16 liststackqueuepriority_queuesetmultisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种： 1typedef pair&lt;const Key, T&gt; value_type; 在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施 12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容： （1）空容器构造函数（默认构造函数） 构造一个空的容器，没有元素。 （2）范围构造函数 构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。 （3）复制构造函数（并用分配器复制） 使用x中的每个元素的副本构造一个容器。 （4）移动构造函数（并与分配器一起移动） 构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。 （5）初始化列表构造函数 用il中的每个元素的副本构造一个容器。 12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); Example 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。 由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。 如果容器是空的，则返回的迭代器值不应被解除引用。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 123a =&gt; 200b =&gt; 100c =&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。 1key_compare key_comp() const; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; "mymap contains:\n"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\n'; return 0;&#125; Output 1234mymap contains:a =&gt; 100b =&gt; 200c =&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。 1value_compare value_comp() const; Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; "mymap contains:\n"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125; Output 1234mymap contains:x =&gt; 1001y =&gt; 2002z =&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。 如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 另一个成员函数map::count可以用来检查一个特定的键是否存在。 12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; "elements in mymap:" &lt;&lt; '\n'; std::cout &lt;&lt; "a =&gt; " &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "c =&gt; " &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "d =&gt; " &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 1234elements in mymap:a =&gt; 50c =&gt; 150d =&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。 由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。 如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。 1size_type count (const key_type&amp; k) const; Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; " is an element of mymap.\n"; else std::cout &lt;&lt; " is not an element of mymap.\n"; &#125; return 0;&#125; Output 1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限 返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。 一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::upper_bound将迭代器返回到上限 返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。 类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::equal_range获取相同元素的范围 返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。 12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; "lower bound points to: "; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.first-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "upper bound points to: "; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.second-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12lower bound points to: &apos;b&apos; =&gt; 20upper bound points to: &apos;c&apos; =&gt; 30 multimap无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括： unordered_set unordered_multiset unordered_map unordered_multimap 都是以哈希表实现的。 unordered_set、unodered_multiset结构： unordered_map、unodered_multimap结构： unordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 1template &lt;class... Types&gt; class tuple; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple ("test", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; "foo contains: "; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\n'; return 0;&#125; Output 1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。 这涉及单独构建其元素，初始化取决于调用的构造函数形式： （1）默认的构造函数 构建一个 元组对象的元素值初始化。 （2）复制/移动构造函数 该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。 （3）隐式转换构造函数 同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。 （4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。 （5）对转换构造函数 该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。 （6）分配器版本 和上面的版本一样，除了每个元素都是使用allocator alloc构造的。 1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr); Example 123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; "sixth contains: " &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; " and " &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\n'; return 0;&#125; Output 1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 pair是tuple（元组）的一个特例。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。 应用： 可以将两个类型数据组合成一个如map&lt;key, value&gt; 当某个函数需要两个返回值时 1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。 这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式： （1）默认的构造函数 构建一个 对对象的元素值初始化。 （2）复制/移动构造函数（和隐式转换） 该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。 （3）初始化构造函数 会员 第一是由一个和成员构建的第二与b。 （4）分段构造 构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。 1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args); Example 12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 ("tomatoes",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string("lightbulbs"),0.99); // using make_pair (move) product2.first = "shoes"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; "The price of " &lt;&lt; product1.first &lt;&lt; " is $" &lt;&lt; product1.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product2.first &lt;&lt; " is $" &lt;&lt; product2.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product3.first &lt;&lt; " is $" &lt;&lt; product3.second &lt;&lt; '\n'; return 0;&#125; Output 123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview C C++]]></title>
    <url>%2F2016%2F06%2F08%2FProgram-C%2Finterview%2F</url>
    <content type="text"><![CDATA[C/C++ 面试知识总结C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。 勘误新增请 Issue、PR，建议、讨论请 #issues/12，排版使用 中文文案排版指北 使用建议： Ctrl + F：快速查找定位知识点 TOC 导航：jawil/GayHub 插件快速目录跳转 目录 C/C++ STL 数据结构 算法 Problems 操作系统 计算机网络 网络编程 数据库 设计模式 链接装载库 海量数据处理 音视频 其他 书籍 复习刷题网站 招聘时间岗位 面试题目经验 C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常量； 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 使用const 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 类class A&#123;private: const int a; // 常对象成员，只能在初始化列表赋值public: // 构造函数 A() &#123; &#125;; A(int x) : a(x) &#123; &#125;; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值&#125;;void function()&#123; // 对象 A b; // 普通对象，可以调用全部成员函数 const A a; // 常对象，只能调用常成员函数、更新常成员变量 const A *p = &amp;a; // 常指针 const A &amp;q = a; // 常引用 // 指针 // 还有其中区别方法，沿着 * 号划一条线： // 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； // 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。 char greeting[] = "Hello"; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量 char* const p3 = greeting; // 常指针，指向字符数组变量 const char* const p4 = greeting; // 常指针，指向字符数组常量&#125;// 函数void function1(const int Var); // 传递过来的参数在函数内不可变void function2(const char* Var); // 参数指针所指内容为常量void function3(char* const Var); // 参数指针为常指针void function4(const int&amp; Var); // 引用参数在函数内为常量// 函数返回值const int function5(); // 返回一个常数const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 C++ static 和const 的作用 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 不能包含循环、递归、switch 等复杂操作； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 使用inline 使用 12345678910111213141516171819// 声明1（加 inline，建议使用）inline int functionName(int first, int secend,...);// 声明2（不加 inline）int functionName(int first, int secend,...);// 定义inline int functionName(int first, int secend,...) &#123;/****/&#125;;// 类内定义，隐式内联class A &#123; int doA() &#123; return 0; &#125; // 隐式内联&#125;// 类外定义，需要显式内联class A &#123; int doA();&#125;inline int A::doA() &#123; return 0; &#125; // 需要显式内联 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 虚函数（virtual）可以是内联函数（inline）吗？Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base&#123;public: inline virtual void who() &#123; cout &lt;&lt; "I am Base\n"; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123;public: inline void who() // 不写inline时隐式内联 &#123; cout &lt;&lt; "I am Derived\n"; &#125;&#125;;int main()&#123; // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-&gt;who(); // 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system("pause"); return 0;&#125; assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。 assert() 使用 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n)设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1234567891011#pragma pack(push) // 保存对齐状态#pragma pack(4) // 设定为 4 字节对齐struct test&#123; char m1; double m4; int m3;&#125;;#pragma pack(pop) // 恢复对齐状态 位域1Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域 volatile1volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式编译和连接的 extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern "C" 使用 123456789#ifdef __cplusplusextern "C" &#123;#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus&#125;#endif struct 和 typedef structC 中1234// ctypedef struct Student &#123; int age; &#125; S; 等价于 123456// cstruct Student &#123; int age; &#125;;typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 C++ 中由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 123456// cppstruct Student &#123; int age; &#125;;void f( Student me ); // 正确，"struct" 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 12345678910111213typedef struct Student &#123; int age; &#125; S;void Student() &#123;&#125; // 正确，定义后 "Student" 只代表此函数//void S() &#123;&#125; // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名int main() &#123; Student(); struct Student me; // 或者 "S me"; return 0;&#125; C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest &#123; UnionTest() : i(10) &#123;&#125;; int i; double d;&#125;;static union &#123; int i; double d;&#125;;int main() &#123; UnionTest u; union &#123; int i; double d; &#125;; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;&#125; C 实现 C++ 类C 语言实现封装、继承和多态 explicit（显式）构造函数explicit 修饰的构造函数可用来防止隐式转换 explicit 使用 1234567891011121314151617181920212223242526272829class Test1&#123;public: Test1(int n) // 普通构造函数 &#123; num=n; &#125;private: int num;&#125;;class Test2&#123;public: explicit Test2(int n) // explicit（显式）构造函数 &#123; num=n; &#125;private: int num;&#125;;int main()&#123; Test1 t1=12; // 隐式调用其构造函数，成功 Test2 t2=12; // 编译错误，不能隐式调用其构造函数 Test2 t2(12); // 显式调用成功 return 0;&#125; friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 usingusing 声明一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; 构造函数的 using 声明【C++11】在 C++11 中，派生类能够重用其直接基类定义的构造函数。 12345class Derived : Base &#123;public: using Base::Base; /* ... */&#125;; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1derived(parms) : base(args) &#123; &#125; using 指示using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; 尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1using namespace std; 应该多使用 using 声明 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; 或者 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; :: 范围解析运算符分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1234567891011121314151617int count = 0; // 全局（::）的 countclass A &#123;public: static int count; // 类 A 的 count（A::count）&#125;;int main() &#123; ::count = 1; // 设置全局的 count 的值为 1 A::count = 2; // 设置类 A 的 count 为 2 int count = 0; // 局部的 count count = 3; // 设置局部的 count 的值为 3 return 0;&#125; enum 枚举类型限定作用域的枚举类型1enum class open_modes &#123; input, output, append &#125;; 不限定作用域的枚举类型12enum color &#123; red, yellow, green &#125;;enum &#123; floatPrec = 6, doublePrec = 10 &#125;; C++ 枚举类型详解 decltypedecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法： 1decltype ( expression ) decltype 使用 1234567891011121314// 尾置返回允许我们在参数列表之后声明返回类型template &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg)&#123; // 处理序列 return *beg; // 返回序列中一个元素的引用&#125;// 为了使用模板参数成员，必须用 typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123; // 处理序列 return *beg; // 返回序列中一个元素的拷贝&#125; 引用左值引用常规引用，一般表示对象的身份。 右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 引用折叠 X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp; 详解c++ 引用（reference）与 指针（pointer）的区别与联系 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。 initializer_list 列表初始化【C++11】用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S &#123; std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) &#123; std::cout &lt;&lt; "constructed with a " &lt;&lt; l.size() &lt;&lt; "-element list\n"; &#125; void append(std::initializer_list&lt;T&gt; l) &#123; v.insert(v.end(), l.begin(), l.end()); &#125; std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123; return &#123;&amp;v[0], v.size()&#125;; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list &#125;&#125;; template &lt;typename T&gt;void templated_fn(T) &#123;&#125; int main()&#123; S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化 s.append(&#123;6, 7, 8&#125;); // 函数调用中的列表初始化 std::cout &lt;&lt; "The vector size is now " &lt;&lt; s.c_arr().second &lt;&lt; " ints:\n"; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "Range-for over brace-init-list: \n"; for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; ' '; std::cout &lt;&lt; '\n'; auto al = &#123;10, 11, 12&#125;; // auto 的特殊规则 std::cout &lt;&lt; "The list bound to auto has size() = " &lt;&lt; al.size() &lt;&lt; '\n'; // templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式， // 它无类型，故 T 无法推导 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // 也 OK&#125; 面向对象面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 关键字：public, protected, friendly, private。不写默认为 friendly。 关键字 当前类 包内 子孙类 包外 public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 继承 基类（父类）——&gt; 派生类（子类） 多态 多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。 C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。 多态是以封装和继承为基础的。 静态多态（早绑定）函数重载 123456class A&#123;public: void do(int a); void do(int a, int b);&#125;; 动态多态（晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 123456789101112131415161718192021222324252627282930313233class Shape // 形状类&#123;public: virtual double calcArea() &#123; ... &#125; virtual ~Shape();&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;class Rect : public Shape // 矩形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); // 调用圆形类里面的方法 shape2-&gt;calcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0;&#125; 虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 123456789101112131415161718192021class Shape&#123;public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0；&#125; 纯虚函数纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1virtual int A() = 0; 虚函数、纯虚函数CSDN . C++ 中的虚函数、纯虚函数区别和联系 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 虚继承虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有有定于任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理 C/C++内存管理详解 - ShinChan’s Blog malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 malloc、free用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 12char *str = (char*) malloc(100);assert(str != nullptr); 释放内存后指针置空 12free(p); p = nullptr; new、delete new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 123456int main()&#123; T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0;&#125; 定位 new定位 new（placement new）允许我们向 new 传递额外的参数。 1234new (palce_address) typenew (palce_address) type (initializers)new (palce_address) type [size]new (palce_address) type [size] &#123; braced initializer list &#125; palce_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？如何定义一个只能在堆上（栈上）生成对象的类? 只能在堆上方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 只能在栈上方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针 C++11及C++14标准的智能指针 C++ 智能指针 使用 C++11 智能指针时要避开的 10 大错误 C++ 标准库（STL）中头文件：#include &lt;memory&gt; C++ 981std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 unique_ptrunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符MSDN . 强制转换运算符 C++类型转换总结 static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -&gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 123456try &#123; Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); &#125; catch (bad_cast b) &#123; cout &lt;&lt; "Caught: " &lt;&lt; b.what(); &#125; 运行时类型信息 (RTTI)dynamic_cast 用于多态类型的转换 typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Flyable // 能飞的&#123;public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落&#125;;class Bird : public Flyable // 鸟&#123;public: void foraging() &#123;...&#125; // 觅食 virtual void takeoff() &#123;...&#125; virtual void land() &#123;...&#125;&#125;;class Plane : public Flyable // 飞机&#123;public: void carry() &#123;...&#125; // 运输 virtual void take off() &#123;...&#125; virtual void land() &#123;...&#125;&#125;;class type_info&#123;public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info();private: ...&#125;;class doSomething(Flyable *obj) // 做些事情&#123; obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; // 输出传入对象类型（"class Bird" or "class Plane"） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 &#123; Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化 bird-&gt;foraging(); &#125; obj-&gt;land();&#125;; Effective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） Google C++ Style Guide 英文：Google C++ Style Guide中文：C++ 风格指南 Google C++ Style Guide 图 图片来源于：CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide) STLSTL 索引STL 方法含义索引 C++ STL容器总结 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持快速随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持快速随机访问 list 双向链表 插入、删除 O(1)随机读改 O(n) 无序 可重复 支持快速增删 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 hash_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 hash_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 hash_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 hash_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 STL 算法 算法 底层算法 时间复杂度 可不可重复 find 顺序查找 O(n) 可重复 sort 内省排序 O(n*log2n) 可重复 数据结构顺序结构顺序栈（Sequence Stack）SqStack.cpp 顺序栈数据结构和图片 123456typedef struct &#123; ElemType *elem; int top; int size; int increment;&#125; SqSrack; 队列（Sequence Queue）队列数据结构 123456typedef struct &#123; ElemType * elem; int front; int rear; int maxSize;&#125;SqQueue; 非循环队列非循环队列图片 SqQueue.rear++ 循环队列循环队列图片 SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize 顺序表（Sequence List）SqList.cpp 顺序表数据结构和图片 123456typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList; 链式结构LinkList.cpp LinkList_with_head.cpp 链式数据结构 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList; 链队列（Link Queue）链队列图片 线性表的链式表示单链表（Link List）单链表图片 双向链表（Du-Link-List）双向链表图片 循环链表（Cir-Link-List）循环链表图片 哈希表HashTable.cpp 概念哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突处理方法 链地址法：key 相同的用单链表链接 开放定址法 线性探测法：key 相同 -&gt; 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 -&gt; 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2） 随机探测法：H = (H(key) + 伪随机数) % m 线性探测的哈希表数据结构线性探测的哈希表数据结构和图片 123456789101112typedef char KeyType;typedef struct &#123; KeyType key;&#125;RcdType;typedef struct &#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 递归概念函数直接或间接地调用自身 递归与分治 分治法 问题的分解 问题规模的分解 折半查找（递归） 归并查找（递归） 快速排序（递归） 递归与迭代 迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并查找（迭代） 广义表头尾链表存储表示广义表的头尾链表存储表示和图片 12345678910111213141516// 广义表的头尾链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义 struct &#123; struct GLNode *hp, *tp; &#125; ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾 &#125; a;&#125; *GList, GLNode; 扩展线性链表存储表示扩展线性链表存储表示和图片 1234567891011121314// 广义表的扩展线性链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode1 &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // 原子结点的值域 struct GLNode1 *hp; // 表结点的表头指针 &#125; a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点&#125; *GList1, GLNode1; 二叉树BinaryTree.cpp 性质 非空二叉树第 i 层最多 2(i-1) 个结点 （i &gt;= 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k &gt;= 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1 存储结构二叉树数据结构 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 顺序存储二叉树顺序存储图片 链式存储二叉树链式存储图片 遍历方式 先序遍历 中序遍历 后续遍历 层次遍历 分类 满二叉树 完全二叉树（堆） 大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右 小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右 二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整： LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋 其他树及森林树的存储结构 双亲表示法 双亲孩子表示法 孩子兄弟表示法 并查集一种不相交的子集所构成的集合 S = {S1, S2, …, Sn} 平衡二叉树（AVL树）性质 | 左子树树高 - 右子树树高 | &lt;= 1 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量） 平衡二叉树图片 最小失衡树平衡二叉树插入新结点导致失衡的子树 调整： LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋 红黑树红黑树的特征是什么？ 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红） 调整 变色 左旋 右旋 应用 关联数组：如 STL 中的 map、set 红黑树、B 树、B+ 树的区别？ 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。 B 树（B-tree）、B+ 树（B+-tree）B 树、B+ 树图片 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用B树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。 B树的优点对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。 B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别 八叉树八叉树图片 八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。 用途 三维计算机图形 最邻近搜索 算法排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia . 排序算法 查找 查找算法 平均时间复杂度 空间复杂度 查找条件 顺序查找 O(n) O(1) 无序或有序 二分查找（折半查找） O(log2n) O(1) 有序 插值查找 O(log2(log2n)) O(1) 有序 斐波那契查找 O(log2n) O(1) 有序 哈希查找 O(1) O(n) 无序或有序 二叉查找树（二叉搜索树查找） O(log2n) 红黑树 O(log2n) 2-3树 O(log2n - log3n) B树/B+树 O(log2n) 图搜索算法 图搜索算法 数据结构 遍历时间复杂度 空间复杂度 BFS广度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) DFS深度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) 其他算法 算法 思想 应用 分治法 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 循环赛日程安排问题、排序算法（快速排序、归并排序） 动态规划 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 背包问题、斐波那契数列 贪心法 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 ProblemsSingle Problem Chessboard Coverage Problem（棋盘覆盖问题） Knapsack Problem（背包问题） Neumann Neighbor Problem（冯诺依曼邻居问题） Round Robin Problem（循环赛日程安排问题） Tubing Problem（输油管道问题） Leetcode Problems Github . haoel/leetcode Github . pezy/LeetCode 剑指 Offer Github . zhedahht/CodingInterviewChinese2 Github . gatieme/CodingInterviews Cracking the Coding Interview 程序员面试金典 Github . careercup/ctci 牛客网 . 程序员面试金典 牛客网 牛客网 . 在线编程专题 操作系统 【构建操作系统】进程间通信 C++ 高性能服务器网络框架设计细节 epoll编程，如何实现高并发服务器开发？ 如何实现高并发服务器开发 进程与线程 编程思想之多线程与多进程(4)——C++中的多线程 对于有线程系统： 进程是资源分配的独立单位 线程是资源调度的独立单位 对于无线程系统： 进程是资源调度、分配的独立单位 进程之间的通信方式以及优缺点 管道（PIPE） 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信 套接字（Socket）：可用于不同及其间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程之间的通信方式 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition） 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore) 无名线程信号量 命名线程信号量 信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制 进程之间的通信方式以及优缺点来源于：进程线程面试题总结 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 线程之间私有和共享的资源 私有：线程栈，寄存器，程序寄存器 共享：堆，地址空间，全局变量，静态变量 多进程与多线程间的对比、优劣与选择对比 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用 IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU 利用率低 占用内存少，切换简单，CPU 利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 优劣 优劣 多进程 多线程 优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小 缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差 选择 需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式 多进程与多线程间的对比、优劣与选择来自：多线程还是多进程的选择及区别 多进程并发优点： 将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。 操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。 使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。 缺点： 这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。 运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。 多线程并发优点： 每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。 共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。 缺点： 虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。 共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。 Linux 内核的同步方式原因在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 来自：Linux 内核的同步机制，第 1 部分、Linux 内核的同步机制，第 2 部分 死锁原因 系统资源不足 资源分配不当 进程运行推进顺序不合适 产生条件 互斥 请求和保持 不剥夺 环路 预防 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 有序资源分配法 银行家算法 文件系统 Windows：FCB 表 + FAT + 位图 Unix：inode + 混合索引 + 成组链接 主机字节序与网络字节序主机字节序（CPU 字节序）概念主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式32 位整数 0x12345678 是从起始位置为 0x00 的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端小端图片 判断大端小端判断大端小端 可以这样判断自己 CPU 字节序是大端还是小端： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 0x12345678; if (*((char*)&amp;i) == 0x12) cout &lt;&lt; "大端" &lt;&lt; endl; else cout &lt;&lt; "小端" &lt;&lt; endl; return 0;&#125; 各架构处理器的字节序 x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序； Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序； ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。 网络字节序网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 页面置换算法在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 分类 全局置换：在整个内存空间置换 局部置换：在本进程中进行置换 算法全局： 工作集算法 缺页率置换算法 局部： 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法 计算机网络计算机经网络体系结构： 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 物理层 传输数据的单位 ———— 比特 数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点） 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 数据链路层主要信道： 点对点信道 广播信道 点对点信道 数据单元 ———— 帧 三个基本问题： 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 点对点协议（Point-to-Point Protocol）： 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 广播信道广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP 网际协议IP 地址分类： IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP 数据报格式： ICMP 网际控制报文协议ICMP 报文格式： 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 内部网关协议 RIP（Routing Information Protocol，路由信息协议） OSPF（Open Sortest Path First，开放最短路径优先） 外部网关协议 BGP（Border Gateway Protocol，边界网关协议） IP多播 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 VPN 和 NAT VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换） 路由表包含什么？ 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 运输层协议： TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） 端口： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 端口号 21 23 25 53 69 80 443 161 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。 特征： 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流 TCP 如何保证可靠传输： 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验 TCP 报文结构 TCP 首部 TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下： URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。 特征： 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小 UDP 报文结构 UDP 首部 TCP/UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp TCP 与 UDP 的区别 TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节 TCP 黏包问题原因TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。 解决 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。 使用更加复杂的应用层协议。 TCP 流量控制概念流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。 方法利用可变窗口进行流量控制 TCP 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) TCP的拥塞控制图 TCP 传输连接管理 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【TCP 建立连接全过程解释】 客户端发送 SYN 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。 TCP 为什么要进行三次握手？【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。） Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信} 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 知乎 . TCP 为什么是三次握手，而不是两次或四次？ 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 《计算机网络（第 7 版）-谢希仁》 TCP 四次挥手释放连接 【TCP 释放连接全过程解释】 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 TCP 为什么要进行四次挥手？【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？ 【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手） 【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 【答案三】 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 Time-wait状态(2MSL)一些理解 TCP 有限状态机TCP 有限状态机图片 TCP和UDP详解 HTTP、TCP、UDP详解 应用层DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 域名： 域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 TELNET TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。 WWW WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问 URL URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 标准格式： 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 完整格式： 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项如：https://github.com/huihut/interview#cc HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。 请求方法 方法 意义 OPTIONS 请求一些选项信息，允许客户端查看服务器的性能 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码（Status-Code） 1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 更多状态码：菜鸟教程 . HTTP状态码 其他协议 SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 网络编程SocketLinux Socket 编程（不限 Linux） Socket 中的 read()、write() 函数12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); read() read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。 write() write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。 Socket 中 TCP 的三次握手建立连接我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1 只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图： 从图中可以看出： 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。 Socket 中 TCP 的四次握手释放连接上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图： 图示过程如下： 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。 这样每个方向上都有一个 FIN 和 ACK。 数据库 数据库事务四大特性：原子性、一致性、分离性、持久性 数据库索引：顺序索引、B+ 树索引、hash 索引MySQL 索引背后的数据结构及算法原理 SQL 约束 (Constraints) 范式 第一范式（1NF）：属性（字段）是最小单位不可再分 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖） 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖） 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖） 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖） 设计模式 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工程目录 单例模式单例模式例子 抽象工厂模式抽象工厂模式例子 适配器模式适配器模式例子 桥接模式桥接模式例子 观察者模式观察者模式例子 设计模式的六大原则 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle） 链接装载库内存、栈、堆一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据 栈栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器 堆堆分配算法： 空闲链表（Free List） 位图（Bitmap） 对象池 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针 编译链接各平台文件格式 平台 可执行文件 目标文件 动态库/共享对象 静态库 Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework 编译链接过程 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件） 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin 目标文件编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF） 目标文件格式 Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式 PE 和 ELF 都是 COFF（Common File Format）的变种 目标文件存储结构 段 功能 File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） .text section 代码段，执行语句编译成的机器代码 .data section 数据段，已初始化的全局变量和局部静态变量 .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 .comment section 注释信息段，存放编译器版本信息 .note.GNU-stack section 堆栈提示段 其他段略 链接的接口————符号在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。 如下符号表（Symbol Table）： Symbol（符号名） Symbol Value （地址） main 0x100 Add 0x123 … … Linux 的共享库（Shared Library）Linux 下的共享库就是普通的 ELF 共享对象。 共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容 命名libname.so.x.y.z x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容 路径大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。 /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库 动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库 环境变量 LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能 so 共享库的编写使用 CLion 编写共享库 创建一个名为 MySharedLib 的共享库 CMakeLists.txt 123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t)&#123; return t;&#125;template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest)&#123; return first + sum&lt;T&gt;(rest...);&#125;#endif library.cpp 123456#include &lt;iostream&gt;#include "library.h"void hello() &#123; std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;&#125; so 共享库的使用（被可执行项目调用）使用 CLion 调用共享库 创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt 12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories($&#123;INC_DIR&#125;)link_directories($&#123;LIB_DIR&#125;)link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp 12345678910111213#include &lt;iostream&gt;#include "library.h"using std::cout;using std::endl;int main() &#123; hello(); cout &lt;&lt; "1 + 2 = " &lt;&lt; sum(1,2) &lt;&lt; endl; cout &lt;&lt; "1 + 2 + 3 = " &lt;&lt; sum(1,2,3) &lt;&lt; endl; return 0;&#125; 执行结果 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 运行库（Runtime Library）典型程序运行步骤 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。 glibc 入口_start -&gt; __libc_start_main -&gt; exit -&gt; _exit 其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。 MSVC CRT 入口int mainCRTStartup(void) 执行如下操作： 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。 C 语言运行库（CRT）大致包含如下功能： 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。 C语言标准库（ANSI C）包含： 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h &amp; float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h） 回调函数和钩子函数什么是回调函数？简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 为什么要使用回调函数？因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 使用场景不管怎么说，回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数。 机制也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。 为此，你需要做三件事： 声明； 定义； 设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。 声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数 回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。 参考 C语言中的回调函数 一文搞懂C语言回调函数 c语言实现回调函数 函数指针 什么是钩子函数？钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。 本质钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。 类型 局部钩子：仅钩挂您自己进程的事件。 远程钩子：可以钩挂自己进程或其他进程的事件， 远程钩子又分为两种： 一种是系统级的全局钩子， 一种是线程级的钩子。 全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。 机制当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。 两个例外： 工作日志钩子 工作日志回放钩子。 这两个钩子的钩子函数必须在安装钩子的线程中。原因是： 这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。 解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。 参考 浅谈c++ hook 钩子的使用介绍 异步消息的传递－回调机制 异步消息的传递－回调机制 什么是回调软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类： 同步调用 回调 异步调用 同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。 同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。 对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。 对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。 在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。 Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。 对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。 下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。 过程语言中的回调（C）函数指针回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子： 12void Func(char *s)； // 函数原型void (*pFunc) (char *); //函数指针 可以看出，函数的定义和函数指针的定义非常类似。 一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。 1typedef void(*pcb)(char *); 回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。 被调函数的例子： 1234567891011void GetCallBack(pcb callback)&#123; /* do something */&#125;// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：void fCallback(char *s) &#123; /* do something */&#125; // 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,GetCallBack（fCallback）; 如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。 参数传递规则到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C/C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 _cdecl，_stdcall 或者 _pascal 来表示其调用规范（默认为 _cdecl）。C++ Builder也支持 _fastcall 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。 将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如： 123456// 被调用函数是以 int 为参数，以 int 为返回值__stdcall int callee(int); // 调用函数以函数指针为参数void caller( __cdecl int(*ptr)(int)); // 在 p 中企图存储被调用函数地址的非法操作__cdecl int(*p)(int) = callee; // 出错 指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列 应用举例C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。 123456// 快速排序函数原型：void qsort(void *base, size_t nelem, size_t width, int (_USERENTRY *fcmp)(const void *, const void *));// 二分搜索函数原型：void *bsearch(const void *key, const void *base, size_t nelem, size_t width, int (_USERENTRY *fcmp)(const void *, const void *)); 其中 fcmp 就是一个回调函数的变量。 下面给出一个具体的例子： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int sort_function( const void *a, const void *b);int list[5] = &#123; 54, 21, 11, 67, 22 &#125;;int main(void)&#123; int x; qsort((void *)list, 5, sizeof(list[0]), sort_function); for (x = 0; x &lt; 5; x++) printf("%i\n", list[x]); return 0;&#125;int sort_function( const void *a, const void *b)&#123; return *(int*)a-*(int*)b;&#125; 回调在分布式计算中的应用（CORBA）回调接口模型CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。 回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。 从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型： 下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架： 1234567891011121314module cb&#123; interface CallBack; interface Server; interface CallBack &#123; void OnEvent(in long Source,in long msg); &#125;; interface Server &#123; long RegisterCB(in CallBack cb); void UnRegisterCB(in long hCb); &#125;;&#125;; 客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。 野指针避免野指针的方法为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。 避免野指针的方法 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;int main()&#123; char *str1 = "123"; char *str2 = NULL; //str2 赋初值，不指向任何内存 printf("str2的值是: %u\n", str2); str2 = (char *)malloc(10); printf("str2被分配的地址是: %u\n", str2); strcpy(str2, str1); printf("str2指向的字符串是: %s\n", str2); if(NULL != str2) &#123; free(str2); // 主动释放分配给str2的内存 str2 = NULL; // 让str2不指向任何内存 &#125; return 0;&#125; 海量数据处理 海量数据处理面试题集锦 十道海量数据处理面试题与十个方法大总结 音视频 最全实时音视频开发要用到的开源工程汇总 18个实时音视频开发中会用到开源项目 其他 Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题 书籍语言 《C++ Primer》 《Effective C++》 《More Effective C++》 《深度探索 C++ 对象模型》 《深入理解 C++11》 《STL 源码剖析》 算法 《剑指 Offer》 《编程珠玑》 《程序员面试宝典》 系统 《深入理解计算机系统》 《Windows 核心编程》 《Unix 环境高级编程》 网络 《Unix 网络编程》 《TCP/IP 详解》 其他 《程序员的自我修养》 复习刷题网站 leetcode 牛客网 慕课网 菜鸟教程 招聘时间岗位 牛客网 . 2019 IT名企校招指南 面试题目经验牛客网 牛客网 . 2017秋季校园招聘笔经面经专题汇总 牛客网 . 史上最全2017春招面经大合集！！ 牛客网 . 面试题干货在此 知乎 知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。 知乎 . 互联网公司最常见的面试算法题有哪些？ 知乎 . 面试 C++ 程序员，什么样的问题是好问题？ CSDN CSDN . 全面整理的C++面试题 CSDN . 百度研发类面试题（C++方向） CSDN . c++常见面试题30道 CSDN . 腾讯2016实习生面试经验（已经拿到offer) cnblogs cnblogs . C++面试集锦( 面试被问到的问题 ) cnblogs . C/C++ 笔试、面试题目大汇总 cnblogs . 常见C++面试题及基本知识点总结（一） Segmentfault segmentfault . C++常见面试问题总结 HTTP相关知识 你必须知道的HTTP基本概念 浏览器中常见网络协议介绍 WebRTC介绍及简单应用 WebRTC架构简介 了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化 Spark Apache Spark 中文文档 Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN 30分钟概览Spark分布式计算引擎 加密安全问题 SHA算法系列介绍 比特币背后的密码学原理 比特币的加密算法 密码学大事件！ SHA-1 哈希碰撞实例 如何安全的存储用户的密码 机器学习作用于信息安全的五大顶级案例 机器学习和数据挖掘在网络安全领域会有哪些应用？ 机器学习正在安全领域挂起一阵小旋风，但这里面有BUG 其他 终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！ 如何真正让小程序,WebRTC和APP互通连麦直播 创业者必读：开发一款 App 到底需要多久？ 如何开发一个app（Android） 微信小程序开发教程–从零开始 面向机器学习:数据平台的设计与搭建 基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架 高德面试基本知识 1、进程和线程 2、多线程通讯方式 3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式） 4、linux命令 top、netstat 5、gdb调试，怎样切换到某个线程 6、inline和宏定义区别 7、vector和list区别，什么情况分别是用什么 8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的 9、setsocektopt no-delay，等参数的作用 10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，， 11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行 12、c++11 智能指针 13、死锁概念 14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的 15、怎么样判断一棵树和平衡二叉树 16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出） 项目： 1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码 2、视频花屏是怎样优化的 3、rtp，udp 4、语音包、和视频包是不是固定大小的，，，是否分包]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重拾十大经典排序算法]]></title>
    <url>%2F2016%2F06%2F05%2FProgram-C%2Falgorithm%2F</url>
    <content type="text"><![CDATA[最近在工作中偶然间涉及到数据库的存储和访问，数据库里存放着员工的指纹、年龄以及姓名等信息，当然指纹是通过md5加密存储的。目前需要对员工的年龄、学历、工作年限等进行排序，如果只有几十个上百个样本，应该不会那么麻烦；关键这是几万名员工的数据，这个量很大，马虎不得。悄悄的告诉你，别惹我，我懂得删库跑路哦。 脑海中对排序的记忆有点模糊，只对「归并排序」印象较为深刻，为了加深理解，重拾「数据结构与算法」，并总结了一下常用的十大经典排序算法，由于平台为linux，因此代码全部用C++实现，全部源码均在linux下编译通过并测试成功，可以作为参考。 排序算法在程序猿的编程生涯中虽然用的不多，但是作为基本功，还是要掌握一下。排序算法是「数据结构与算法」中最基本的算法，它分为「内部排序」和「外部排序」；「内部排序」一般在内存中实现；当数据量很大时，内存有限，不能将所有的数据都放到内存中来，这个时候必须使用「外部排序」。 先看一张图，对常用算法的时间复杂度做个比较： 排序算法 平均时间复杂度 最佳情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ In-place 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 希尔排序 $O(n \log n)$ $O(n \log^2 n)$ $O(n \log^2 n)$ $O(1)$ In-place 不稳定 归并排序 $O(n \log n)$ $O(n \log n)$ $O(n \log n)$ $O(n)$ Out-place 稳定 快速排序 $O(n \log n)$ $O(n \log n)$ $O(n^2)$ $O(\log n)$ In-place 不稳定 堆排序 $O(n \log n)$ $O(n \log n)$ $O(n \log n)$ $O(1)$ In-place 不稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ Out-place 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ Out-place 稳定 基数排序 $O(n \times k)$ $O(n \times k)$ $O(n \times k)$ $O(n+k)$ Out-place 稳定 这里的「稳定」是指当排序后两个相等键值的顺序和排序之前的顺序相同； n: 代表数据规模及数据量大小 k: 桶的个数 In-place: 不占用额外内存，只占用常数内存 Out-place: 占用额外内存 一 冒泡排序冒泡排序是排序算法中较为简单的一种，英文称为Bubble Sort。它遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。 如果有$n$个数据，那么需要$O(n^2)$的比较次数，所以当数据量很大时，冒泡算法的效率并不高。当输入的数据是反序时，花的时间最长，当输入的数据是正序时，时间最短。 平均时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 动态演示： 代码： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; //整数或浮点数皆可使用void bubble_sort(T arr[], int len) &#123; int i, j; for (i = 0; i &lt; len - 1; i++)&#123; for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]); &#125;&#125;int main() &#123; int arr[] = &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; ' '; cout &lt;&lt; endl; float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;; len = (int) sizeof(arrf) / sizeof(*arrf); bubble_sort(arrf, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; return 0;&#125; 新建代码文件bubble_sort.cpp，将以上代码写入，linux下编译： 1$ g++ -o bubble_sort bubble_sort.cpp 测试： 1$ ./bubble_sort 输出结果： 121 17 21 22 29 34 50 60 61 62 720.6 1.5 1.9 3.8 4.4 5.4 10.5 12.4 17.5 19.1 19.7 23.8 25.4 28.6 以下的编译方法和测试方法和这里一样，所以下面不再重复编译和测试的说明。 二 选择排序选择排序简单直观，英文称为Selection Sort，先在数据中找出最大或最小的元素，放到序列的起始；然后再从余下的数据中继续寻找最大或最小的元素，依次放到排序序列中，直到所有数据样本排序完成。很显然，选择排序也是一个费时的排序算法，无论什么数据，都需要$O(n^2)$的时间复杂度，不适宜大量数据的排序。 平均时间复杂度：：$O(n^2)$ 空间复杂度：：$O(1)$ 动态演示： 代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; //整数或浮点数皆可使用void selection_sort(T arr[],int len ) &#123; for (int i = 0; i &lt; len - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; len; j++) if (arr[j] &lt; arr[min]) min = j; std::swap(arr[i], arr[min]); &#125;&#125;int main() &#123; float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;; int len = (int) sizeof(arrf) / sizeof(*arrf); selection_sort(arrf,len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; return 0;&#125; 三 插入排序插入排序英文称为Insertion Sort，它通过构建有序序列，对于未排序的数据序列，在已排序序列中从后向前扫描，找到相应的位置并插入，类似打扑克牌时的码牌。插入排序有一种优化的算法，可以进行拆半插入。 基本思路是先将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；然后从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置，直到所有数据都完成排序；如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。 平均时间复杂度：：$O(n^2)$ 空间复杂度：：$O(1)$ 动态演示： 代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; //整数或浮点数皆可使用void insertion_sort(T arr,int len)&#123; for(int i=1;i&lt;len;i++)&#123; T key=arr[i]; int j; for(j=i-1;j&gt;=0 &amp;&amp; key&lt;arr[j];j--) arr[j+1]=arr[j]; arr[j+1]=key; &#125;&#125;int main() &#123; float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;; int len = (int) sizeof(arrf) / sizeof(*arrf); insertion_sort(arrf,len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; return 0;&#125; 四 希尔排序希尔排序也称递减增量排序，是插入排序的一种改进版本，英文称为Shell Sort，效率虽高，但它是一种不稳定的排序算法。 插入排序在对几乎已经排好序的数据操作时，效果是非常好的；但是插入排序每次只能移动一位数据，因此插入排序效率比较低。 希尔排序在插入排序的基础上进行了改进，它的基本思路是先将整个数据序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全部数据进行依次直接插入排序。 平均时间复杂度：：$O(n \log n)$ 空间复杂度：：$O(1)$ 假如有这样一组数据，[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果以步长5进行分割，每一列为一组，那么这组数据应该首先分成这样 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 之后对每列进行插入排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数据依序拼接在一起，得到[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]，此时10已经移到正确的顺序了，之后以步长3进行插入排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以步长 1 进行排序。 步长的选择是希尔排序的关键，只要最终步长为1，任何步长序列都可以。建议最初步长选择为数据长度的一半，直到最终的步长为1。 图解： 代码： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;void shell_sort(T array[], int length) &#123; int h = 1; while (h &lt; length / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123; std::swap(array[j], array[j - h]); &#125; &#125; h = h / 3; &#125;&#125;int main() &#123; int arrf[] = &#123; 13，14，94，33，82，25，59，94，65，23，45，27，73，25，39，10 &#125;; int len = (int) sizeof(arrf) / sizeof(*arrf); shell_sort(arrf,len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; return 0;&#125; 五 归并排序归并排序英文称为Merge Sort，归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它首先将数据样本拆分为两个子数据样本, 并分别对它们排序, 最后再将两个子数据样本合并在一起; 拆分后的两个子数据样本序列, 再继续递归的拆分为更小的子数据样本序列, 再分别进行排序, 直到最后数据序列为1，而不再拆分，此时即完成对数据样本的最终排序。 归并排序严格遵循从左到右或从右到左的顺序合并子数据序列, 它不会改变相同数据之间的相对顺序, 因此归并排序是一种稳定的排序算法. 作为一种典型的分而治之思想的算法应用，归并排序的实现分为两种方法： 自上而下的递归； 自下而上的迭代； 平均时间复杂度：：$O(n \log n)$ 空间复杂度：：$O(n)$ 动态演示： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; void merge_sort_iteration(T arr[], int len) &#123;//迭代法 T* a = arr; T* b = new T[len]; for (int seg = 1; seg &lt; len; seg += seg) &#123; for (int start = 0; start &lt; len; start += seg + seg) &#123; int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt; end1) b[k++] = a[start1++]; while (start2 &lt; end2) b[k++] = a[start2++]; &#125; T* temp = a; a = b; b = temp; &#125; if (a != arr) &#123; for (int i = 0; i &lt; len; i++) b[i] = a[i]; b = a; &#125; delete[] b;&#125;template&lt;typename T&gt; void merge_sort_recursive_t(T arr[], T reg[], int start, int end) &#123;//递归法 if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive_t(arr, reg, start1, end1); merge_sort_recursive_t(arr, reg, start2, end2); int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) reg[k++] = arr[start1++]; while (start2 &lt;= end2) reg[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = reg[k];&#125;template&lt;typename T&gt; void merge_sort_recursive(T arr[], const int len) &#123; T *reg = new T[len]; merge_sort_recursive_t(arr, reg, 0, len - 1); delete[] reg;&#125;int main() &#123; float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;; int len = (int) sizeof(arrf) / sizeof(*arrf); merge_sort_recursive(arrf,len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; merge_sort_iteration(arrf,len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; ' '; return 0;&#125; 六 快速排序快速排序,英文称为Quicksort，又称划分交换排序 partition-exchange sort 简称快排。 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。首先从数列中挑出一个元素，并将这个元素称为「基准」，英文pivot。重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。之后，在子序列中继续重复这个方法，直到最后整个数据序列排序完成。 在平均状况下，排序n个项目要$O(n \log n)$次比较。在最坏状况下则需要$O(n^2)$次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。 平均时间复杂度：： $O(n \log n)$ 空间复杂度： ：$O(\log n)$ 动态演示： 更直观一些的动图演示： 代码分两种方式实现，分别为迭代法和递归法。 迭代法： 123456789101112131415161718192021222324252627282930313233343536struct Range &#123; int start, end; Range(int s = 0, int e = 0) &#123; start = s, end = e; &#125;&#125;;template &lt;typename T&gt; // void quick_sort(T arr[], const int len) &#123; if (len &lt;= 0) return; // Range r[len]; int p = 0; r[p++] = Range(0, len - 1); while (p) &#123; Range range = r[--p]; if (range.start &gt;= range.end) continue; T mid = arr[range.end]; int left = range.start, right = range.end - 1; while (left &lt; right) &#123; while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; std::swap(arr[left], arr[right]); &#125; if (arr[left] &gt;= arr[range.end]) std::swap(arr[left], arr[range.end]); else left++; r[p++] = Range(range.start, left - 1); r[p++] = Range(left + 1, range.end); &#125;&#125; 递归法： 123456789101112131415161718192021222324252627template &lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) &#123; if (start &gt;= end) return; T mid = arr[end]; int left = start, right = end - 1; while (left &lt; right) &#123; while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; std::swap(arr[left], arr[right]); &#125; if (arr[left] &gt;= arr[end]) std::swap(arr[left], arr[end]); else left++; quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);&#125;template &lt;typename T&gt; //void quick_sort(T arr[], int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125; 七 堆排序堆排序，英文称Heapsort，是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序实现分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 算法步骤： 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1 平均时间复杂度： ：$O(n \log n)$ 空间复杂度： ：$O(1)$ 动图演示： 来一个更直观一些的： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(int arr[], int start, int end) &#123; //建立父节点指标和子节点指标 int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; //子节点指标在范围内才做比较 if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //比较两个子节点大小，选择最大的 son++; if (arr[dad] &gt; arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数 return; else &#123; //否則交换父子内容再继续子节点和孙节点比较 swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; &#125; &#125;&#125;void heap_sort(int arr[], int len) &#123; //初始化，i从最后一个父节点开始调整 for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1); //先將第一个元素和已经排好的元素前一位做交换，再重调整，(刚调整的元素之前的元素)，直到排序完毕 for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr[0], arr[i]); max_heapify(arr, 0, i - 1); &#125;&#125;int main() &#123; int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;; int len = (int) sizeof(arr) / sizeof(*arr); heap_sort(arr, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;&#125; 八 计数排序计数排序英文称Counting sort，是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于 i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。基本的步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加,从C中的第一个元素开始，每一项和前一项相加 反向填充目标数组,将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1 平均时间复杂度：：$O(n + k )$ 空间复杂度： ：$O(k)$ 动图演示： 代码： 12345678910111213141516171819202122232425262728293031323334353637void Count_Sort(int* Data, int Len)&#123; int* Cout = NULL; Cout = (int*)malloc(sizeof(int) * Len); //初始化记数为0 for (int i = 0; i &lt; Len; i++) &#123; Cout[i] = 0; &#125; //记录重复的个数 for (int i = 0; i &lt; Len; i++) &#123; Cout[Data[i]] += 1; &#125; //确定不比该位置大的数据个数。 for (int i = 1; i &lt; Len; i++) &#123; Cout[i] += Cout[i - 1]; &#125; int* Sort = NULL; Sort = (int*)malloc(sizeof(int) * Len); for (int i = 0; i &lt; Len; i++) &#123; //将数组反向填充到Sort，每次拿出一个就减一 Cout[Data[i]] -= 1; Sort[Cout[Data[i]]] = Data[i]; &#125; //排序结束，将排序好的数据复制到原来数组中。 for (int i = 0; i &lt; Len; ++i) &#123; Data[i] = Sort[i]; &#125; //释放申请的空间。 free(Cout); free(Sort);&#125; 九 桶排序桶排序也称为箱排序，英文称为 Bucket Sort。它是将数组划分到一定数量的有序的桶里，然后再对每个桶中的数据进行排序，最后再将各个桶里的数据有序的合并到一起。 平均时间复杂度：：$O(n + k)$ 空间复杂度：：$O(n + k)$ 动态演示： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;using namespace std;struct tNode&#123; int tValue; tNode *next; tNode(int val) &#123; this-&gt;tValue = val; this-&gt;next = NULL; &#125;&#125;;bool bucket_sort(int *arrf, const int SIZE)&#123; tNode **pNode = (tNode **)malloc(sizeof(tNode *) * 512); if (NULL == pNode) return false; memset(pNode, 0, sizeof(tNode *) * 512); int shiftNum = 0; tNode *p = NULL; tNode *pLast = NULL; tNode *pNewNode = NULL; for (int i = 0; i &lt; SIZE; ++i) &#123; shiftNum = arrf[i] &gt;&gt; 24; p = pNode[shiftNum]; pNewNode = new tNode(arrf[i]); if (NULL == pNewNode) return false; if (NULL == p) &#123; pNode[shiftNum] = pNewNode; &#125; else if (arrf[i] &lt;= p-&gt;tValue) &#123; pNode[shiftNum] = pNewNode; pNewNode-&gt;next = p; &#125; else &#123; while (NULL != p-&gt;next) &#123; if (arrf[i] &gt; p-&gt;next-&gt;tValue) p = p-&gt;next; else break; &#125; pNewNode-&gt;next = p-&gt;next; p-&gt;next = pNewNode; &#125; &#125; for (int i = 0, k = 0; i &lt; 512; i++) &#123; p = pNode[i]; while (NULL != p) &#123; arrf[k++] = p-&gt;tValue; p = p-&gt;next; &#125; &#125; return true;&#125;int main(int argc, char **argv)&#123; int arr[] = &#123; 5,558,772,935,344,487,96,665,302,735,954,308,718,147,185,371,166,849,202,478,874,169,980,125,44,15,279,882,466,974 &#125;; bucket_sort(arr,30); for (int i = 0; i &lt; 30; ++i) &#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; 十 基数排序基数排序英文称Radix sort，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也仅限于整数。它首先将所有待比较数值，统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 平均时间复杂度： ：$O(n \times k)$ 空间复杂度： ：$O(n + k )$ 动态演示： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int maxbit(int data[], int n) //辅助函数，求数据的最大位数&#123; int maxData = data[0]; ///&lt; 最大数 /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。 for (int i = 1; i &lt; n; ++i) &#123; if (maxData &lt; data[i]) maxData = data[i]; &#125; int d = 1; int p = 10; while (maxData &gt;= p) &#123; //p *= 10; // Maybe overflow maxData /= 10; ++d; &#125; return d;/* int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i &lt; n; ++i) &#123; while(data[i] &gt;= p) &#123; p *= 10; ++d; &#125; &#125; return d;*/&#125;void radixsort(int data[], int n) //基数排序&#123; int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i &lt;= d; i++) //进行d次排序 &#123; for(j = 0; j &lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for(j = 0; j &lt; n; j++) &#123; k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; &#125; for(j = 1; j &lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for(j = n - 1; j &gt;= 0; j--) &#123; //将所有桶中记录依次收集到tmp中 k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; &#125; for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; &#125; delete []tmp; delete []count;&#125; 参考wikihttps://github.com/hustcc/JS-Sorting-Algorithm「数据结构与算法」「算法导论」]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2016%2F06%2F03%2FProgram-C%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构 一、数据结构概念1.1 数据结构相关概念疑惑 1、我学完了C语言，可是现在感觉还是写不出代码。 2、为什么会有各种各样的程序存在？ 3、程序的本质是什么？ 程序是为了具体问题而存在的 程序需要围绕问题的解决进行设计 同一个问题可以有多种解决方案 如何追求程序的“性价比”？ 是否有可量化的方法判别程序的好坏？ 数据结构起源 计算机从解决数值计算问题到解决生活中的问题 现实生活中的问题涉及不同个体间的复杂联系 需要在计算机程序中描述生活中个体间的联系 *数据结构主要研究非数值计算程序问题中的操作对象以及它们之间的关系 * 不是研究复杂的算法 数据结构中的基本概念 数据 – 程序的操作对象，用于描述客观事物 (int a, int b,) 数据的特点： 可以输入到计算机 可以被计算机程序处理 数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等 数据元素：组成数据的基本单位 数据项：一个数据元素由若干数据项组成 数据对象 – 性质相同的数据元素的集合 （比如：数组，链表） 123456789101112131415161718//声明一个结构体类型struct _MyTeacher&#123; //一种数据类型 char name[32]; char tile[32]; int age; char addr[128];&#125;;int main21()&#123; struct _MyTeacher t1; //数据元素 struct _MyTeacher tArray[30]; //数据对象 memset(&amp;t1, 0, sizeof(t1)); strcpy(t1.name, "name"); //数据项 strcpy(t1.addr, "addr"); //数据项 strcpy(t1.tile, "addr"); //数据项 t1.age = 1;&#125; 数据元素之间不是独立的，存在特定的关系，这些关系即结构 *数据结构指数据对象中数据元素之间的关系 * 如：数组中各个元素之间存在固定的线性关系 编写一个“好”的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。 基本概念总结： 数据的逻辑结构 指数据元素之间的逻辑关系。即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。逻辑结构可细分为4类： 数据的物理结构 数据的运算 1.2 算法算法概念 算法是特定问题求解步骤的描述 在计算机中表现为指令的有限序列 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，语言并不重要，重要的是思想。 算法和数据结构区别 数据结构只是静态的描述了数据元素之间的关系 高效的程序需要在数据结构的基础上设计和选择算法 程序 = 数据结构 + 算法 总结： 算法是为了解决实际问题而设计的 数据结构是算法需要处理的问题载体 数据结构与算法相辅相成 算法特性 输入 算法具有0个或多个输入 输出 算法至少有1个或多个输出 有穷性 算法在有限的步骤之后会自动结束而不会无限循环 确定性 算法中的每一步都有确定的含义，不会出现二义性 可行性 算法的每一步都是可行的 算法效率的度量 1、事后统计法 比较不同算法对同一组输入数据的运行处理时间 缺陷 为了获得不同算法的运行时间必须编写相应程序 运行时间严重依赖硬件以及运行时的环境因素 算法的测试数据的选取相当困难 事后统计法虽然直观，但是实施困难且缺陷多 算法效率的度量 事前分析估算 依据统计的方法对算法效率进行估算 影响算法效率的主要因素 算法采用的策略和方法 问题的输入规模 编译器所产生的代码 计算机执行速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//算法最终编译成具体的计算机指令//每一个指令，在具体的计算机上运行速度固定//通过具体的n的步骤，就可以推导出算法的复杂度long sum1(int n)&#123; long ret = 0; int* array = (int*)malloc(n * sizeof(int)); int i = 0; for(i=0; i&lt;n; i++) array[i] = i + 1; for(i=0; i&lt;n; i++) ret += array[i]; free(array); return ret; &#125;long sum2(int n)&#123; long ret = 0; int i = 0; for(i=1; i&lt;=n; i++) ret += i; return ret;&#125;long sum3(int n)&#123; long ret = 0; if( n &gt; 0 ) ret = (1 + n) * n / 2; return ret;&#125;int main()&#123; printf("%d\n", sum1(100)); printf("%d\n", sum2(100)); printf("%d\n", sum3(100)); return 0;&#125;int func(int a[], int len)&#123; int i = 0; int j = 0; int s = 0; for(i=0; i&lt;len; i++)&#123; for(j=0; j&lt;len; j++)&#123; s += i*j; //n*n &#125; &#125; return s; &#125; 注意 1：判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。 注意 2：在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。 2、大 O 表示法 算法效率严重依赖于操作(Operation)数量 在判断时首先关注操作数量的最高次项 操作数量的估算可以作为时间复杂度的估算 1234O(5) = O(1)O(2n + 1) = O(2n) = O(n) O(n2+ n + 1) = O(n2)O(3n3+1) = O(3n3) = O(n3) 常见时间复杂度 关系 3、算法的空间复杂度 算法的空间复杂度通过计算算法的存储空间实现 1S(n) = O(f(n)) 其中，n 为问题规模，f(n) 为在问题规模为 n 时所占用存储空间的函数 大 O 表示法同样适用于算法的空间复杂度 当算法执行时所需要的空间是常数时，空间复杂度为O(1) 空间与时间的策略： 多数情况下，算法执行时所用的时间更令人关注 如果有必要，可以通过增加空间复杂度来降低时间复杂度 同理，也可以通过增加时间复杂度来降低空间复杂度 练习1：分析 sum1 sum2 sum3 函数的空间复杂度 1O(4n+12) O(8)=O(1) O(4)=O(1) 总结：实现算法时，需要分析具体问题，对执行时间和空间的要求。 练习2：时间换空间 1234567891011121314151617181920212223242526272829303132333435/* 问题： 在一个由自然数 1-1000 中某些数字所组成的数组中，每个数字可能出现零次或者多次。 设计一个算法，找出出现次数最多的数字。*/方法1： 排序，然后找出出现次数最多的数字方法2：void search(int a[], int len)&#123; int sp[1000] = &#123;0&#125;; int i = 0; int max = 0; for(i=0; i&lt;len; i++)&#123; int index = a[i] - 1; sp[index]++; &#125; for(i=0; i&lt;1000; i++)&#123; if( max &lt; sp[i] ) max = sp[i]; &#125; for(i=0; i&lt;1000; i++)&#123; if( max == sp[i] ) printf("%d\n", i+1); &#125;&#125;int main()&#123; int array[] = &#123;1, 1, 3, 4, 5, 6, 6, 6, 2, 3&#125;; search(array, sizeof(array)/sizeof(*array)); return 0;&#125; 把每个数字出现的次数的中间结果，缓存下来；在缓存的结果中求最大值。 二、线性表2.1 线性表基本概念线性表定义 线性表(List)是零个或多个数据元素的集合 线性表中的数据元素之间是有顺序的 线性表中的数据元素个数是有限的 线性表中的数据元素的类型必须相同 数学定义 线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列 12（a1, a2, …, an）ai 是表项，n 是表长度。 性质 a0 为线性表的第一个元素，只有一个后继 an 为线性表的最后一个元素，只有一个前驱 除 a0 和 an 外的其它元素 ai，既有前驱，又有后继 线性表能够逐项访问和顺序存取 练习 下面的关系中可以用线性表描述的是 A.班级中同学的友谊关系 N:N B.公司中的上下级关系 1:N C.冬天图书馆排队占座关系 D.花名册上名字之间的关系 1::1 线性表的操作 创建线性表 销毁线性表 清空线性表 将元素插入线性表 将元素从线性表中删除 获取线性表中某个位置的元素 获取线性表的长度 线性表在程序中表现为一种特殊的数据类型 线性表的操作在程序中的表现为一组函数 1234567891011121314151617181920212223242526272829/* C 语言描述=====》线性表的设计与实现 ADT 抽象层 《[数据结构(C语言版)].严蔚敏_吴伟民.扫描版.pdf》 p44页 */#ifndef _WBM_LIST_H_#define _WBM_LIST_H_typedef void List;typedef void ListNode;//创建并且返回一个空的线性表List* List_Create();//销毁一个线性表listvoid List_Destroy(List* list);//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态void List_Clear(List* list);//返回一个线性表list中的所有元素个数int List_Length(List* list);//向一个线性表list的pos位置处插入新元素nodeint List_Insert(List* list, ListNode* node, int pos); //获取一个线性表list的pos位置处的元素ListNode* List_Get(List* list, int pos);//删除一个线性表list的pos位置处的元素 返回值为被删除的元素，NULL表示删除失败ListNode* List_Delete(List* list, int pos);#endif/* 注意: */int List_Insert(List* list, ListNode* node, int pos); (重点:分离思想) 2.2 线性表的顺序存储结构基本概念 设计与实现 插入元素算法 判断线性表是否合法 判断插入位置是否合法 把最后一个元素到插入位置的元素后移一个位置 将新元素插入 线性表长度加 1 获取元素操作 判断线性表是否合法 判断位置是否合法 直接通过数组下标的方式获取元素 删除元素算法 判断线性表是否合法 判断删除位置是否合法 将元素取出 将删除位置后的元素分别向前移动一个位置 线性表长度减 1 链表顺序存储插入算法和删除算法 优点和缺点 优点： 无需为线性表中的逻辑关系增加额外的空间 可以快速的获取表中合法位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时难以确定存储空间的容量 2.3 线性表的链式存储基本概念 链式存储定义 为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。 表头结点 链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息 数据结点 链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息 尾结点 链表中的最后一个数据结点，其下一元素指针为空，表示无后继。 链表技术领域推演 设计与实现 链表链式存储 _api 实现分析 在C语言中可以用结构体来定义链表中的指针域 链表中的表头结点也可以用结构体实现 12345678910111213141516typedef void * LK; // 不希望看到内部数据是可以这么定义// 初始化链表LK init_LinkList(); // 插入节点void Insert_LinkList(LK list, int position, void *data);// 遍历void Foreach_LinkList(LK list, void(*myforeach)(void *)) ;// 删除节点void RemoveByPos_LinkList(LK list, int position);// 销毁void Destroy_LinkList(LK list); 123456789101112131415161718192021// 带头结点、位置从0的单链表// 返回链表中第3个位置处，元素的值LinkListNode* LinkList_Get(LinkList* list, int pos)&#123; int i = 0; TLinkList *tList = (TLinkList *)list; LinkListNode *current = NULL; LinkListNode *ret = NULL; if (list == NULL || pos &lt; 0 || pos &gt;= tList-&gt;length) return NULL; current = (LinkListNode *)tList; for (i=0; i&lt;pos; i++) current = current-&gt;next; ret = current-&gt;next; return ret ;&#125;/* */ 返回第三个位置的,移动pos次以后，当前指针指向哪里？ 答案：指向位置2，所以需要返回 ret = current-&gt;next; 1234567/* 备注：循环遍历时， 遍历第1次，指向位置0 遍历第2次，指向位置1 遍历第3次，指向位置2 遍历第n次，指向位置n-1;*/ 所以如果想返回位置 n 的元素的值，需要怎么做 ret = current-&gt;next; 此问题是：*指向头结点的指针移动 n 次 和 第 n 个元素之间的关系？ * 删除元素 优点和缺点 优点： 无需一次性定制链表的容量 插入和删除操作无需移动数据元素 缺点： 数据元素必须保存后继元素的位置信息 获取指定数据的元素操作需要顺序访问之前的元素 2.4 循环链表基本概念 循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素 循环链表拥有单链表的所有操作 创建链表 销毁链表 获取链表长度 清空链表 获取第pos个元素操作 插入元素到位置pos 删除位置pos处的元素 新增功能：游标 的定义 在循环链表中可以定义一个“当前”指针，这个指针通常称为 游标，可以通过这个游标来遍历链表中的所有元素。 循环链表新操作 123456789101112// 将游标重置指向链表中的第一个数据元素CircleListNode* CircleList_Reset(CircleList* list);// 获取当前游标指向的数据元素CircleListNode* CircleList_Current(CircleList* list);// 将游标移动指向到链表中的下一个数据元素CircleListNode* CircleList_Next(CircleList* list);// 直接指定删除链表中的某个数据元素 CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node); // 根据元素的 值 删除, 元素 pk 根据元素的 位置 删除元素 循环链表的应用 证明循环链表 打印两次。 约瑟夫问题求解 约瑟夫问题 - 循环链表典型应用 n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。 设计与实现 循环链表插入元素的分析 1） 普通插入元素（和单链表是一样的） 2） 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素） 1void CircleList_Insert(list, (CircleListNode*)&amp;v1, CircleList_Length(list)); 3） 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向 0 号结点 1void CircleList_Insert(list, (CircleListNode*)&amp;v1, 0); 4）第一次插入元素 循环链表插入综合场景分析图 循环链表删除结点分析 1、 删除普通结点 2、 删除头结点（删除 0 号位置处元素），需要求出尾结点 优点和缺点 优点：功能强了。 循环链表只是在单链表的基础上做了一个加强 循环链表可以完全取代单链表的使用 循环链表的 Next 和 Current 操作可以高效的遍历链表中的所有元素 缺点： 代码复杂度提高了 2.5 双向链表基本概念 请思考： 为什么 需要 双向链表？ 单链表的结点都只有一个指向下一个结点的指针 单链表的数据元素无法直接访问其前驱元素 逆序访问单链表 中的元素是极其 耗时 的操作！ 1234567len = LinkList_Length(list);for (i=len-1; len&gt;=0; i++) //O(n)&#123; LinkListNode *p = LinkList_Get(list, i); //O(n) //访问数据元素p中的元素 //&#125; 双向链表的定义 在单链表的结点中增加一个指向其前驱的 pre 指针 双向链表拥有单链表的所有操作 创建链表 销毁链表 获取链表长度 清空链表 获取第 pos 个元素操作 插入元素到位置 pos 删除位置 pos 处的元素 设计与实现 循环链表一般操作 插入操作 插入操作异常处理 插入第一个元素异常处理 在 0 号位置处插入元素； 删除操作 删除操作异常处理 双向链表的新操作 获取当前游标指向的数据元素 将游标重置指向链表中的第一个数据元素 将游标移动指向到链表中的下一个数据元素 将游标移动指向到链表中的上一个数据元素 直接指定删除链表中的某个数据元素 123456DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node);DLinkListNode* DLinkList_Reset(DLinkList* list);DLinkListNode* DLinkList_Current(DLinkList* list);DLinkListNode* DLinkList_Next(DLinkList* list);DLinkListNode* DLinkList_Pre(DLinkList* list);//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点；做一个企业级的财富库，完成你人生开发经验的积累，是我们的学习重点，要注意！ 优点和缺点 优点： 双向链表在单链表的基础上增加了指向前驱的指针 功能上双向链表可以完全取代单链表的使用 双向链表的 Next，Pre 和 Current 操作可以高效的遍历链表中的所有元素 缺点： 代码复杂 三、栈 stack 和队列 queue3.1栈 stackStack基本概念 栈是一种 特殊的线性表 栈仅能在线性表的一端进行操作 栈顶(Top)：允许操作的一端 栈底(Bottom)：不允许操作的一端 Stack的常用操作 创建栈 销毁栈 清空栈 进栈 出栈 获取栈顶元素 获取栈的大小 1234567891011121314151617181920#ifndef _MY_STACK_H_#define _MY_STACK_H_typedef void Stack;Stack* Stack_Create();void Stack_Destroy(Stack* stack);void Stack_Clear(Stack* stack);int Stack_Push(Stack* stack, void* item);void* Stack_Pop(Stack* stack);void* Stack_Top(Stack* stack);int Stack_Size(Stack* stack);#endif //_MY_STACK_H_ 栈模型和链表模型关系分析 栈的顺序存储设计与实现 设计与实现 1234567891011121314151617181920212223#ifndef __MY_SEQLIST_H__ #define __MY_SEQLIST_H__typedef void SeqList;typedef void SeqListNode;SeqList* SeqStack_Create(int capacity);void SeqStack _Destroy(SeqStack * list);void SeqStack _Clear(SeqStack * list);int SeqStack _Length(SeqStack * list);int SeqStack _Capacity(SeqStack * list);int SeqStack _Insert(SeqStack * list, SeqListNode* node, int pos);SeqListNode* SeqList_Get(SeqList* list, int pos);SeqListNode* SeqList_Delete(SeqList* list, int pos);#endif //__MY_SEQLIST_H__ 栈的链式存储设计与实现 设计与实现 1234567891011121314151617181920#ifndef _MY_LINKSTACK_H_#define _MY_LINKSTACK_H_typedef void LinkStack;LinkStack* LinkStack_Create();void LinkStack_Destroy(LinkStack* stack);void LinkStack_Clear(LinkStack* stack);int LinkStack_Push(LinkStack* stack, void* item);void* LinkStack_Pop(LinkStack* stack);void* LinkStack_Top(LinkStack* stack);int LinkStack_Size(LinkStack* stack);#endif //_MY_LINKSTACK_H_ 栈的应用 案例1：就近匹配 应用1：就近匹配 几乎所有的编译器都具有检测括号是否匹配的能力 如何实现编译器中的符号成对检测？ 1234567#include &lt;stdio.h&gt; int main() &#123; int a[4][4]; int (*p)[4]; p = a[0]; return 0;&#125; 算法思路 从第一个字符开始扫描 当遇见普通字符时忽略， 当遇见左符号时压入栈中 当遇见右符号时从栈中弹出栈顶符号，并进行匹配 匹配成功：继续读入下一个字符 匹配失败：立即停止，并报错 结束： 成功: 所有字符扫描完毕，且栈为空 失败：匹配失败或所有字符扫描完毕但栈非空 当需要检测成对出现但又互不相邻的事物时，可以使用栈 “后进先出” 的特性，栈非常适合于需要“就近匹配”的场合 案例2：中缀表达式和后缀表达式 应用2：中缀 后缀 计算机的本质工作就是做数学运算，那计算机可以读入字符串 “9 + (3 - 1) * 5 + 8 / 2”并计算值吗？ 后缀表达式 ==？符合计算机运算 波兰科学家在20世纪50年代提出了一种将运算符放在数字后面的后缀表达式对应的， 我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯 1234// 实例：5 + 4=&gt; 5 4 + 1 + 2 * 3 =&gt; 1 2 3 * + 8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * + 中缀表达式符合人类的阅读和思维习惯 后缀表达式符合计算机的“运算习惯” 如何将中缀表达式转换成后缀表达式？ 中缀转后缀算法： 遍历中缀表达式中的数字和符号 对于数字：直接输出 对于符号： 左括号：进栈 运算符号：与栈顶符号进行优先级比较 若栈顶符号优先级低：此符合进栈 （默认栈顶若是左括号，左括号优先级最低） 若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈 右括号：将栈顶符号弹出并输出，直到匹配左括号 遍历结束：将栈中的所有符号弹出并输出 中缀转后缀 计算机是如何基于后缀表达式计算的？ 8 3 1 – 5 * + 遍历后缀表达式中的数字和符号 对于数字：进栈 对于符号： 从栈中弹出右操作数 从栈中弹出左操作数 根据符号进行运算 将运算结果压入栈中 遍历结束：栈中的唯一数字为计算结果 栈的神奇！ 中缀表达式是人习惯的表达方式 后缀表达式是计算机喜欢的表达方式 通过栈可以方便的将中缀形式变换为后缀形式 中缀表达式的计算过程类似程序编译运行的过程 扩展：给你一个字符串，计算结果 “1 + 2 * (66 / (2 * 3) + 7 )” 字符串解析 词法语法分析 优先级分析 数据结构选型===》栈还是树？ 3.2 队列queuequeue基本概念 队列是一种特殊的线性表 队列仅在线性表的两端进行操作 队头(Front)：取出数据元素的一端 队尾(Rear)：插入数据元素的一端 队列不允许在中间部位进行操作！ queue常用操作 销毁队列 清空队列 进队列 出队列 获取队头元素 获取队列的长度 1234567891011121314151617181920#ifndef _MY_QUEUE_H_#define _MY_QUEUE_H_typedef void Queue;Queue* Queue_Create();void Queue_Destroy(Queue* queue);void Queue_Clear(Queue* queue);int Queue_Append(Queue* queue, void* item);void* Queue_Retrieve(Queue* queue);void* Queue_Header(Queue* queue);int Queue_Length(Queue* queue);#endif //_MY_QUEUE_H_ 队列模型和链表模型关系分析 队列的顺序存储设计与实现 队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。 设计与实现 12345678910111213141516171819202122#ifndef _MY_SEQQUEUE_H_#define _MY_SEQQUEUE_H_typedef void SeqQueue;SeqQueue* SeqQueue_Create(int capacity);void SeqQueue_Destroy(SeqQueue* queue);void SeqQueue_Clear(SeqQueue* queue);int SeqQueue_Append(SeqQueue* queue, void* item);void* SeqQueue_Retrieve(SeqQueue* queue);void* SeqQueue_Header(SeqQueue* queue);int SeqQueue_Length(SeqQueue* queue);int SeqQueue_Capacity(SeqQueue* queue);#endif //_MY_SEQQUEUE_H_ 队列的链式存储设计与实现 队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。 设计与实现 1234567891011121314151617181920#ifndef _MY_LINKQUEUE_H_#define _MY_LINKQUEUE_H_typedef void LinkQueue;LinkQueue* LinkQueue_Create();void LinkQueue_Destroy(LinkQueue* queue);void LinkQueue_Clear(LinkQueue* queue);int LinkQueue_Append(LinkQueue* queue, void* item);void* LinkQueue_Retrieve(LinkQueue* queue);void* LinkQueue_Header(LinkQueue* queue);int LinkQueue_Length(LinkQueue* queue);#endif //_MY_LINKQUEUE_H_ 四、树专题树基本概念 非线性结构，一个直接前驱，但可能有多个直接后继（1:n） 树的表示法 图形表示法 广义表表示法 左孩子－右兄弟表示法 双亲孩子表示法 树的逻辑结构 一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。 广义表表示法 左孩子－右兄弟表示法 4.1 二叉树概念 先序遍历（DLR）：先访问根、再访问左、再访问右 中序遍历（LDR）：先访问左、再访问根、再访问右 后序遍历（LRD）：先访问左、再访问右、再访问根 二叉树的结构最简单，规律性最强。可以证明，所有树都能转为唯一对应的二叉树，不失一般性 定义：是 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 二叉树性质 性质1: 在二叉树的第 i 层上至多有 个结点（i&gt;0） 性质2: 深度为 k 的二叉树至多有 个结点（k&gt;0） 性质3: 对于任何一棵二叉树，若 2 度的结点数有 个，则叶子数（）必定为 （即） 满二叉树：一棵深度为 k 且有 个结点的二叉树。（特点：每层都“充满”了结点） 完全二叉树：深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应。 理解：（k-1 层与满二叉树完全相同，第 k 层结点尽力靠左） 性质4: 具有 n 个结点的完全二叉树的深度必为 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为 i 的结点，其左孩子编号必为 2i，其右孩子编号必为 2i + 1；其双亲的编号必为 i/2（i=1 时为根,除外） 二叉树的存储结构 1、顺序存储结构 按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。 答：一律转为完全二叉树！ 讨论：不是完全二叉树怎么办？ 方法很简单，将各层空缺处统统补上“虚结点”，其内容为空 2、链式存储结构 二叉树的表示 12345678910111213141516/*typedef struct BiTNode&#123; int data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;*/struct BiTNode&#123; int data; struct BiTNode *lchild, *rchild;&#125;;typedef struct BiTNode BiTNode;typedef struct BiTNode * BiTree; 树的三叉链表表示 12345678910111213141516171819202122232425typedef struct TriTNode &#123; int data; //左右孩子指针 struct TriTNode *lchild, *rchild; struct TriTNode *parent;&#125;TriTNode, *TriTree;双亲链表法//双亲链表#define MAX_TREE_SIZE 100typedef struct BPTNode&#123; int data; int parentPosition; //指向双亲的指针 //数组下标 char LRTag; //左右孩子标志域&#125;BPTNode;typedef struct BPTree&#123; BPTNode nodes[100]; //因为节点之间是分散的，需要把节点存储到数组中 int num_node; //节点数目 int root; //根结点的位置 //注意此域存储的是父亲节点在数组的下标&#125;BPTree;//用这个数据结构能表达出一颗树，为什么？ 二叉树的遍历 树的遍历本质剖析 4.2 二叉树编程实践12345typedef struct node&#123; int data; struct node *lchild,*rchild；&#125; NODE;NODE *root; 先序遍历算法 123456789DLR(NODE *root )&#123; if (root) //非空二叉树 &#123; printf(“%d”,root-&gt;data); //访问D DLR(root-&gt;lchild); //递归遍历左子树 DLR(root-&gt;rchild); //递归遍历右子树 &#125;&#125; 中序遍历算法 123456789LDR(NODE *root)&#123; if(root !=NULL) &#123; LDR(root-&gt;lchild); printf(“%d”,root-&gt;data); LDR(root-&gt;rchild); &#125; &#125; 后序遍历算法 123456789LRD (NODE *root)&#123; if(root !=NULL) &#123; LRD(root-&gt;lchild); LRD(root-&gt;rchild); printf(“%d”,root-&gt;data); &#125; &#125; 案例1：计算二叉树中叶子结点的数目 123456789101112131415int sum = 0; //全局变量DLR_CountLeafNum(NODE *root)//采用中序遍历的递归算法&#123; if ( root) //非空二叉树条件，还可写成if(root !=NULL ) &#123; if(!root-&gt;lchild&amp;&amp;!root-&gt;rchild) //是叶子结点则统计并打印 &#123; sum++; printf("%d\n",root-&gt;data); &#125; DLR_CountLeafNum(root-&gt;lchild); //递归遍历左子树，直到叶子处； DLR_CountLeafNum(root-&gt;rchild);&#125;//递归遍历右子树，直到叶子处； &#125; return(0); &#125; 思想： 1）求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。​ 2）若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。​ 3）全局变量转成函数参数​ 4）按照先序、中序、后序方式计算叶子结点，===》三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。 案例2：求二叉树的深度 思想： 1）求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再 +1。 ​ 2）若左子树还是树，重复步骤 1；若右子树还是树，重复步骤 1。 案例3：完全Copy二叉树 思想： 1）malloc新结点， ​ 2）拷贝左子树，拷贝右子树，让新结点连接左子树，右子树 ​ 3）若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。 案例4：树的非递归遍历(中序遍历) 中序 遍历的几种情况 分析1： 什么时候访问根、什么时候访问左子树、什么访问右子树 当左子树为空或者左子树已经访问完毕以后，再访问根 访问完毕根以后，再访问右子树。 分析2： 非递归遍历树，访问结点时，为什么是栈，而不是其他模型（比如说是队列）。 先走到的后访问、后走到的先访问，显然是栈结构 分析3：结点所有路径情况 步骤1： 如果结点有左子树，该结点入栈； 如果结点没有左子树，访问该结点； 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 注意：入栈的结点表示，本身没有被访问过，同时右子树也没有被访问过。 分析4：有一个一直往左走入栈的操作，中序遍历的起点 作业：自己编写堆栈函数原型，实现中序遍历非递归算法 4.3 二叉树的创建中序和先序创建树 1、根据中序遍历的结果能确定一棵树吗？ 中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？ 请思考，会有多少种形状。 2、如何才能确定一棵树？ 结论： 通过中序遍历和先序遍历可以确定一个树 ​ 通过中序遍历和后续遍历可以确定一个树 ​ 通过先序遍历和后序遍历确定不了一个树。 单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。 3、根据先序和中序结果画树 算法 1、通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树 2、在A的左子树中，找左子树的根结点（在先序中找），转步骤1 3、在A的右子树中，找右子树的根结点（在先序中找），转步骤1 讲解： 先序遍历结果：ADEBCF 中序遍历结果：DEACFB 练习： 先序遍历结果：ABDHKECFIGJ 中序遍历结果：HKDBEAIFCGJ 4、学习算法可借助工具、动画 #号法创建树 1、什么是 # 号法创建树 # 创建树，让树的每一个节点都变成度数为2的树 先序遍历：124###3## 可以唯一确定一棵树吗，为什么？ 2、# 创建树练习 先序遍历：ABDH#K###E##CFI###G#J## ,请画出树的形状 # 号法画出树关键点： 要清楚的确定左子树什么结束，右子树什么时候开始。 3、# 号法编程实践 利用前序遍历来建树（结点值陆续从键盘输入，用 DLR 为宜） 1234567891011121314151617181920212223242526272829303132Bintree createBTpre( )&#123; Bintree T; char ch; scanf(“%c”,&amp;ch); if(ch==’#’) T=NULL; else &#123; T=( Bintree )malloc(sizeof(BinTNode)); T-&gt;data=ch; T-&gt;lchild=createBTpre(); T-&gt;rchild=createBTpre(); &#125; return T;&#125;//后序遍历销毁一个树void BiTree_Free(BiTNode* T)&#123; BiTNode *tmp = NULL; if (T!= NULL) &#123; if (T-&gt;rchild != NULL) BiTree_Free(T-&gt;rchild); if (T-&gt;lchild != NULL) BiTree_Free(T-&gt;lchild); if (T != NULL) &#123; free(T); T = NULL; &#125; &#125;&#125; 4.4 二叉线索树线索化概念 1、前言 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。 若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树了。 二叉线索树思想是干什么的？ 中序遍历这棵树===》转换成链表访问 2、线索化思想 结论： 线索化过程就是在遍历过程（假设是中序遍历）中修改空指针的过程： ​ 将空的lchild改为结点的直接前驱； ​ 将空的rchild改为结点的直接后继。 3、线索化思想训练 请将此树线索化。 1）右空指针线索化： 2）左空指针线索化 3）总结 线索化的实现 1）线索化树结点 1234567typedef struct BiThrNode /* 二叉线索存储结点结构 */&#123; char data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ int LTag; int RTag; /* 左右标志 */&#125; BiThrNode, *BiThrTree; 2）线索化思想分析 线索化的本质：让前后结点，建立关系； 1）两个辅助指针变量形成差值后：后继结点的左孩子指向前驱结点，前驱结点的右孩子指向后继结点。 2）赋值指针变量和业务操作的逻辑关系 4） 二叉树线索化树的遍历 123456789101112131415161718192021/* 中序遍历二叉线索树T(头结点)的非递归算法 */int InOrderTraverse_Thr(BiThrNode* T)&#123; BiThrNode* p; p = T-&gt;lchild; /* p指向根结点 */ while (p != T) &#123; /* 空树或遍历结束时,p==T */ while (p-&gt;LTag == Link) p = p-&gt;lchild; printf("%c ", p-&gt;data); while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; p = p-&gt;rchild; printf("%c ", p-&gt;data); &#125; p=p-&gt;rchild; &#125; return 0;&#125; 4.5 霍夫曼树组建一个网络，耗费最小 WPL最小；这个方法是霍夫曼想出来的，称为霍夫曼树 霍夫曼树的构造 对于文本 ”BADCADFEED” 的传输而言，因为重复出现的只有 ”ABCDEF” 这6个字符，因此可以用下面的方式编码： 接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。 这样的编码方式需要30个bit位才能表示10个字符 那么当传输一篇500个字符的情报时，需要15000个bit位 在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。 如何提高收发效率？ 要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位 准则：任一字符的编码都不是另一个字符编码的前缀！ 也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。 霍夫曼树 1、给定 n 个数值 { v1, v2, …, vn} 2、根据这 n 个数值构造二叉树集合 F F = { T1, T2, …, Tn} Ti 的数据域为 vi，左右子树为空 3、在 F 中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和 4、在 F 中删除这两棵子树，并将构造的新二叉树加入F中 5、重复 3 和 4，直到 F 中只剩下一个树为止。这棵树即霍夫曼树 假设经过统计 ABCDEF 在需要传输的报文中出现的概率如下 霍夫曼树是一种特殊的二叉树 霍夫曼树应用于信息编码和数据压缩领域 霍夫曼树是现代压缩算法的基础 五、 排序5.1 基本概念排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。 排序数学定义： 假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：Kp1≤Kp2≤…≤Kpn 。按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序 排序的稳定性： 如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的；否则称这个排序方法是不稳定的。 多关键字排序： 排序时需要比较的关键字多余一个 排序结果首先按关键字1进行排序 当关键字1相同时按关键字2进行排序 当关键字n-1相同时按关键字n进行排序 对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！ 排序中的关键操作： 比较 任意两个数据元素通过比较操作确定先后次序 交换 数据元素之间需要交换才能得到预期结果 内排序和外排序： 内排序 整个排序过程不需要访问外存便能完成 外排序 待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成 排序的审判： 时间性能 关键性能差异体现在比较和交换的数量 辅助存储空间 为完成排序操作需要的额外的存储空间 必要时可以“空间换时间” 算法的实现复杂性 过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能 总结： 排序是数据元素从无序到有序的过程 排序具有稳定性，是选择排序算法的因素之一 比较和交换是排序的基本操作 多关键字排序与单关键字排序无本质区别 排序的时间性能是区分排序算法好坏的主要因素 5.2 选择法基本思想： 每一趟 (例如第 i 趟，i = 0, 1, …,n-2)在后面 n-i个待排的数据元素中选出关键字最小的元素, 作为有序元素序列的第 i 个元素。 排序过程： 首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换 再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换 重复上述操作，共进行n-1趟排序后，排序结束 5.3 插入排序基本思想： 元素1个元素， 排序过程： 整个排序过程为 n-1 趟插入，即先将序列中第 1 个记录看成是一个有序子序列，然后从第 2 个记录开始，逐个进行插入，直至整个序列有序 实质：对线性表执行 n-1 次插入操作，只是先要找到插入位置 V[0], V[1], …, V[i-1] 已经排好序。这时已经排好序。这时,用V[i]的关键字与 V[i-1], V[i-2], …的关键字进行比较, 找到插入位置即将V[i]]插入, 原来位置上的对象向后顺移。 插入排序关键点： 1、拿出一个元素，留出位置 2、符合条件的元素后移 5.4 冒泡排序 5.5 希尔排序排序过程： 先取一个正整数 d1&lt;n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2&lt;d1，重复上述分组和排序操作；直至 di=1，即所有记录放进一个组中排序为止 O(n-1.3) Q(nlogn) 希尔排序是不稳定的。 5.6 快速排序思想： 快速排序是对冒泡排序的一种改进。它的基本思想是： 通过一躺排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间； 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 12345// O(n*logn)不稳定，分组，后面的有可能跑到前面去了。21 100 3 50 1 3 1 21 100 50 1 3 21 50 100 5.7 归并排序注意：一个元素，可以看做有序的，是稳定的算法 对一个数组分成两路，mid中间 设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m],R[m+1..high],先将它们合并到一个局部的暂存向量R1(相当于输出堆)中,待合并完成后将R1复制回R[low..high]中。 5.8 排序总结 六、C++ 模板类与数据结构基础C++模板是容器的概念。 理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 加入到容器中的元素，应该可以被加入才行。 模板类设计与实现 链表类_链式存储设计与实现 栈类_链式存储设计与实现 队列类_链式存储设计与实现 链表类_顺序存储设计与实现 栈类_顺序存储设计与实现 队列类_顺序存储设计与实现]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 进阶]]></title>
    <url>%2F2016%2F05%2F24%2FProgram-C%2Fprogram-c-advance%2F</url>
    <content type="text"><![CDATA[C 语言进阶一、 内存分区栈区 由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。 堆区 由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。 12345678910111213141516171819#include &lt;stdlib.h&gt;void *calloc(size_t nmemb, size_t size);功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存置0。参数： nmemb：所需内存单元数量 size：每个内存单元的大小（单位：字节）返回值： 成功：分配空间的起始地址 失败：NULL#include &lt;stdlib.h&gt;void *realloc(void *ptr, size_t size);功能：重新分配用malloc或者calloc函数在堆中分配内存空间的大小。realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。参数： ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 size：为重新分配内存的大小, 单位：字节返回值： 成功：新分配的堆内存地址 失败：NULL 全局/静态区 全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储全局变量、静态变量和常量。 注意： 这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。 全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。 字符串常量存储在全局/静态存储区的常量区。 12345678910int v1 = 10;//全局/静态区const int v2 = 20; //常量，一旦初始化，不可修改static int v3 = 20; //全局/静态区char *p1; //全局/静态区，编译器默认初始化为NULL//那么全局static int 和 全局int变量有什么区别？void test()&#123; static int v4 = 20; //全局/静态区&#125; 字符串常量是否可修改？字符串常量优化： ANSI C中规定：修改字符串常量，结果是未定义的。ANSI C并没有规定编译器的实现者对字符串的处理，例如：1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。所以尽量不要去修改字符串常量！ C99标准：char p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *If an attempt is made to use p to modify the contents of the array, the behavior is undefined**. 总结 在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。 数据区包括：堆，栈，全局/静态存储区。 全局/静态存储区包括：常量区，全局区、静态区。 常量区包括：字符串常量区、常变量区。 代码区：存放程序编译后的二进制代码，不可寻址区。 可以说，C/C++内存分区其实只有两个，即代码区和数据区。 函数调用模型： 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 临时变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 栈的生长方向和内存存放方向： 二、指针强化指针是一种数据类型，占用内存空间，用来保存内存地址。 2.1 野指针和空指针2.1.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存： 123456789void test()&#123; char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, "1111"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, "2222"); //err &#125; 2.1.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下会导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子： 1234567891011#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; n = *p; printf("value = %d\n", n); return 0;&#125; 运行结果： 1value = 100 n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 *p 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 *p 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？ 为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果： 123456789101112#include &lt;stdio.h&gt;int *func()&#123; int n = 100; return &amp;n;&#125;int main()&#123; int *p = func(), n; printf("c.biancheng.net\n"); n = *p; printf("value = %d\n", n); return 0;&#125; 运行结果： 12c.biancheng.netvalue = -2 可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 *p 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？ 前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。 关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《C语言和内存》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。 第一个例子在调用其他函数之前使用 *p 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 *p 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。 总结： 常规程序中，函数返回的指针通常应该是： 指向静态（static）变量； 指向专门申请分配的（如用malloc）空间； 指向常量区（如指向字符串”hello”）； 指向全局变量； 指向程序代码区（如指向函数的指针）。 除这5项以外，其它怪技巧不提倡。 函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁。当返回为指针的时候需要特别注意，因为函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数 2.2 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 *。 注意：对一个int*类型指针解引用会产生一个整型值，类似地，对一个float*指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 * 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 * 放在等号的左边赋值（给内存赋值，写内存） * 放在等号的右边取值（从内存中取值，读内存） 123456789101112131415161718//解引用void test01()&#123; //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = &amp;a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = "hello world!"; *str = 'm'; printf("a:%d\n", a); printf("*p:%d\n", *p); printf("b:%d\n", b);&#125; 2.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 2.4 指针的意义_间接赋值通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 123456789void test()&#123; int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = &amp;a; //通过*操作内存 *p = 22;&#125; 间接赋值：从1级指针到2级指针： 12345678910111213141516171819202122232425262728void AllocateSpace(char** p)&#123; *p = (char*)malloc(100); strcpy(*p, "hello world!");&#125;void FreeSpace(char** p)&#123; if (p == NULL)&#123; return; &#125; if (*p != NULL)&#123; free(*p); *p = NULL; &#125;&#125;void test()&#123; char* p = NULL; AllocateSpace(&amp;p); printf("%s\n",p); FreeSpace(&amp;p); if (p == NULL)&#123; printf("p内存释放!\n"); &#125;&#125; 间接赋值的推论： 用 1 级指针形参，去间接修改了 0 级指针(实参)的值。 用 2 级指针形参，去间接修改了 1 级指针(实参)的值。 用 3 级指针形参，去间接修改了 2 级指针(实参)的值。 用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。 2.5 指针做函数参数指针做函数参数，具备输入和输出特性： 输入：主调函数分配内存 输出：被调用函数分配内存 输入特性： 12345678910111213void fun(char *p /* in */)&#123; //给p指向的内存区域拷贝内容 strcpy(p, "abcddsgsd");&#125;void test(void)&#123; //输入，主调函数分配内存 char buf[100] = &#123; 0 &#125;; fun(buf); printf("buf = %s\n", buf);&#125; 输出特性： 12345678910111213141516171819202122232425void fun(char **p /* out */, int *len)&#123; char *tmp = (char *)malloc(100); if (tmp == NULL) &#123; return; &#125; strcpy(tmp, "adlsgjldsk"); //间接赋值 *p = tmp; *len = strlen(tmp);&#125;void test(void)&#123; //输出，被调用函数分配内存，地址传递 char *p = NULL; int len = 0; fun(&amp;p, &amp;len); if (p != NULL) &#123; printf("p = %s, len = %d\n", p, len); &#125;&#125; 2.6 字符串指针强化字符串是以0或者’\0’结尾的字符数组，(数字0和字符’\0’等价) 如果以字符串初始化，那么编译器默认会在字符串尾部添加’\0’ 1char str3[] = "hello"; sizeof 计算数组大小，数组包含’\0’字符 strlen 计算字符串的长度，到’\0’结束 字符串拷贝功能实现： 1234567891011121314151617//1）应该判断下传入的参数是否为NULL//2）最好不要直接使用形参int copy_string04(char* dest, char* source)&#123; if (dest == NULL)&#123; return -1; &#125; if (source == NULL)&#123; return -2; &#125; char* src = source; char* tar = dest; while (*tar++ = *src++)&#123;&#125; return 0;&#125; 字符串的格式化： 12345678910#include &lt;stdio.h&gt;int sprintf(char *str, const char *format, ...);功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\0' 为止。参数： str：字符串首地址 format：字符串格式，用法和printf()一样返回值： 成功：实际格式化的字符个数 失败： - 1 1234567891011121314151617181920212223242526272829//1. 格式化字符串char buf[1024] = &#123; 0 &#125;;sprintf(buf, "你好,%s,欢迎加入我们!", "John");printf("buf:%s\n",buf);memset(buf, 0, 1024);sprintf(buf, "我今年%d岁了!", 20);printf("buf:%s\n", buf);//2. 拼接字符串memset(buf, 0, 1024);char str1[] = "hello";char str2[] = "world";int len = sprintf(buf,"%s %s",str1,str2);printf("buf:%s len:%d\n", buf,len);//3. 数字转字符串memset(buf, 0, 1024);int num = 100;sprintf(buf, "%d", num);printf("buf:%s\n", buf);//设置宽度 右对齐memset(buf, 0, 1024);sprintf(buf, "%8d", num);printf("buf:%s\n", buf);//设置宽度 左对齐memset(buf, 0, 1024);sprintf(buf, "%-8d", num);printf("buf:%s\n", buf); 12345678910#include &lt;stdio.h&gt;int sscanf(const char *str, const char *format, ...);功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。参数： str：指定的字符串首地址 format：字符串格式，用法和scanf()一样返回值： 成功：实际读取的字符个数 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//1. 跳过数据void test01()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf("123456aaaa", "%*d%s", buf); printf("buf:%s\n",buf);&#125;//2. 读取指定宽度数据void test02()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 sscanf("123456aaaa", "%7s", buf); printf("buf:%s\n", buf);&#125;//3. 匹配a-z中任意字符void test03()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf("abcdefg123456", "%[a-z]", buf); printf("buf:%s\n", buf);&#125;//4. 匹配aBc中的任何一个void test04()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf("abcdefg123456", "%[aBc]", buf); printf("buf:%s\n", buf);&#125;//5. 匹配非a的任意字符void test05()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf("bcdefag123456", "%[^a]", buf); printf("buf:%s\n", buf);&#125;//6. 匹配非a-z中的任意字符void test06()&#123; char buf[1024] = &#123; 0 &#125;; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 sscanf("123456ABCDbcdefag", "%[^a-z]", buf); printf("buf:%s\n", buf);&#125; 2.6.1 一级指针易错点 越界 指针叠加会不断改变指针指向 p++ 返回局部变量地址 123456char *get_str()&#123; char str[] = "abcdedsgads"; //栈区， printf("[get_str]str = %s\n", str); return str;&#125; 同一块内存释放多次 free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存 2.7 const使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//const修饰变量void test01()&#123; //1. const基本概念 const int i = 0; //i = 100; //错误，只读变量初始化之后不能修改 //2. 定义const变量最好初始化 const int j; //j = 100; //错误，不能再次赋值 //3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改 const int k = 10; //k = 100; //错误，不可直接修改，我们可通过指针间接修改 printf("k:%d\n", k); int* p = &amp;k; *p = 100; printf("k:%d\n", k);&#125;//const 修饰指针void test02()&#123; int a = 10; int b = 20; //const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向 const int* p_a = &amp;a; //*p_a = 100; //不可修改指针指向的内存空间 p_a = &amp;b; //可修改指针的指向 //const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间 int* const p_b = &amp;a; //p_b = &amp;b; //不可修改指针的指向 *p_b = 100; //可修改指针指向的内存空间 //指针的指向和指针指向的内存空间都不能修改 const int* const p_c = &amp;a;&#125;//const指针用法struct Person&#123; char name[64]; int id; int age; int score;&#125;;//每次都对对象进行拷贝，效率低，应该用指针void printPersonByValue(struct Person person)&#123; printf("Name:%s\n", person.name); printf("Name:%d\n", person.id); printf("Name:%d\n", person.age); printf("Name:%d\n", person.score);&#125;//但是用指针会有副作用，可能会不小心修改原数据void printPersonByPointer(const struct Person *person)&#123; printf("Name:%s\n", person-&gt;name); printf("Name:%d\n", person-&gt;id); printf("Name:%d\n", person-&gt;age); printf("Name:%d\n", person-&gt;score);&#125;void test03()&#123; struct Person p = &#123; "Obama", 1101, 23, 87 &#125;; //printPersonByValue(p); printPersonByPointer(&amp;p);&#125; 三、指针的指针(二级指针)123int a = 12;int *b = &amp;a;int **c = &amp;b; 它在内存中的大概模样大致如下： 3.1 二级指针做形参输出特性二级指针做参数的输出特性是指由被调函数分配内存。 1234567891011121314151617181920212223242526272829303132333435363738//被调函数,由参数n确定分配多少个元素内存void allocate_space(int **arr,int n)&#123; //堆上分配n个int类型元素内存 int *temp = (int *)malloc(sizeof(int)* n); if (NULL == temp)&#123; return; &#125; //给内存初始化值 int *pTemp = temp; for (int i = 0; i &lt; n;i ++)&#123; //temp[i] = i + 100; *pTemp = i + 100; pTemp++; &#125; //指针间接赋值 *arr = temp;&#125;//打印数组void print_array(int *arr,int n)&#123; for (int i = 0; i &lt; n;i ++)&#123; printf("%d ",arr[i]); &#125; printf("\n");&#125;//二级指针输出特性(由被调函数分配内存)void test()&#123; int *arr = NULL; int n = 10; //给arr指针间接赋值 allocate_space(&amp;arr,n); //输出arr指向数组的内存 print_array(arr, n); //释放arr所指向内存空间的值 if (arr != NULL)&#123; free(arr); arr = NULL; &#125;&#125; 3.2 二级指针做形参输入特性二级指针做形参输入特性是指由主调函数分配内存。 123456789101112131415161718192021222324252627282930//打印数组void print_array(int **arr,int n)&#123; for (int i = 0; i &lt; n;i ++)&#123; printf("%d ",*(arr[i])); &#125; printf("\n");&#125;//二级指针输入特性(由主调函数分配内存)void test()&#123; int a1 = 10; int a2 = 20; int a3 = 30; int a4 = 40; int a5 = 50; int n = 5; int** arr = (int **)malloc(sizeof(int *) * n); arr[0] = &amp;a1; arr[1] = &amp;a2; arr[2] = &amp;a3; arr[3] = &amp;a4; arr[4] = &amp;a5; print_array(arr,n); free(arr); arr = NULL;&#125; 四、位运算4.1 位逻辑运算符4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 按位取反~ 1234unsigned char a = 2; //00000010unsigned char b = ~a; //11111101printf("ret = %d\n", a); //ret = 2printf("ret = %d\n", b); //ret = 253 位与（AND）: &amp; 二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 位或（OR）: | 二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. 位异或: 二进制运算符 ^ 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. 123 (10010011) ^ (00111101)= (10101110) 用法： 打开位 已知：10011010： 将位2打开 flag | 10011010 123 (10011010)| (00000100)= (10011110) 将所有位打开。 flag | ~flag 123 (10011010)| (01100101)= (11111111) 关闭位 flag &amp; ~flag 123 (10011010)&amp; (01100101)= (00000000) 转置位 转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 b^1 为0，如果b为0，则 1^b 为1。无论b的值是0还是1, 0^b 为b. flag ^ 0xff 123 (10010011)^ (11111111)= (01101100) 交换两个数不需要临时变量 123456789101112131415161718192021222324//a ^ b = temp;//a ^ temp = b;//b ^ temp = a (10010011)^ (00100110)= (10110101) (10110101)^ (00100110) 10010011#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int a = 2, b = 6; a = a ^ b; b = b ^ a; a = a ^ b; printf("a = %d b = %d/n", a, b); return 0;&#125; 4.2 移位运算符 左移 &lt;&lt; 左移运算符 &lt;&lt; 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 左移一位相当于原值 *2. 1234567(10001010) &lt;&lt; 2(00101000) 1 &lt;&lt; 1 = 2;2 &lt;&lt; 1 = 4;4 &lt;&lt; 1 = 8;8 &lt;&lt; 2 = 32 右移 &gt;&gt; 右移运算符 &gt;&gt; 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 12345678910//有符号值(10001010) &gt;&gt; 2(00100010) //在某些系统上的结果值(10001010) &gt;&gt; 2(11100010) //在另一些系统上的解雇//无符号值(10001010) &gt;&gt; 2(00100010) //所有系统上的结果值 用法：移位运算符： 移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。 number &lt;&lt; n number乘以2的n次幂 number &gt;&gt; n 如果number非负，则用number除以2的n次幂 五、多维数组5.1 一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 12345int arr[10];//arr = NULL; //arr作为指针常量，不可修改int *p = arr; //此时arr作为指针常量来使用printf("sizeof(arr):%d\n", sizeof(arr)); //此时sizeof结果为整个数组的长度printf("&amp;arr type is %s\n", typeid(&amp;arr).name()); //int(*)[10]而不是int* 下标引用： 1int arr[] = &#123; 1, 2, 3, 4, 5, 6 &#125;; *(arr + 3) ,这个表达式是什么意思呢？ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： 12*(arr + 3)arr[3] 问题 1：数组下标可否为负值？ 问题 2：请阅读如下代码，说出结果： 1234int arr[] = &#123; 5, 3, 6, 8, 2, 9 &#125;;int *p = arr + 2;printf("*p = %d\n", *p); // 6printf("*p = %d\n", p[-1]); // 3 5.1.1 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明 12int a[10];int *b; 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 因此，表达式 *a 是完全合法的，但是表达式 *b 却是非法的。*b 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。 5.1.2 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： 12int print_array(int *arr);int print_array(int arr[]); 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 5.2 多维数组数组名： 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： 1int arr[3][10] 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 指向数组的指针(数组指针)： 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：int array[5] 的类型为 int[5]；C语言可通过typedef定义一个数组类型： 定义数组指针有一下三种方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方式一void test01()&#123; //先定义数组类型，再用数组类型定义数组指针 int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = &amp;arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i &lt; 10;i++)&#123; printf("%d ",(*pArr)[i]); &#125; printf("\n");&#125;//方式二void test02()&#123; int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = &amp;arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i &lt; 10; i++)&#123; (*pArr)[i] = i + 1; &#125; for (int i = 0; i &lt; 10; i++)&#123; printf("%d ", (*pArr)[i]); &#125; printf("\n");&#125;//方式三void test03()&#123; int arr[10]; int(*pArr)[10] = &amp;arr; for (int i = 0; i &lt; 10; i++)&#123; (*pArr)[i] = i + 1; &#125; for (int i = 0; i &lt; 10; i++)&#123; printf("%d ", (*pArr)[i]); &#125; printf("\n");&#125; 5.2.1 指针数组(元素为指针)栈区指针数组： 123456789101112131415161718192021222324252627282930313233343536//数组做函数函数，退化为指针void array_sort(char** arr,int len)&#123; for (int i = 0; i &lt; len; i++)&#123; for (int j = len - 1; j &gt; i; j --)&#123; //比较两个字符串 if (strcmp(arr[j-1],arr[j]) &gt; 0)&#123; char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125;&#125;//打印数组void array_print(char** arr,int len)&#123; for (int i = 0; i &lt; len;i++)&#123; printf("%s\n",arr[i]); &#125; printf("----------------------\n");&#125;void test()&#123; //主调函数分配内存 //指针数组 char* p[] = &#123; "bbb", "aaa", "ccc", "eee", "ddd"&#125;; //char** p = &#123; "aaa", "bbb", "ccc", "ddd", "eee" &#125;; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len);&#125; 堆区指针数组： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//分配内存char** allocate_memory(int n)&#123; if (n &lt; 0 )&#123; return NULL; &#125; char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL)&#123; return NULL; &#125; //分别给每一个指针malloc分配内存 for (int i = 0; i &lt; n; i ++)&#123; temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], "%2d_hello world!", i + 1); &#125; return temp;&#125;//打印数组void array_print(char** arr,int len)&#123; for (int i = 0; i &lt; len;i++)&#123; printf("%s\n",arr[i]); &#125; printf("----------------------\n");&#125;//释放内存void free_memory(char** buf,int len)&#123; if (buf == NULL)&#123; return; &#125; for (int i = 0; i &lt; len; i ++)&#123; free(buf[i]); buf[i] = NULL; &#125; free(buf);&#125;void test()&#123; int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n);&#125; 二维数组的线性存储特性式： 1234567891011121314151617181920212223242526272829void PrintArray(int* arr, int len)&#123; for (int i = 0; i &lt; len; i++)&#123; printf("%d ", arr[i]); &#125; printf("\n");&#125;//二维数组的线性存储void test()&#123; int arr[][3] = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;; int arr2[][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i &lt; len; i++)&#123; printf("%d ", p[i]); &#125; printf("\n"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len);&#125; 二维数组的3种形式参数： 1234567891011121314151617181920212223242526272829303132333435363738//二维数组的第一种形式void PrintArray01(int arr[3][3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf("arr[%d][%d]:%d\n", i, j, arr[i][j]); &#125; &#125;&#125;//二维数组的第二种形式void PrintArray02(int arr[][3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf("arr[%d][%d]:%d\n", i, j, arr[i][j]); &#125; &#125;&#125;//二维数组的第二种形式void PrintArray03(int(*arr)[3])&#123; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; printf("arr[%d][%d]:%d\n", i, j, arr[i][j]); &#125; &#125;&#125;void test()&#123; int arr[][3] = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr);&#125; 5.3 总结编程提示： 源代码的可读性几乎总是比程序的运行时效率更为重要 只要有可能，函数的指针形参都应该声明为const 在多维数组的初始值列表中使用完整的多层花括号提供可读性 内容总结： 在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。这个规则只有两个例外，sizeof和对数组名&amp;。 指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。 当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。 我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。 六、结构体6.1 结构体基础知识结构体类型的定义 123456789struct Person&#123; char name[64]; int age;&#125;;typedef struct _PERSON&#123; char name[64]; int age;&#125;Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 结构体变量的定义 1234567891011struct Person&#123; char name[64]; int age;&#125;p1; //定义类型同时定义变量struct&#123; char name[64]; int age;&#125;p2; //定义类型同时定义变量struct Person p3; //通过类型直接定义 结构体成员的使用 12345678910111213141516171819struct Person&#123; char name[64]; int age;&#125;;void test()&#123; //在栈上分配空间 struct Person p1; strcpy(p1.name, "John"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf("Name:%s Age:%d\n", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-&gt;name, "Obama"); p2-&gt;age = 33; //如果是指针变量，通过-&gt;操作结构体成员 printf("Name:%s Age:%d\n", p2-&gt;name, p2-&gt;age);&#125; 深拷贝和浅拷贝 1234567891011121314151617181920212223242526//一个老师有N个学生typedef struct _TEACHER&#123; char* name;&#125;Teacher;void test()&#123; Teacher t1; t1.name = malloc(64); strcpy(t1.name , "John"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL)&#123; free(t1.name); t1.name = NULL; &#125; if (t2.name != NULL)&#123; free(t2.name); t1.name = NULL; &#125;&#125; 结构体数组 1234567891011121314151617181920212223242526272829303132struct Person&#123; char name[64]; int age;&#125;;void test()&#123; //在栈上分配空间 struct Person p1[3] = &#123; &#123; "John", 30 &#125;, &#123; "Obama", 33 &#125;, &#123; "Edward", 25&#125; &#125;; struct Person p2[3] = &#123; "John", 30, "Obama", 33, "Edward", 25 &#125;; for (int i = 0; i &lt; 3;i ++)&#123; printf("Name:%s Age:%d\n",p1[i].name,p1[i].age); &#125; printf("-----------------\n"); for (int i = 0; i &lt; 3; i++)&#123; printf("Name:%s Age:%d\n", p2[i].name, p2[i].age); &#125; printf("-----------------\n"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i &lt; 3;i++)&#123; sprintf(p3[i].name, "Name_%d", i + 1); p3[i].age = 20 + i; &#125; for (int i = 0; i &lt; 3; i++)&#123; printf("Name:%s Age:%d\n", p3[i].name, p3[i].age); &#125;&#125; 6.2 结构体嵌套指针结构体嵌套一级指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Person&#123; char* name; int age;&#125;;void allocate_memory(struct Person** person)&#123; if (person == NULL)&#123; return; &#125; struct Person* temp = (struct Person*)malloc(sizeof(struct Person)); if (temp == NULL)&#123; return; &#125; //给name指针分配内存 temp-&gt;name = (char*)malloc(sizeof(char)* 64); strcpy(temp-&gt;name, "John"); temp-&gt;age = 100; *person = temp;&#125;void print_person(struct Person* person)&#123; printf("Name:%s Age:%d\n",person-&gt;name,person-&gt;age);&#125;void free_memory(struct Person** person)&#123; if (person == NULL)&#123; return; &#125; struct Person* temp = *person; if (temp-&gt;name != NULL)&#123; free(temp-&gt;name); temp-&gt;name = NULL; &#125; free(temp);&#125;void test()&#123; struct Person *p = NULL; allocate_memory(&amp;p); print_person(p); free_memory(&amp;p);&#125; 结构体嵌套二级指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//一个老师有N个学生typedef struct _TEACHER&#123; char name[64]; char** students;&#125;Teacher;void create_teacher(Teacher** teacher,int n,int m)&#123; if (teacher == NULL)&#123; return; &#125; //创建老师数组 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n); if (teachers == NULL)&#123; return; &#125; //给每一个老师分配学生 int num = 0; for (int i = 0; i &lt; n; i ++)&#123; sprintf(teachers[i].name, "老师_%d", i + 1); teachers[i].students = (char**)malloc(sizeof(char*) * m); for (int j = 0; j &lt; m;j++)&#123; teachers[i].students[j] = malloc(64); sprintf(teachers[i].students[j], "学生_%d", num + 1); num++; &#125; &#125; *teacher = teachers; &#125;void print_teacher(Teacher* teacher,int n,int m)&#123; for (int i = 0; i &lt; n; i ++)&#123; printf("%s:\n", teacher[i].name); for (int j = 0; j &lt; m;j++)&#123; printf(" %s",teacher[i].students[j]); &#125; printf("\n"); &#125;&#125;void free_memory(Teacher** teacher,int n,int m)&#123; if (teacher == NULL)&#123; return; &#125; Teacher* temp = *teacher; for (int i = 0; i &lt; n; i ++)&#123; for (int j = 0; j &lt; m;j ++)&#123; free(temp[i].students[j]); temp[i].students[j] = NULL; &#125; free(temp[i].students); temp[i].students = NULL; &#125; free(temp);&#125;void test()&#123; Teacher* p = NULL; create_teacher(&amp;p,2,3); print_teacher(p, 2, 3); free_memory(&amp;p,2,3);&#125; 6.3 结构体成员偏移量123456789101112131415161718192021//一旦结构体定义下来，则结构体中的成员内存布局就定下了typedef struct Teacher &#123; char a; int b; int c; &#125; Teacher;void test()&#123; Teacher t1; Teacher*p = NULL; p = &amp;t1; int offsize1 = (int)&amp;(p-&gt;b) - (int)p; //age 相对于结构体 Teacher的偏移量 int offsize2 = (int)&amp;(((Teacher *)0)-&gt;b);//绝对0地址 age的偏移量 int offsize3 = offsetof(Teacher, b); printf("offsize1:%d \n", offsize1); printf("offsize2:%d \n", offsize2); printf("offsize3:%d \n", offsize3);&#125; 6.4 结构体字节对齐在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。 6.4.1 内存对齐原因我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。 为什么要简单内存对齐？ 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。 某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。 6.4.2 如何内存对齐 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为min（当前成员的大小，#pargama pack(n)）整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 结构体总的大小，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，不足要补齐。 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(push) 将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。 #pragma pack(pop) 从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 内存对齐案例 123456789101112131415161718192021222324252627282930#pragma pack(4)typedef struct _STUDENT&#123; int a; char b; double c; float d;&#125;Student;typedef struct _STUDENT2&#123; char a; Student b; double c;&#125;Student2;void test01()&#123; //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf("sizeof Student:%d\n",sizeof(Student)); //Student2 //a从偏移量为0位置开始 8 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf("sizeof Student2:%d\n", sizeof(Student2));&#125; 七、文件操作文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。 文件的概念 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 流的概念 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 文本流 文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。 标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。 二进制流 二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。 c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上。 比如说，在widows下，文件的换行符是 \r\n，而在Linux下换行符则是 \n. 当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n, 所以文本文件方式和二进制方式无区别。 7.1 文件的操作文件流总览 标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。 程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 FILE*。这个指针指向这个FILE结构，当它处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 输入/输出函数家族 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 7.2 文件打开关闭文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 12345678FILE * fopen(const char * filename, const char * mode);功能：打开文件参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab” 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 12345678910111213141516void test()&#123; FILE *fp = NULL; // "\\"这样的路径形式，只能在windows使用 // "/"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen("../test", "w"); //fp = fopen("..\\test", "w"); if (fp == NULL) //返回空，说明打开失败 &#123; //perror()是标准出错打印函数，能打印调用库函数出错原因 perror("open"); return -1; &#125;&#125; 注意：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 1234567int fclose(FILE * stream);功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。参数： stream：文件指针返回值： 成功：0 失败：-1 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 文件读写函数回顾 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() 块读写函数回顾 123456789101112131415161718192021size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式给文件写入内容参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功写入文件数据的块数，此值和nmemb相等 失败：0size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式从文件中读取内容参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 格式化读写函数回顾 1234567891011121314151617int fprintf(FILE * stream, const char * format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\0' 为止。参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样返回值： 成功：实际写入文件的字符个数 失败：-1int fscanf(FILE * stream, const char * format, ...);功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样返回值： 成功：实际从文件中读取的字符个数 失败： - 1 注意：fscanf遇到空格和换行时结束。 7.3 读写配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122struct info&#123; char key[64]; char val[128];&#125;;struct config&#123; FILE *fp; //保存文件指针 struct info *list; //保存配置信息 int lines; //配置信息条数&#125;;//加载配置文件int load_file(char *path, struct config **myconfig)&#123; if (NULL == path)&#123; return -1; &#125; //以读写的方式打开文件 FILE *fp = fopen(path, "r+"); if (NULL ==fp)&#123; printf("文件打开失败!\n"); return -2; &#125; //配置文件信息分配内存 struct config *conf = (struct config *)malloc(sizeof(struct config)); conf-&gt;fp = fp; conf-&gt;list = NULL; //指针的间接赋值 *myconfig = conf; return 0;&#125;//统计文件行数int count_file(struct config *config)&#123; if (NULL == config)&#123; return -1; &#125; char buf[1024] = &#123; 0 &#125;; int lines = 0; while (fgets(buf, 1024, config-&gt;fp))&#123; //如果是注释则不统计 if (buf[0] == '#')&#123; continue; &#125; lines++; &#125; //将文件指针重置到开始位置 fseek(config-&gt;fp,0, SEEK_SET); return lines;&#125;//解析配置文件int parse_file(struct config *config)&#123; if (NULL == config)&#123; return -1; &#125; //获得配置文件行数 config-&gt;lines = count_file(config); //给每一行配置信息分配内存 config-&gt;list = (struct info *)malloc(sizeof(struct info) * config-&gt;lines); int index = 0; char buf[1024] = &#123; 0 &#125;; while (fgets(buf, 1024, config-&gt;fp))&#123; //去除每一行最后的\n字符 buf[strlen(buf) - 1] = '\0'; //如果是注释则不显示 if (buf[0] == '#')&#123; continue; &#125; memset(config-&gt;list[index].key, 0, 64); memset(config-&gt;list[index].val, 0, 128); char *delimit = strchr(buf, ':'); strncpy(config-&gt;list[index].key, buf, delimit - buf); strncpy(config-&gt;list[index].val, delimit + 1, strlen(delimit + 1)); memset(buf, 0 , 1024); index++; &#125; return 0;&#125;const char *get_file(struct config *config, char *key)&#123; if (NULL == config)&#123; return NULL; &#125; if (NULL == key)&#123; return NULL; &#125; for (int i = 0; i &lt; config-&gt;lines;i ++)&#123; if (strcmp(config-&gt;list[i].key,key) == 0)&#123; return config-&gt;list[i].val; &#125; &#125; return NULL;&#125;void destroy_file(struct config *config)&#123; if (NULL == config)&#123; return; &#125; //关闭文件指针 fclose(config-&gt;fp); config-&gt;fp = NULL; //释放配置信息 free(config-&gt;list); config-&gt;list = NULL; free(config);&#125;void test()&#123; char *path = "./my.ini"; struct config *conf = NULL; load_file(path, &amp;conf); parse_file(conf); printf("%s\n", get_file(conf, "username")); printf("%s\n", get_file(conf, "password")); printf("%s\n", get_file(conf, "server_ip")); printf("%s\n", get_file(conf, "server_port")); printf("%s\n", get_file(conf, "aaaa")); destroy_file(conf);&#125; 八、链表8.1 链表基本概念 链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（非顺序存储）。 数据域用来存储数据，指针域用于建立与下一个结点的联系。 建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。 链表的开销，主要是访问顺序性和组织链的空间损失。 数组和链表的区别： 数组：一次性分配一块连续的存储区域。 优点：随机访问元素效率高 缺点： 需要分配一块连续的存储区域（很大区域，有可能分配失败） 删除和插入某个元素效率低 链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。 优点： 不需要一块连续的存储区域 删除和插入某个元素效率高 缺点：随机访问元素效率低 8.1.1 有关结构体的自身引用问题1：请问结构体可以嵌套本类型的结构体变量吗？ 问题2：请问结构体可以嵌套本类型的结构体指针变量吗？ 123456789101112typedef struct _STUDENT&#123; char name[64]; int age;&#125;Student;typedef struct _TEACHER&#123; char name[64]; Student stu; //结构体可以嵌套其他类型的结构体 //Teacher stu; //struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存 struct _TEACHER* teacher; //不论什么类型的指针，都只占4个字节，编译器可确定内存分配&#125;Teacher; 结构体可以嵌套另外一个结构体的任何类型变量; 结构体嵌套本结构体普通变量（不可以）。本结构体的类型大小无法确定，类型本质：固定大小内存块别名; 结构体嵌套本结构体指针变量（可以）, 指针变量的空间能确定，32位， 4字节， 64位， 8字节; 8.1.2 链表节点大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？ 链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域： 数据域用来存储数据； 指针域用于建立与下一个结点的联系，当此节点为尾节点时，指针域的值为NULL； 123456789typedef struct Node &#123; //数据域 int id; char name[50]; //指针域 struct Node *next; &#125;Node; 8.1.3 链表的分类链表分为： 静态链表 动态链表 静态链表和动态链表是线性表链式存储结构的两种不同的表示方式： 所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。 所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。 静态链表 123456789101112131415161718192021222324typedef struct Stu &#123; int id; //数据域 char name[100]; struct Stu *next; //指针域&#125;Stu;void test() &#123; //初始化三个结构体变量 Stu s1 = &#123; 1, "yuri", NULL &#125;; Stu s2 = &#123; 2, "lily", NULL &#125;; Stu s3 = &#123; 3, "lilei", NULL &#125;; s1.next = &amp;s2; //s1的next指针指向s2 s2.next = &amp;s3; s3.next = NULL; //尾结点 Stu *p = &amp;s1; while (p != NULL) &#123; printf("id = %d, name = %s\n", p-&gt;id, p-&gt;name); //结点往后移动一位 p = p-&gt;next; &#125;&#125; 动态链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct Stu &#123; int id; //数据域 char name[100]; struct Stu *next; //指针域&#125;Stu;void test() &#123; //动态分配3个节点 Stu *s1 = (Stu *)malloc(sizeof(Stu)); s1-&gt;id = 1; strcpy(s1-&gt;name, "yuri"); Stu *s2 = (Stu *)malloc(sizeof(Stu)); s2-&gt;id = 2; strcpy(s2-&gt;name, "lily"); Stu *s3 = (Stu *)malloc(sizeof(Stu)); s3-&gt;id = 3; strcpy(s3-&gt;name, "lilei"); //建立节点的关系 s1-&gt;next = s2; //s1的next指针指向s2 s2-&gt;next = s3; s3-&gt;next = NULL; //尾结点 //遍历节点 Stu *p = s1; while (p != NULL)&#123; printf("id = %d, name = %s\n", p-&gt;id, p-&gt;name); //结点往后移动一位 p = p-&gt;next; &#125; //释放节点空间 p = s1; Stu *tmp = NULL; while (p != NULL) &#123; tmp = p; p = p-&gt;next; free(tmp); tmp = NULL; &#125;&#125; 带头和不带头链表 带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。 不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。 单向链表、双向链表、循环链表 单向链表： 双向链表： 循环链表： 8.2 链表基本操作8.2.1 创建链表使用结构体定义节点类型： 12345typedef struct _LINKNODE&#123; int id; //数据域 struct _LINKNODE *next; //指针域&#125;link_node; 编写函数：link_node* init_linklist() 建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回. 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _LINKNODE&#123; int data; struct _LINKNODE *next;&#125;link_node;link_node *init_linklist()&#123; //创建头结点指针 link_node* head = NULL; //给头结点分配内存 head = (link_node*)malloc(sizeof(link_node)); if (head == NULL)&#123; return NULL; &#125; head-&gt;data = -1; head-&gt;next = NULL; //保存当前节点 link_node* p_current = head; int data = -1; //循环向链表中插入节点 while (1)&#123; printf("please input data:\n"); scanf("%d",&amp;data); //如果输入-1，则退出循环 if (data == -1)&#123; break; &#125; //给新节点分配内存 link_node* newnode = (link_node*)malloc(sizeof(link_node)); if (newnode == NULL)&#123; break; &#125; //给节点赋值 newnode-&gt;data = data; newnode-&gt;next = NULL; //新节点入链表，也就是将节点插入到最后一个节点的下一个位置 p_current-&gt;next = newnode; //更新辅助指针p_current p_current = newnode; &#125; return head;&#125; 8.2.2 遍历链表编写函数：void foreach_linklist(link_node* head) 顺序输出单向链表各项结点数据域中的内容： 12345678910111213//遍历链表void foreach_linklist(link_node* head)&#123; if (head == NULL)&#123; return; &#125; //赋值指针变量 link_node* p_current = head-&gt;next; while (p_current != NULL)&#123; printf("%d ",p_current-&gt;data); p_current = p_current-&gt;next; &#125; printf("\n");&#125; 8.2.3 插入节点编写函数: void insert_linklist(link_node* head,int val,int data). 在指定值后面插入数据data,如果值val不存在，则在尾部插入。 1234567891011121314151617181920212223242526272829//在值val前插入节点void insert_linklist(link_node* head, int val, int data)&#123; if (head == NULL)&#123; return; &#125; //两个辅助指针 link_node* p_prev = head; link_node* p_current = p_prev-&gt;next; while (p_current != NULL)&#123; if (p_current-&gt;data == val)&#123; break; &#125; p_prev = p_current; p_current = p_prev-&gt;next; &#125; //如果p_current为NULL，说明不存在值为val的节点 if (p_current == NULL)&#123; printf("不存在值为%d的节点!\n",val); return; &#125; //创建新的节点 link_node* newnode = (link_node*)malloc(sizeof(link_node)); newnode-&gt;data = data; newnode-&gt;next = NULL; //新节点入链表 newnode-&gt;next = p_current; p_prev-&gt;next = newnode;&#125; 8.2.4 删除节点编写函数: void remove_linklist(link_node* head,int val) 删除第一个值为val的结点. 12345678910111213141516171819202122232425262728//删除值为val的节点void remove_linklist(link_node* head,int val)&#123; if (head == NULL)&#123; return; &#125; //辅助指针 link_node* p_prev = head; link_node* p_current = p_prev-&gt;next; //查找值为val的节点 while (p_current != NULL)&#123; if (p_current-&gt;data == val)&#123; break; &#125; p_prev = p_current; p_current = p_prev-&gt;next; &#125; //如果p_current为NULL，表示没有找到 if (p_current == NULL)&#123; return; &#125; //删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系 p_prev-&gt;next = p_current-&gt;next; //释放待删除节点的内存 free(p_current);&#125; 8.2.5 销毁链表编写函数: void destroy_linklist(link_node* head) 销毁链表，释放所有节点的空间. 1234567891011121314//销毁链表void destroy_linklist(link_node* head)&#123; if (head == NULL)&#123; return; &#125; //赋值指针 link_node* p_current = head; while (p_current != NULL)&#123; //缓存当前节点下一个节点 link_node* p_next = p_current-&gt;next; free(p_current); p_current = p_next; &#125;&#125; 九、函数指针9.1 函数类型通过什么来区分两个不同的函数？ 一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。 函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。 c 语言中通过 typedef 为函数类型重命名： 12typedef int f(int, int); // f 为函数类型typedef void p(int); // p 为函数类型 这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。 注意：通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。 123456789101112typedef int(p)(int, int);void my_func(int a,int b)&#123; printf("%d %d\n",a,b);&#125;void test()&#123; p p1; //p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用 p* p2 = my_func; p2(10,20); //正确，指向有函数体的函数入口地址&#125; 9.2 函数指针(指向函数的指针) 函数指针定义方式(先定义函数类型，根据类型定义指针变量); 先定义函数指针类型，根据类型定义指针变量; 直接定义函数指针变量; 123456789101112131415161718192021222324252627282930int my_func(int a,int b)&#123; printf("ret:%d\n", a + b); return 0;&#125;//1. 先定义函数类型，通过类型定义指针void test01()&#123; typedef int(FUNC_TYPE)(int, int); FUNC_TYPE* f = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125;//2. 定义函数指针类型void test02()&#123; typedef int(*FUNC_POINTER)(int, int); FUNC_POINTER f = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125;//3. 直接定义函数指针变量void test03()&#123; int(*f)(int, int) = my_func; //如何调用？ (*f)(10, 20); f(10, 20);&#125; 9.3 函数指针数组函数指针数组，每个元素都是函数指针。 1234567891011121314151617181920212223242526void func01(int a)&#123; printf("func01:%d\n",a);&#125;void func02(int a)&#123; printf("func02:%d\n", a);&#125;void func03(int a)&#123; printf("func03:%d\n", a);&#125;void test()&#123;#if 0 //定义函数指针 void(*func_array[])(int) = &#123; func01, func02, func03 &#125;;#else void(*func_array[3])(int); func_array[0] = func01; func_array[1] = func02; func_array[2] = func03;#endif for (int i = 0; i &lt; 3; i ++)&#123; func_array[i](10 + i); (*func_array[i])(10 + i); &#125;&#125; 9.4 函数指针做函数参数(回调函数)函数参数除了是普通变量，还可以是函数指针变量。 1234//形参为普通变量void fun( int x )&#123;&#125;//形参为函数指针变量void fun( int(*p)(int a) )&#123;&#125; 函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。 123456789101112131415161718192021//加法计算器int plus(int a,int b)&#123; return a + b;&#125;//减法计算器int minus(int a,int b)&#123; return a - b;&#125;//计算器#if 0int caculator(int a,int b,int(*func)(int,int))&#123; return func(a, b);&#125;#elsetypedef int(*FUNC_POINTER)(int, int);int caculator(int a, int b, FUNC_POINTER func)&#123; return func(a, b);&#125;#endif 注意：函数指针和指针函数的区别： 函数指针是指向函数的指针； 指针函数是返回类型为指针的函数； 十、预处理10.1 预处理的基本概念C 语言对源程序处理的四个步骤：预处理、编译、汇编、链接。 预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。 10.2 文件包含指令(#include)“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。 #incude&lt;&gt; 和 #include”” 区别 “” 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。 &lt; &gt; 表示系统直接按系统指定的目录检索。 注意： ​ 1. #include &lt;&gt; 常用于包含库函数的头文件； ​ 2. #include “” 常用于包含自定义的头文件； ​ 3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含； 10.3 宏定义10.3.1 无参数的宏定义(宏常量)如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为： const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用： #define num 100 在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。宏定义，只在宏定义的文件中起作用。 123456#define PI 3.1415void test()&#123; double r = 10.0; double s = PI * r * r; printf("s = %lf\n", s);&#125; 说明： 1)宏名一般用大写，以便于与变量区别； 2) 宏定义可以是常数、表达式等； 3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错； 4) 宏定义不是C语言，不在行末加分号； 5) 宏名有效范围为从定义到本源文件结束； 6) 可以用#undef命令终止宏定义的作用域； 7) 在宏定义中，可以引用已定义的宏名； 10.3.2 带参数的宏定义(宏函数)在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。 宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。 1234567#define SUM(x,y) ((x)+(y))void test()&#123; //仅仅只是做文本替换 下例替换为 int ret = ((10)+(20)); //不进行计算 int ret = SUM(10, 20); printf("ret:%d\n",ret);&#125; 注意: 1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格； 2) 用括号括住每一个参数，并括住宏的整体定义。 3) 用大写字母表示宏的函数名。 4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。 10.4 条件编译一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。 条件编译 防止头文件被重复包含引用； 12345678#ifndef _SOMEFILE_H#define _SOMEFILE_H//需要声明的变量、函数//宏定义//结构体#endif 10.5 一些特殊的预定宏C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。 123456789101112// __FILE__ 宏所在文件的源文件名 // __LINE__ 宏所在行的行号// __DATE__ 代码编译的日期// __TIME__ 代码编译的时间void test()&#123; printf("%s\n", __FILE__); printf("%d\n", __LINE__); printf("%s\n", __DATE__); printf("%s\n", __TIME__);&#125; 十一、动态库的封装和使用11.1 库的基本概念库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。 在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。 库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。 库：就是已经编写好的，后续可以直接使用的代码。 c++静态库：会合入到最终生成的程序，使得结果文件比较大。优点是不再有任何依赖。 c++动态库：动态库，一个文件可以多个代码同时使用内存中只有一份，节省内存，可以随主代码一起编译。缺点是需要头文件。 网友说：库就是除了main函数之外的其他代码，都可以组成库。 11.2 静态库优缺点 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系； 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 内存和磁盘空间 静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。 程序开发和发布 空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。 要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。 11.3 Linux 下 gcc 编译器生成和使用静态库和动态库我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。 静态库在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库。 动态库在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。 windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。 11.3.1 基本概念库的种类： linux下的库有两种： 静态库 共享库（动态库）。 二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。 库文件是如何产生的： 静态库的后缀是 .a，它的产生分两步: Step 1. 由源文件编译生成一堆 .o，每个 .o 里都包含这个编译单元的符号表 Step 2. ar 命令将很多 .o 转换成 .a，成为静态库 动态库的后缀是 .so，它由 gcc 加特定参数编译产生。 库文件命名规范： 库文件一般放在 /usr/local/lib，/usr/lib，/lib，或者其他自定义的 lib 下。 静态库的名字一般为 libxxxx.a，其中 xxxx 是该 lib 的名称 动态库的名字一般为 libxxxx.so.major.minor， xxxx 是该 lib 的名称，major 是主版本号， minor 是副版本号 如何知道一个可执行程序依赖哪些库： ldd 命令可以查看一个可执行程序依赖的共享库，例如： 123$ ldd /lib/i386-linux-gnu/libc.so.6/lib/ld-linux.so.2 (0xf7740000)linux-gate.so.1 =&gt; (0xf773f000) 可以看到 libc 命令依赖于 linux-gate 库和 ld-linux 库 可执行程序在执行的时候如何定位共享库文件： 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader) 对于 elf 格式的可执行程序，是由 ld-linux.so* 来完成的，它先后搜索 elf 文件的 DT_RPATH 段—环境变量 LD_LIBRARY_PATH—/etc/ld.so.cache 文件列表— /lib/,/usr/lib 目录找到库文件后将其载入内存 如：export LD_LIBRARY_PATH=’pwd’ 将当前文件目录添加为共享目录 在新安装一个库之后如何让系统能够找到他： 如果安装在 /lib 或者 /usr/lib 下，那么 ld 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 /etc/ld.so.cache 文件中，步骤如下： 编辑 /etc/ld.so.conf 文件，加入库文件所在目录的路径 运行 ldconfig，该命令会重建 /etc/ld.so.cache 文件 11.3.2 用 gcc 生成静态和动态链接库的示例假设有1个类 hello，和一个 main 函数。如下： hello.h 123456#ifndef HELLO_H #define HELLO_H void hello(const char *name); #endif hello.c 1234#include &lt;stdio.h&gt; void hello(const char *name) &#123; printf("Hello %s!\n", name);&#125; main.c 123456#include "hello.h" int main() &#123; hello("world!"); return 0; &#125; hello.c 是一个没有 main 函数的 .c 程序，因此不够成一个完整的程序，如果使用 gcc –o 编译并连接它，gcc 将报错，无法通过编译。 前面提过，无论静态库，还是动态库，都是由 .o文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 .o 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现： 1）通过编译多个源文件，直接将目标代码合成一个 .o 文件。 2）通过创建静态链接库 libmyhello.a，使得 main 函数调用 hello 函数时可调用静态链接库。 3）通过创建动态链接库 libmyhello.so，使得 main 函数调用 hello 函数时可调用动态链接库。 11.3.2.1 途径一：编译多个源文件执行命令： 12$ gcc -c hello.c$ gcc -c main.c 这里提醒一下：gcc –o 是将 .c 源文件编译成为一个可执行的二进制代码。而 gcc –c 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点这里。 这时可以看到生成了 hello.o 和 main.o 文件。 12345678910111213$ lshello.c hello.h hello.o main.c main.o# 将两个文件链接成一个 `.o` 文件：$ gcc -o sayhello main.o hello.o# 查看此时已经生成了可执行文件sayhello$ lshello.c hello.h hello.o main.c main.o sayhello# 运行$ ./sayhelloHello world!! 11.3.2.2 途径二：静态链接库静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 .a。例如：我们将创建的静态库名为myhello，则静态库文件名就是 libmyhello.a 。创建静态库用 ar 命令。 删除途径一中生成的3个文件，回到原始的三个文件： 1234567891011$ rm hello.o main.o sayhello$ lshello.c hello.h main.c# 开始尝试途径二，创建静态库文件libmyhello.a：$ gcc -c hello.c$ ar rcs libmyhello.a hello.o# 查看一下已经生成了：$ lshello.c hello.h hello.o libmyhello.a main.c 静态库制作完了，如何使用它内部的函数呢？ 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中。 注意，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 .a 得到的静态库文件名来查找静态库文件。 因此，我们在写需要连接的库时，只写静态库名就可以，如 libmyhello.a 的库，只写: -lmyhello在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数： 123456789# 这里-L.告诉 gcc 先在当前目录下查找库文件。$ gcc -o sayhello main.c -static -L. -lmyhello # 查看一下，已经生成可执行文件sayhello$ lshello.c hello.h hello.o libmyhello.a main.c sayhello$ ./sayhelloHello world!! 前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。 1234$ rm libmyhello.a$ ./sayhelloHello world!! 程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。 静态链接库的一个缺点是： 如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。 使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 /usr/lib/libm.so。当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响。 11.3.2.3 途径三：动态链接库（共享函数库）动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 .so。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 libmyhello.so 。用 gcc 来创建动态库。 删除途径二中生成的2个文件，回到原始的三个文件： 1234567891011121314$ rm hello.o sayhello$ lshello.c hello.h main.c# 开始尝试途径三，创建静态库文件libmyhello.so：# 按教程里，会报错：$ gcc -c hello.c$ lshello.c hello.h hello.o main.c$ gcc -shared -fPIC -o libmyhello.so hello.o/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIChello.o: could not read symbols: Bad valuecollect2: ld returned 1 exit status 正确方法是，这样就可以了： 12345$ gcc -fPIC -shared -o libmyhello.so hello.c# 已生成libmyhello.so，是绿色。$ lshello.c hello.h libmyhello.so main.c 最主要的是 GCC 命令行的选项: -shared：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件 -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。 下面调用该动态链接库： 1234567$ gcc -o sayhello main.c -L. -lmyhello$ lshello.c hello.h libmyhello.so main.c sayhello$ ./sayhelloHello world!!成功！ 按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 libmyhello.so： 1./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory 程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法： （1）我们将文件 libmyhello.so复制到目录/usr/lib中。 （2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量： export LD_LIBRARY_PATH=$(pwd) （3）执行： ldconfig /usr/zhsoft/lib 说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 /etc/ld.so.cache 中追加进指定目录下的共享库。该命令会重建 /etc/ld.so.cache 文件。 参考教程： http://blog.csdn.net/jiayouxjh/article/details/7602729 http://blog.sina.com.cn/s/blog_54f82cc20101153x.html http://navyaijm.blog.51cto.com/4647068/809424 十二、递归函数12.1 递归函数基本概念C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。 12.2 普通函数调用1234567891011121314void funB(int b)&#123; printf("b = %d\n", b);&#125;void funA(int a)&#123; funB(a - 1); printf("a = %d\n", a);&#125;int main(void)&#123; funA(2); printf("main\n"); return 0;&#125; 函数的调用流程如下： 12.3 递归函数调用1234567891011121314void fun(int a)&#123; if (a == 1)&#123; printf("a = %d\n", a); return; //中断函数很重要 &#125; fun(a - 1); printf("a = %d\n", a);&#125;int main(void)&#123; fun(2); printf("main\n"); return 0;&#125; 函数的调用流程如下： 递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。 12345678void recursion(int val)&#123; if (val == 0)&#123; return; &#125; int ret = val / 10; recursion(ret); printf("%d ",val % 10);&#125; 12.4 递归实现字符串反转123456789101112131415161718192021222324252627282930313233343536373839404142int reverse1(char *str)&#123; if (str == NULL)&#123; return -1; &#125; if (*str == '\0') &#123; // 函数递归调用结束条件 return 0; &#125; reverse1(str + 1); printf("%c", *str); return 0;&#125;char buf[1024] = &#123; 0 &#125;; //全局变量int reverse2(char *str)&#123; if (str == NULL) &#123; return -1; &#125; if ( *str == '\0' ) &#123; // 函数递归调用结束条件 return 0; &#125; reverse2(str + 1); strncat(buf, str, 1); return 0;&#125;int reverse3(char *str, char *dst)&#123; if (str == NULL || dst == NULL) &#123; return -1; &#125; if (*str == '\0') &#123; // 函数递归调用结束条件 return 0; &#125; reverse3(str + 1); strncat(dst, str, 1); return 0;&#125; 12.5 递归实现链表逆序打印TODO 十三、面向接口编程13.1 案例背景一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。 13.2 案例需求要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。 13.3 案例要求 1）能支持多个厂商的 socket 通信产品入围 2）能支持多个第三方厂商加密产品的入围 3）企业信息系统框架不轻易发生框架 13.4 编程提示 1）抽象通信接口结构体设计（CSocketProtocol） 2）框架接口设计（framework） 3） a) 通信厂商1入围（CSckImp1） b) 通信厂商2入围（CSckImp2） 4） a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能） c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp) 5）框架接口分文件]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 基础]]></title>
    <url>%2F2016%2F05%2F10%2FProgram-C%2Fprogram-c%2F</url>
    <content type="text"><![CDATA[C 语言基础一、C 语言概述 二、数据类型 三、字符串处理和函数 声明变量不需要建立存储空间，如：extern int a; 定义变量需要建立存储空间，如：int b; 全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。 数字 0 (和字符 ‘\0’ 等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 gets(str)与scanf(“%s”,str)的区别： gets(str)允许输入的字符串含有空格 scanf(“%s”,str)不允许含有空格 注意：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。 gets() 、puts() 123456#include &lt;stdio.h&gt;char *gets(char *s);功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。int puts(const char *s);功能：标准设备输出s字符串，在输出完成后自动输出一个'\n'。 fgets() 、fputs() 12345678#include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream);功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过scanf和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。int fputs(const char * str, FILE * stream);功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 '\0' 不写入文件。fputs()是puts()的文件操作版本，但fputs()不会自动输出一个'\n'。 strlen() 、strcpy() 、strncpy() 、strcat() 、strncat() 、strcmp() 、strncmp() 、sprintf() 、sscanf() 、strchr() 、strstr() 、strtok() 、atoi() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;string.h&gt;size_t strlen(const char *s);功能：计算指定指定字符串s的长度，不包含字符串结束符‘\0’char *strcpy(char *dest, const char *src);功能：把src所指向的字符串复制到dest所指向的空间中，'\0'也会拷贝过去注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。char *strncpy(char *dest, const char *src, size_t n);功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含'\0'。char *strcat(char *dest, const char *src);功能：将src字符串连接到dest的尾部，‘\0’也会追加过去char *strncat(char *dest, const char *src, size_t n);功能：将src字符串前n个字符连接到dest的尾部，‘\0’也会追加过去int strcmp(const char *s1, const char *s2);功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。int strncmp(const char *s1, const char *s2, size_t n);功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。#include &lt;stdio.h&gt;int sprintf(char *_CRT_SECURE_NO_WARNINGS, const char *format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\0' 为止。#include &lt;stdio.h&gt;int sscanf(const char *str, const char *format, ...);功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。#include &lt;string.h&gt;char *strchr(const char *s, int c);功能：在字符串s中查找字母c出现的位置char *strstr(const char *haystack, const char *needle);功能：在字符串haystack中查找字符串needle出现的位置char *strtok(char *str, const char *delim);功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。#include &lt;stdlib.h&gt;int atoi(const char *nptr);功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符('\0')才结束转换，并将结果返回返回值。类似的函数有：- atof()：把一个小数形式的字符串转化为一个浮点数。- atol()：将一个字符串转化为long类型 形参列表 在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。 如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换。 注意：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。 当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 extern告诉编译器这个变量或函数在其他文档里已被定义了。 static法则： A、若全局变量仅在单个C文档中访问，则能够将这个变量修改为静态全局变量，以降低模块间的耦合度; B、若全局变量仅由单个函数访问，则能够将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题； 12// 多文件编译gcc -o 可执行程序 文件1.c 文件2.c 头文件.h 四、指针和指针变量 内存区的每一个字节都有一个编号，这就是“地址”。 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号) 指针的实质就是内存“地址”。指针就是地址，地址就是指针。 指针是内存单元的编号，指针变量是存放地址的变量。 通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。 指针也是一种数据类型，指针变量也是一种变量 指针变量指向谁，就把谁的地址赋值给指针变量 “*” 操作符操作的是指针变量指向的内存空间 指针大小 使用sizeof()测量指针的大小，得到的总是：4或8 sizeof()测的是指针变量指向存储地址的大小 在32位平台，所有的指针（地址）都是32位(4字节) 在64位平台，所有的指针（地址）都是64位(8字节) 野指针和空指针 指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。 但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。 NULL是一个值为0的宏常量：#define NULL ((void *)0) 万能指针 void * void * 指针可以指向任意变量的内存空间： 12345678void *p = NULL;int a = 10;p = (void *)&amp;a; //指向变量时，最好转换为void *//使用指针变量指向的内存时，转换为int **( (int *)p ) = 11;printf("a = %d\n", a); const修饰的指针变量 1234567891011121314int a = 100;int b = 200;//指向常量的指针//修饰*，指针指向内存区域不能修改，指针指向可以变const int *p1 = &amp;a; //等价于int const *p1 = &amp;a;//*p1 = 111; //errp1 = &amp;b; //ok//指针常量//修饰p1，指针指向不能变，指针指向的内存可以修改int * const p2 = &amp;a;//p2 = &amp;b; //err*p2 = 222; //ok 指针操作数组元素 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); for (i = 0; i &lt; n; i++) &#123; //printf("%d, ", a[i]); printf("%d, ", *(a+i)); &#125; printf("\n"); int *p = a; //定义一个指针变量保存a的地址 for (i = 0; i &lt; n; i++) &#123; p[i] = 2 * i; &#125; for (i = 0; i &lt; n; i++) &#123; printf("%d, ", *(p + i)); &#125; printf("\n"); return 0;&#125; 指针加减运算 指针计算不是简单的整数相加 如果是一个int *，+1的结果是增加一个int的大小 如果是一个char *，+1的结果是增加一个char大小 通过改变指针指向操作数组元素： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int i = 0; int n = sizeof(a) / sizeof(a[0]); int *p = a; for (i = 0; i &lt; n; i++) &#123; printf("%d, ", *p); p++; &#125; printf("\n"); return 0;&#125; 指针数组 指针数组，它是数组，数组的每个元素都是指针类型。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; //指针数组 int *p[3]; int a = 1; int b = 2; int c = 3; int i = 0; p[0] = &amp;a; p[1] = &amp;b; p[2] = &amp;c; for (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++ ) &#123; printf("%d, ", *(p[i])); &#125; printf("\n"); return 0;&#125; 多级指针 C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。 二级指针就是指向一个一级指针变量地址的指针。 三级指针基本用不着，但考试会考。 123456789101112int a = 10;int *p = &amp;a; //一级指针*p = 100; //*p就是aint **q = &amp;p;//*q就是p//**q就是aint ***t = &amp;q;//*t就是q//**t就是p//***t就是a 数组名做函数参数 数组名做函数参数，函数的形参会退化为指针： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;//void printArrary(int a[10], int n)//void printArrary(int a[], int n)void printArrary(int *a, int n)&#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; printf("%d, ", a[i]); &#125; printf("\n");&#125;int main()&#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int n = sizeof(a) / sizeof(a[0]); //数组名做函数参数 printArrary(a, n); return 0;&#125; 指针做为函数的返回值 12345678910111213141516#include &lt;stdio.h&gt;int a = 10;int *getA()&#123; return &amp;a;&#125;int main()&#123; *( getA() ) = 111; printf("a = %d\n", a); return 0;&#125; 指针和字符串 字符指针 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; char str[] = "hello world"; char *p = str; *p = 'm'; p++; *p = 'i'; printf("%s\n", str); // millo world p = "mike jiang"; printf("%s\n", p); // mike jiang char *q = "test"; printf("%s\n", q); // test return 0;&#125; const修饰的指针变量 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; //const修饰一个变量为只读 const int a = 10; //a = 100; //err //指针变量， 指针指向的内存， 2个不同概念 char buf[] = "aklgjdlsgjlkds"; //从左往右看，跳过类型，看修饰哪个字符 //如果是*， 说明指针指向的内存不能改变 //如果是指针变量，说明指针的指向不能改变，指针的值不能修改 const char *p = buf; // 等价于上面 char const *p1 = buf; //p[1] = '2'; //err p = "agdlsjaglkdsajgl"; //ok char * const p2 = buf; p2[1] = '3'; //p2 = "salkjgldsjaglk"; //err //p3为只读，指向不能变，指向的内存也不能变 const char * const p3 = buf; return 0;&#125; 五、内存管理5.1 作用域C语言变量的作用域分为： 代码块作用域(代码块是{}之间的一段代码) 函数作用域 文件作用域 局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点： 在一个函数内定义，只在函数范围内有效 在复合语句中定义，只在复合语句中有效 随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束 如果没有赋初值，内容为随机 123456789101112131415161718192021222324#include &lt;stdio.h&gt;void test()&#123; //auto写不写是一样的 //auto只能出现在&#123;&#125;内部 auto int b = 10; &#125;int main(void)&#123; //b = 100; //err， 在main作用域中没有b if (1) &#123; //在复合语句中定义，只在复合语句中有效 int a = 10; printf("a = %d\n", a); &#125; //a = 10; //err离开if()的复合语句，a已经不存在 return 0;&#125; 静态(static)局部变量 static局部变量的作用域也是在定义的函数内有效 static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值只初始化一次，但可以赋值多次 static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符 全局变量 在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量,须用extern声明 全局变量的生命周期和程序运行周期一样 不同文件的全局变量不可重名 静态(static)全局变量 在函数外定义,作用范围被限制在所定义的文件中 不同文件静态全局变量可以重名,但作用域不冲突 static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次 extern全局变量声明 extern int a; 声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义 全局函数和静态函数 在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。 注意： 允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。 同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。 所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。 总结： 类型 作用域 生命周期 auto变量 一对{}内 当前函数 static局部变量 一对{}内 整个程序运行期 extern变量 整个程序 整个程序运行期 static全局变量 当前文件 整个程序运行期 extern函数 整个程序 整个程序运行期 static函数 当前文件 整个程序运行期 register变量 一对{}内 当前函数 5.2 内存布局内存分区 C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。 在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况： 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。 代码区 存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。 全局初始化数据区/静态数据区（data段） 该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。 未初始化数据区（又叫 bss 区） 存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。 程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。 代码区（text segment） 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 未初始化数据区（BSS） 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 全局初始化数据区/静态数据区（data segment） 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 栈区（stack） 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 堆区（heap） 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 存储类型总结： 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 存储类型总结内存操作函数： 123456789101112#include &lt;string.h&gt;void *memset(void *s, int c, size_t n);功能：将s的内存区域的前n个字节以参数c填入void *memcpy(void *dest, const void *src, size_t n);功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。memmove()memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。int memcmp(const void *s1, const void *s2, size_t n);功能：比较s1和s2所指向内存区域的前n个字节 堆区内存分配和释放： 123456#include &lt;stdlib.h&gt;void *malloc(size_t size);功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。void free(void *ptr);功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int count, *array, n; printf("请输入要申请数组的个数:\n"); scanf("%d", &amp;n); array = (int *)malloc(n * sizeof (int)); if (array == NULL) &#123; printf("申请空间失败!\n"); return -1; &#125; //将申请到空间清0 memset(array, 0, sizeof(int)*n); for (count = 0; count &lt; n; count++) /*给数组赋值*/ array[count] = count; for (count = 0; count &lt; n; count++) /*打印数组元素*/ printf("%2d", array[count]); free(array); return 0;&#125; 返回堆区地址： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int *fun()&#123; int *tmp = NULL; tmp = (int *)malloc(sizeof(int)); *tmp = 100; return tmp;//返回堆区地址，函数调用完毕，不释放&#125;int main(int argc, char *argv[])&#123; int *p = NULL; p = fun(); printf("*p = %d\n", *p);//ok //堆区空间，使用完毕，手动释放 if (p != NULL) &#123; free(p); p = NULL; &#125; return 0;&#125; 六、复合类型(自定义类型)6.1 结构体定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 1234567891011121314151617181920212223//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//先定义类型，再定义变量（常用）struct stu s1 = &#123; "mike", 18 &#125;;//定义类型同时定义变量struct stu2&#123; char name[50]; int age;&#125;s2 = &#123; "lily", 22 &#125;;struct&#123; char name[50]; int age;&#125;s3 = &#123; "yuri", 25 &#125;; 结构体成员的使用： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;int main()&#123; struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, "abc"); s1.age = 18; printf("s1.name = %s, s1.age = %d\n", s1.name, s1.age); //如果是指针变量，通过-&gt;操作结构体成员 strcpy((&amp;s1)-&gt;name, "test"); (&amp;s1)-&gt;age = 22; printf("(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\n", (&amp;s1)-&gt;name, (&amp;s1)-&gt;age); return 0;&#125; 结构体套结构体： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;struct person&#123; char name[20]; char sex;&#125;;struct stu&#123; int id; struct person info;&#125;;int main()&#123; struct stu s[2] = &#123; 1, "lily", 'F', 2, "yuri", 'M' &#125;; int i = 0; for (i = 0; i &lt; 2; i++) &#123; printf("id = %d\tinfo.name=%s\tinfo.sex=%c\n", s[i].id, s[i].info.name, s[i].info.sex); &#125; return 0;&#125; 结构体套一级指针： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;//结构体类型的定义struct stu&#123; char *name; //一级指针 int age;&#125;;int main()&#123; struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-&gt;name = malloc(strlen("test") + 1); strcpy(p-&gt;name, "test"); p-&gt;age = 22; printf("p-&gt;name = %s, p-&gt;age=%d\n", p-&gt;name, p-&gt;age); printf("(*p).name = %s, (*p).age=%d\n", (*p).name, (*p).age); if (p-&gt;name != NULL) &#123; free(p-&gt;name); p-&gt;name = NULL; &#125; if (p != NULL) &#123; free(p); p = NULL; &#125; return 0;&#125; 结构体普通变量做函数参数： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include &lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//函数参数为结构体普通变量void set_stu(struct stu tmp)&#123; strcpy(tmp.name, "mike"); tmp.age = 18; printf("tmp.name = %s, tmp.age = %d\n", tmp.name, tmp.age);&#125;int main()&#123; struct stu s = &#123; 0 &#125;; set_stu(s); //值传递 printf("s.name = %s, s.age = %d\n", s.name, s.age); return 0;&#125; 结构体指针变量做函数参数： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include &lt;string.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//函数参数为结构体指针变量void set_stu_pro(struct stu *tmp)&#123; strcpy(tmp-&gt;name, "mike"); tmp-&gt;age = 18;&#125;int main()&#123; struct stu s = &#123; 0 &#125;; set_stu_pro(&amp;s); //地址传递 printf("s.name = %s, s.age = %d\n", s.name, s.age); return 0;&#125; 结构体数组名做函数参数： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;//结构体类型的定义struct stu&#123; char name[50]; int age;&#125;;//void set_stu_pro(struct stu tmp[100], int n)//void set_stu_pro(struct stu tmp[], int n)void set_stu_pro(struct stu *tmp, int n)&#123; int i = 0; for (i = 0; i &lt; n; i++) &#123; sprintf(tmp-&gt;name, "name%d%d%d", i, i, i); tmp-&gt;age = 20 + i; tmp++; &#125;&#125;int main()&#123; struct stu s[3] = &#123; 0 &#125;; int i = 0; int n = sizeof(s) / sizeof(s[0]); set_stu_pro(s, n); //数组名传递 for (i = 0; i &lt; n; i++) &#123; printf("%s, %d\n", s[i].name, s[i].age); &#125; return 0;&#125; 6.2 共用体(联合体) 联合union是一个能在同一个存储空间存储不同类型数据的类型； 联合体所占的内存长度等于其最长成员的长度，也有叫做共用体； 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用； 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖； 共用体变量的地址和它的各成员的地址都是同一地址。 6.3 枚举枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举类型定义： 1234enum 枚举名&#123; 枚举值表&#125;; 在枚举值表中应列出所有可用值，也称为枚举元素。 枚举值是常量，不能在程序中用赋值语句再对它赋值。 枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 … 6.4 typedeftypedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。 与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值 #define发生在预处理，typedef发生在编译阶段 七、文件操作磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 7.1 文件的打开和关闭文件指针 在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 123456789101112typedef struct&#123; short level; //缓冲区"满"或者"空"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 &#125;FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 文件的打开： 123#include &lt;stdio.h&gt;FILE * fopen(const char * filename, const char * mode);功能：打开文件 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n” 当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 以”二进制”方式打开文件，则读\写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出 123456789101112131415161718int main(void)&#123; FILE *fp = NULL; // 路径可以是相对路径，也可是绝对路径 fp = fopen("../test", "w"); //fp = fopen("..\\test", "w"); if (fp == NULL) //返回空，说明打开失败 &#123; //perror()是标准出错打印函数，能打印调用库函数出错原因 perror("open"); return -1; &#125; fclose(fp); return 0;&#125; 7.2 文件的顺序读写 按照字符读写文件fgetc、fputc 123456#include &lt;stdio.h&gt;int fputc(int ch, FILE * stream);功能：将ch转换为unsigned char后写入stream指定的文件中int fgetc(FILE * stream);功能：从stream指定的文件中读取一个字符 在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。#define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 123#include &lt;stdio.h&gt;int feof(FILE * stream);功能：检测是否读取到了文件结尾。**判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)**。 按照行读写文件fgets、fputs 123456#include &lt;stdio.h&gt;int fputs(const char * str, FILE * stream);功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\0' 不写入文件。 char * fgets(char * str, int size, FILE * stream);功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。 按照格式化文件fprintf、fscanf 123456#include &lt;stdio.h&gt;int fprintf(FILE * stream, const char * format, ...);功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\0' 为止。int fscanf(FILE * stream, const char * format, ...);功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 按照块读写文件fread、fwrite 123456789101112131415#include &lt;stdio.h&gt;size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式给文件写入内容参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针返回值： 成功：实际成功写入文件数据的块数目，此值和nmemb相等 失败：0#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);功能：以数据块的方式从文件中读取内容 7.3 文件的随机读写123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);功能：移动文件流（文件光标）的读写位置。参数： stream：已经打开的文件指针 offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence：其取值如下： SEEK_SET：从文件开头移动offset个字节 SEEK_CUR：从当前位置移动offset个字节 SEEK_END：从文件末尾移动offset个字节返回值： 成功：0 失败：-1#include &lt;stdio.h&gt;long ftell(FILE *stream);功能：获取文件流（文件光标）的读写位置。参数： stream：已经打开的文件指针返回值： 成功：当前文件流（文件光标）的读写位置 失败：-1#include &lt;stdio.h&gt;void rewind(FILE *stream);功能：把文件流（文件光标）的读写位置移动到文件开头。参数： stream：已经打开的文件指针返回值： 无返回值 7.4 获取文件状态12345678910#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *path, struct stat *buf);功能：获取文件状态信息参数： path：文件名 buf：保存文件信息的结构体返回值： 成功：0 失败-1 123456789101112131415struct stat &#123; dev_t st_dev; //文件的设备编号 ino_t st_ino; //节点 mode_t st_mode; //文件的类型和存取的权限 nlink_t st_nlink; //连到该文件的硬连接数目，刚建立的文件值为1 uid_t st_uid; //用户ID gid_t st_gid; //组ID dev_t st_rdev; //(设备类型)若此文件为设备文件，则为其设备编号 off_t st_size; //文件字节数(文件大小) unsigned long st_blksize; //块大小(文件系统的I/O 缓冲区大小) unsigned long st_blocks; //块数 time_t st_atime; //最后一次访问时间 time_t st_mtime; //最后一次修改时间 time_t st_ctime; //最后一次改变时间(指属性)&#125;; 12345678910111213141516#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **args)&#123; if (argc &lt; 2) return 0; struct stat st = &#123; 0 &#125;; stat(args[1], &amp;st); int size = st.st_size;//得到结构体中的成员变量 printf("%d\n", size); return 0;&#125; 7.5 删除文件、重命名文件名123456789101112131415161718#include &lt;stdio.h&gt;int remove(const char *pathname);功能：删除文件参数： pathname：文件名返回值： 成功：0 失败：-1#include &lt;stdio.h&gt;int rename(const char *oldpath, const char *newpath);功能：把oldpath的文件名改为newpath参数： oldpath：旧文件名 newpath：新文件名返回值： 成功：0 失败： - 1 7.6 文件缓冲区ANSI C标准采用“缓冲文件系统”处理数据文件。 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 磁盘文件的存取： 磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存 在内存中对文件进行编辑处理后，保存到磁盘中 程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率 更新缓冲区： 12345678#include &lt;stdio.h&gt;int fflush(FILE *stream);功能：更新缓冲区，让缓冲区的数据立马写到文件中。参数：stream：文件指针返回值： 成功：0 失败：-1]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Program-C 交叉编译]]></title>
    <url>%2F2016%2F05%2F05%2FProgram-C%2Fcompile%2F</url>
    <content type="text"><![CDATA[建立ARM交叉编译环境arm-none-linux-gnueabi-gcc1234567891011121314151617181920212223242526272829303132333435363738394041# add2line：将你要找的地址转成文件和行号，它要使用 debug 信息arm-none-linux-gnueabi-addr2line # ar：产生、修改和解开一个存档文件arm-none-linux-gnueabi-ar # as：gnu的汇编器arm-none-linux-gnueabi-as # ld：gnu 的连接器arm-none-linux-gnueabi-ld # gprof：gnu 汇编器预编译器arm-none-linux-gnueabi-gprof # nm：列出目标文件的符号和对应的地址arm-none-linux-gnueabi-nm # objdump：显示目标文件的信息arm-none-linux-gnueabi-objdump # readelf：显示 elf 格式的目标文件的信息arm-none-linux-gnueabi-readelf # strings：打印出目标文件中可以打印的字符串，有个默认的长度，为4arm-none-linux-gnueabi-strings # c++filt：C++ 和 java 中有一种重载函数，所用的重载函数最后会被编译转化成汇编的标，c++filt 就是实现这种反向的转化，根据标号得到函数名arm-none-linux-gnueabi-c++filt # objcopy：将某种格式的目标文件转化成另外格式的目标文件arm-none-linux-gnueabi-objcopy # ranlib：为一个存档文件产生一个索引，并将这个索引存入存档文件中arm-none-linux-gnueabi-ranlib # size：显示目标文件各个节的大小和目标文件的大小arm-none-linux-gnueabi-size # strip：剥掉目标文件的所有的符号信息arm-none-linux-gnueabi-strip C调用C++库和C++调用C库的方法 C调用C++库和C++调用C库的方法 C++调用C的静态库/动态库C++ 调用 C 的函数比较简单，直接使用 extern &quot;C&quot; {} 告诉编译器用 C 的规则去调用 C 函数就可以了。 CAdd.h 1int cadd(int x, int y); CAdd.c 1234567#include "CAdd.h"#include &lt;stdio.h&gt;int cadd(int x, int y) &#123; printf("from C function.\n"); return (x + y);&#125; 编译libCAdd.a 12gcc -c CAdd.c # 生成CAdd.oar -r libCAdd.a CAdd.o # 归档生成libCAdd.a 编译动态库 libCAdd.so 1gcc -shared -o libCAdd.so CAdd.c cppmain.cpp 123456789101112#include &lt;stdio.h&gt;extern "C" &#123; #include "CAdd.h"&#125;int main()&#123; int sum = cadd(1, 2); printf("1+2 = %d\n", sum); return 0;&#125; 编译main -l 指定库名称，优先链接so动态库，没有动态库再链接 .a 静态库。 1g++ -o cppmain cppmain.cpp -L. -lCAdd 运行 如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 1./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory 是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行 export LD_LIBRARY_PATH=./ 设置当前路径为系统链接库目录就可以了。 *注释 * 这里是在 include 头文件的外面包裹了 extern &quot;C&quot; { }，是告诉编译器以 C 语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论 C 还是 C++ 直接正常include就可以使用了。 CAdd.h 12 C 调用 C++ 的静态库C 语言没法直接调用 C++ 的函数，但可以使用包裹函数来实现。C++ 文件 .cpp 中可以调用 C 和 C++ 的函数，但是 C 代码 .c 只能调用 C 的函数，所以可以用包裹函数去包裹C ++ 函数，然后把这个包裹函数以 C 的规则进行编译，这样 C 就可以调用这个包裹函数了。 CppAdd.h 1int cppadd(int x, int y); CppAdd.cpp 1234567#include "CppAdd.h"#include &lt;stdio.h&gt;int cppadd(int x, int y) &#123; printf("from C++ function.\n"); return (x + y);&#125; 编译静态库 libCppAdd.a 12g++ -c CppAdd.cppar -r libCppAdd.a CppAdd.o CppAddWrapper.h 123456789#ifdef __cplusplusextern "C" &#123;#endifint cppaddwrapper(int x, int y);#ifdef __cplusplus&#125;#endif CppAddWrapper.cpp 123456789#include "CppAddWrapper.h"#include &lt;stdio.h&gt;#include "CppAdd.h"int cppaddwrapper(int x, int y) &#123; printf("from wrapper.\n"); int sum = cppadd(x, y); return sum;&#125; 编译 wrapper 静态库 libCppAddWrapper.a 12g++ -c CppAddWrapper.cppar -r libCppAddWrapper.a CppAddWrapper.o main.c 123456789#include "CppAddWrapper.h"#include &lt;stdio.h&gt;int main()&#123; int sum = cppaddwrapper(1, 2); printf("1+2 = %d\n", sum); return 0;&#125; 编译 main，同时指定 libCppAdd.a 和 libCppAddWrapper.a。 1gcc -o main main.c -L. -lCppAddWrapper -lCppAdd 或者把 libCppAdd.a 合并到 libCppAddWrapper.a 中 1234ar -x libCppAdd.a # 提取CppAdd.oar -x libCppAddWrapper.a # 提取CppAddWrapper.oar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.agcc -o main main.c -L. -lCppAddWrapper # 只需要连接libCppAddWrapper.a即可 如果是 C 调用 C++ 的 so 动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。 总结C/C++ 函数符号的区别 C++ 可以兼容 C 的语法，C/C++ 主要的区别是编译函数符号规则不一样，C 语言代码编译后的函数名还是原来函数名，C++ 代码编译后的函数名带有参数信息。 做个测试来检验一下。一个简单的函数，分别用 C 和 C++ 进行编译。 hello1.c 123int test(int a, char* b)&#123; return a;&#125; hello2.cpp 123int test(int a, char* b)&#123; return a;&#125; 编译 12gcc -c hello1.c # 生成hello1.og++ -c hello1.cpp # 生成hello2.o 查看符号表 1234$ nm hello1.o0000000000000000 T test$ nm hello2.o0000000000000000 T _Z4testiPc 从上面信息可以看出，C 语言编译后的函数符号还是原函数名，而 C++ 编译后的函数符号由test变成了 _Z4testiPc，从这个符号名字可以看出 test 前面有个数字 4 应该是函数名长度，test 后面 iPc 应该就是函数的参数签名。C++ 之所以这样规定编译后的函数符号是因为对面对象的 C++ 具有函数重载功能，以此来区分不同的函数。 .so 动态库、.a 静态库和 .o 中间文件的关系 程序的运行都要经过编译和链接两个步骤。假如有文件 add.c，可以使用命令 gcc -c add.c 进行编译，生成 add.o 中间文件，使用命令 ar -r libadd.a add.o 可以生成 libadd.a 静态库文件。静态库文件其实就是对 .o 中间文件进行的封装，使用 nm libadd.a 命令可以查看其中封装的中间文件以及函数符号。 链接静态库就是链接静态库中的 .o 文件，这和直接编译多个文件再链接成可执行文件一样。 动态链接库是程序执行的时候直接调用的“插件”，使用命令 gcc -shared -o libadd.so add.c 生成 so 动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个 so 打包到可执行文件中。如果没有头文件的话，可以使用 dlopen/dlsum 函数手动去加载相应的动态库。详细做法参考上一篇文章《C语言调用so动态库的两种方式》。 ar nm 命令的详细解释功能说明：建立或修改备存文件，或是从备存文件中抽取文件。 语 法：ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件] 补充说明：ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。 参 数： 123456789101112131415161718192021# 指令参数 -d 删除备存文件中的成员文件。 -m 变更成员文件在备存文件中的次序。 -p 显示备存文件中的成员文件内容。 -q 将问家附加在备存文件末端。 -r 将文件插入备存文件中。 -t 显示备存文件中所包含的文件。 -x 自备存文件中取出成员文件。# 选项参数 a&lt;成员文件&gt; 将文件插入备存文件中指定的成员文件之后。 b&lt;成员文件&gt; 将文件插入备存文件中指定的成员文件之前。 c 建立备存文件。 f 为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。 i&lt;成员文件&gt; 将问家插入备存文件中指定的成员文件之前。 o 保留备存文件中文件的日期。 s 若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。 S 不产生符号表。 u 只将日期较新文件插入备存文件中。 v 程序执行时显示详细的信息。 V 显示版本信息。 ar基本用法ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。 下面是ar命令的格式： 1$ ar [-]&#123;dmpqrtx&#125;[abcfilNoPsSuvV][membername] [count] archive files... 例如我们可以用ar rv libtest.a hello.o hello1.o来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。 {dmpqrtx} 中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下： d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。 m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。 p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。 q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。 r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 t：显示库的模块表清单。一般只显示模块名。 x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。 下面在看看可与操作选项结合使用的任选项： a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。 b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。 c：创建一个库。不管库是否存在，都将创建。 f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。 i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。 l：暂未使用 N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。 o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。 P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。 s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。 S：不创建目标文件索引，这在创建较大的库时能加快时间。 u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。 v：该选项用来显示执行操作选项的附加信息。 V：显示ar的版本。 nm基本用法命令nm用来列出目标文件的符号清单。下面是nm命令的格式： 1nm [-a|--debug-syms][-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic][-s|--print-armap][-o|--print-file-name][-n|--numeric-sort][-p|--no-sort][-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers][--help][--version][-t radix|--radix=radix][-P|--portability][-f format|--format=format][--target=bfdname][objfile...] 如果没有为 nm 命令指出目标文件，则 nm 假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。 -A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。 例如nm libtest.a的输出如下： 1234567891011121314CPThread.o:00000068 T Main__8CPThreadPv00000038 T Start__8CPThread00000014 T _._8CPThread00000000 T __8CPThread00000000 ? __FRAME_BEGIN__.......................................# 则nm -A 的输出如下：libtest.a:CPThread.o:00000068 T Main__8CPThreadPvlibtest.a:CPThread.o:00000038 T Start__8CPThreadlibtest.a:CPThread.o:00000014 T _._8CPThreadlibtest.a:CPThread.o:00000000 T __8CPThreadlibtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__.................................................................. -a或–debug-syms：显示调试符号。 -B：等同于–format=bsd，用来兼容MIPS的nm。 -C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g或–extern-only：仅显示外部符号。 -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix或–radix=radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。 –target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。 -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V或–version：显示nm的版本号。 –help：显示nm的任选项。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统编程]]></title>
    <url>%2F2016%2F05%2F01%2FProgram-C%2FLinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux Note C 语言之解析局部变量返回一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。 准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。 1. Linux 基础命令 stat命令用于显示文件的状态信息。stat命令的输出信息比 ls 命令的输出信息要更详细。 1.0 创建用户创建用户命令两条： adduser useradd 用户删除命令： userdel 两个用户创建命令之间的区别： adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。 12345678910111213141516171819202122232425262728# 使用 adduser$ adduser apple正在添加用户"apple"...正在添加新组"apple" (1007)...正在添加新用户"apple" (1007) 到组"apple"...创建主目录"/home/apple"...正在从"/etc/skel"复制文件...输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码正在改变 apple 的用户信息请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y# 这样在创建用户名时，就创建了用户的主目录以及密码。# 默认情况下：# adduser在创建用户时会主动调用 /etc/adduser.conf；# 在创建用户主目录时默认在/home下，而且创建为 /home/用户名 # 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。# 为用户指定shell版本为：/bin/bash 因此 adduser 常用参数选项为： --home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。 --quiet： 即只打印警告和错误信息，忽略其他信息。 --debug： 定位错误信息。 --conf： 在创建用户时使用指定的configuration文件。 --force-badname： 默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。 12# 使用 useradd# 注意： 在使用useradd命令创建新用户时，不会为用户创建主目录，不会为用户指定shell版本，不会为用户创建密码。 为用户指定参数的 useradd 命令，常用命令行选项： -d： 指定用户的主目录 -m： 如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用。 -s： 指定用户登录时的shell版本 -M： 不创建主目录 12345678# 解释： # -d “/home/tt" ：就是指定/home/tt为主目录# -m 就是如果/home/tt不存在就强制创建# -s 就是指定shell版本 $ sudo useradd -d "/home/tt" -m -s "/bin/bash" tt# 修改 tt 密码：$ sudo passwd tt 删除用户命令 userdel 只删除用户： sudo userdel 用户名 连同用户主目录一块删除： sudo userdel -r 用户名 相关文件： /etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息 /etc/shadow - 使 用 者 帐 号 资 讯 加 密 /etc/group - 群 组 资 讯 /etc/default/useradd - 定 义 资 讯 /etc/login.defs - 系 统 广 义 设 定 /etc/skel - 内 含 定 义 档 的 目 录 为组用户增加 root 权限： 12345# 修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示：## Allow root to run any commands anywhereroot ALL=(ALL) ALLtommy ALL=(ALL) ALL# 修改完毕，现在可以用 tommy 帐号登录，然后用命令 sudo – ，即可获得 root 权限进行操作。 1.1 ln 软硬链接硬链接 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用: ln 命令来建立硬链接。 尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处： （1）不可以在不同文件系统的文件间建立链接 （2）只有超级用户才可以为目录创建硬链接。 软链接（符号链接） 软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。建立软链接，只要在 ln 后面加上选项 –s 12$ ln -s abc cde # 建立 abc 的软连接$ ln abc cde # 建立 abc 的硬连接， 删除链接 12$ rm -rf symbolic_name$ unlink symbolic_name 1.2 find grep xargs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# 列出当前目录及子目录下所有文件和文件夹$ find .# 在/home目录下查找以.txt结尾的文件名 但忽略大小写$ find /home -iname "*.txt"# 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件$ find . \( -name "*.txt" -o -name "*.pdf" \)$ find . -name "*.txt" -o -name "*.pdf"# 匹配文件路径或者文件$ find /usr/ -path "*local*"# 基于正则表达式匹配文件路径$ find . -regex ".*\(\.txt\|\.pdf\)$"# 同上，但忽略大小写$ find . -iregex ".*\(\.txt\|\.pdf\)$"# 找出/home下 不是 以 .txt 结尾的文件$ find /home ! -name "*.txt"# 根据文件类型进行搜索# 类型参数列表：# f 普通文件# l 符号连接# d 目录# c 字符设备# b 块设备# s 套接字# p Fifo$ find . -type 类型参数# 基于目录深度搜索 向下最大深度限制为3$ find . -maxdepth 3 -type f# 搜索出深度距离当前目录至少2个子目录的所有文件$ find . -mindepth 2 -type f# 根据文件时间戳进行搜索# UNIX/Linux文件系统每个文件都有三种时间戳：# - 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。# - 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。# - 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。$ find . -type f 时间戳# 搜索最近七天内被访问过的所有文件$ find . -type f -atime -7# 搜索恰好在七天前被访问过的所有文件$ find . -type f -atime 7# 搜索超过七天内被访问过的所有文件$ find . -type f -atime +7# 搜索访问时间超过10分钟的所有文件$ find . -type f -amin +10# 找出比 file.log 修改时间更长的所有文件$ find . -type f -newer file.log# 根据文件大小进行匹配# 文件大小单元：# b —— 块（512字节）# c —— 字节# w —— 字（2字节）# k —— 千字节# M —— 兆字节# G —— 吉字节$ find . -type f -size 文件大小单元# 搜索大于10KB的文件$ find . -type f -size +10k# 搜索小于10KB的文件$ find . -type f -size -10k# 搜索等于10KB的文件$ find . -type f -size 10k# 删除匹配文件 删除当前目录下所有.txt文件$ find . -type f -name "*.txt" -delete# 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件$ find . -type f -perm 777# 找出当前目录下权限不是644的php文件$ find . -type f -name "*.php" ! -perm 644# 找出当前目录用户tom拥有的所有文件$ find . -type f -user tom# 找出当前目录用户组sunk拥有的所有文件$ find . -type f -group sunk# 借助-exec选项与其他命令结合使用 # 找出当前目录下所有root的文件，并把所有权更改为用户tom# &#123;&#125; 用于与 -exec 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。$ find .-type f -user root -exec chown tom &#123;&#125; \;# 找出自己家目录下所有的.txt文件并删除# -ok 和 -exec 行为一样，不过它会给出提示，是否执行相应的操作。$ find $HOME/. -name "*.txt" -ok rm &#123;&#125; \;# 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中$ find . -type f -name "*.txt" -exec cat &#123;&#125; \;&gt; all.txt# 将30天前的.log文件移动到old目录中$ find . -type f -mtime +30 -name "*.log" -exec cp &#123;&#125; old \;# 找出当前目录下所有.txt文件并以 “File:文件名” 的形式打印出来$ find . -type f -name "*.txt" -exec printf "File: %s\n" &#123;&#125; \;# 因为单行命令中 -exec 参数中无法使用多个命令，以下方法可以实现在 -exec 之后接受多条命令$ -exec ./text.sh &#123;&#125; \;# 搜索但跳出指定的目录# 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk$ find . -path "./sk" -prune -o -name "*.txt" -print# find其他技巧收集# 要列出所有长度为零的文件$ find . -empty# -exec 接收 find 传过来的所有内容，容易造成溢出# xargs find 的好伴侣，xargs 将 find 命令查找的结果分成若干模块输出给后面的指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# grep 内容过滤# 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：$ grep match_pattern file_name$ grep "match_pattern" file_name# 输出除之外的所有行 -v 选项：$ grep -v "match_pattern" file_name# 标记匹配颜色 --color=auto 选项：$ grep "match_pattern" file_name --color=auto# 使用正则表达式 -E 选项：$ grep -E "[1-9]+"$ egrep "[1-9]+"# 只输出文件中匹配到的部分 -o 选项：$ echo this is a test line. | grep -o -E "[a-z]+\."line.$ echo this is a test line. | egrep -o "[a-z]+\."line.# 统计文件或者文本中包含匹配字符串的行数 -c 选项：$ grep -c "text" file_name# 输出包含匹配字符串的行数 -n 选项：$ grep "text" -n file_name$ cat file_name | grep "text" -n# 搜索多个文件并查找匹配文本在哪些文件中：$ grep -l "text" file1 file2 file3...# 在多级目录中对文本进行递归搜索：$ grep "text" . -r -n# 忽略匹配样式中的字符大小写：$ echo "hello world" | grep -i "HELLO"# 选项 -e 制动多个匹配样式：$ echo this is a text line | grep -e "is" -e "line" -oisline# 也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。cat patfileaaabbb$ echo aaa bbb ccc ddd eee | grep -f patfile -o# 在grep搜索结果中包括或者排除指定文件：# 只在目录中所有的.php和.html文件中递归搜索字符"main()"$ grep "main()" . -r --include *.&#123;php,html&#125;# 在搜索结果中排除所有README文件$ grep "main()" . -r --exclude "README"# 在搜索结果中排除filelist文件列表里的文件$ grep "main()" . -r --exclude-from filelist# 使用0值字节后缀的grep与xargs：# 测试文件：$ echo "aaa" &gt; file1$ echo "bbb" &gt; file2$ echo "aaa" &gt; file3$ grep "aaa" file* -lZ | xargs -0 rm# 执行后会删除 file1 和 file3，grep 输出用 -Z 选项来指定以 0 值字节作为终结符文件名（\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和 -l 结合使用。# grep静默输出：# 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。$ grep -q "test" filename# 打印出匹配文本之前或者之后的行：# 显示匹配某个结果 之后的3行，使用 -A 选项：$ seq 10 | grep "5" -A 3# 显示匹配某个结果 之前的3行，使用 -B 选项：$ seq 10 | grep "5" -B 3# 显示匹配某个结果的 前三行和后三行，使用 -C 选项：$ seq 10 | grep "5" -C 3 12345678910111213141516# xargs# 参数：-a file 从文件中读入作为sdtin-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p 当每次执行一个argument的时候询问一次用户。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-t 表示先打印命令，然后再执行。-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替。-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。-L num 从标准输入一次读取 num 行送给 command 命令。-l 同 -L。-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。-x exit的意思，主要是配合-s使用。。-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。 1.3 VIM设置 ~/.bashrc 添加 set -o vi – 可以直接使用 vim 的各种快捷键 VIM 快捷键： 1.4 GCCgcc 工作流程 123456789101112131415# 预处理 头文件展开 宏替换$ gcc -E hello.chello.i# 生成汇编代码$ gcc -S hello.ihello.s# 将汇编编译成二进制文件 $ gcc -c hell0.shello.o# 链接$ gcc hello.oa.out gcc 参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 指定编译输出的名字$ gcc main.c -o main# 通过 -Wall 参数启用所有警告$ gcc -Wall main.c -o main# 使用 -E 参数只产生预处理输出$ gcc -E main.c &gt; main.i# 使用 -S 参数只产生汇编代码$ gcc -S main.c &gt; main.s# 使用 -C 参数只产生编译的代码$ gcc -C main.c# 上面的代码产生main.o, 包含机器级别的代码或者编译的代码。# 使用-save-temps参数产生所有的中间步骤的文件$ gcc -save-temps main.c$ lsa.out main.c main.i main.o main.s# 使用 -l 参数链接共享库$ gcc -Wall main.c -o main -lCPPfile# 使用 -fPIC 产生位置无关的代码# 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。# 下面的例子产生libCfile.so动态库。$ gcc -c -Wall -Werror -fPIC Cfile.c$ gcc -shared -o libCfile.so Cfile.o# 产生共享库的时候使用了-fPIC 参数。# 注意 -shared 产生共享库。# 使用 -V 打印所有的执行命令$ gcc -Wall -v main.c -o mainUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper...# 使用 -D 参数可以使用编译时的宏$ gcc -Wall -D MY_MACRO main.c -o main# 使用 -Werror 将警告升级为错误$ gcc -Wall -Werror main.c -o main# 使用 @ 参数从文件中读取参数# gcc参数可以从文件中读取，通过@后跟文件名的方式提供， 多个参数可以使用空格区隔。$ cat opt_file -Wall -omain$ gcc main.c @opt_file# 使用参数 -I 指定头文件的文件夹$ gcc -I/home/codeman/include input-file.c# -I 取消前一个参数功能，一般用在 -Idir 之后。# 使用参数-std指定支持的c++/c的标准$ gcc -std=c++11 hello-world.cpp# 使用 -static 生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件)$ gcc main.c -static -o main -lpthread# 相反的使用 -shared 使用动态库链接。# 使用 -g 用于 gdb 调试$ gcc main.c -static -o main -g# -lstdc++ 指定 gcc 以 c++ 方式编译$ gcc main.cpp -lstdc++ -o main# -O 优化选项， 1-3 越高优先级越高$ gcc main.cpp -lstdc++ -o main -O1# 使用 -M 生成文件关联的信息$ gcc -M main.cmain.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \ /usr/include/features.h /usr/include/sys/cdefs.h \ /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \ /usr/include/gnu/stubs-64.h \ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h \ /usr/include/bits/types.h /usr/include/bits/typesizes.h \ /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h \ /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h 1.5 库文件制作静态库制作和使用 123456789101112131415161718# 步骤# 1. 编译为 .o 文件# 2. 将 .o 文件打包：ar rcs libmycalc.a file1.0 file2.o ...# 3. 将头文件与库一起发布# 查看库信息$ nm libmycalc.a# 使用# 编译时 需要加静态库名（记得路径），-I 包含头文件$ gcc main.c -o app -I include/ -L lib/ -lmycalc# 优点：# 1. 执行快# 2. 发布应用时不需要发布库# 缺点：# 1. 执行程序体积比较大# 2. 库变更时需要重新编译应用 动态库制作和使用 123456789101112131415161718192021222324# 步骤# 1. 编译与位置无关的代码，生成 .o 关键参数 -fPIC# 2. 将 .o 文件打包， 关键参数 -shared# 3. 将库与头文件一起发布$ gcc -shared -o libcalc.so *.o# 使用# -L 指定动态库路径 -I 指定库名$ gcc main.c -o app -I include/ -L lib/ -lcalc# ldd 查看库依赖$ ldd libcalc.so# 优点：# 1. 执行程序体积小# 2. 库变更时，一般不需要重新发布动态库# 缺点：# 1. 执行时需要加载动态库，相对而言，比静态库慢# 2. 发布应用时需要同时发布动态库# 解决不能加载动态库的问题# 1. 拷贝到 /lib 下。 一般不允许# 2. 将库路径增加到环境变量 LD_LIBRARY_PATH 中，不是特别推荐# 3. 配置 /etc/ld.so.conf 文件，增加 当前项目库路径，执行 sudo ldconfig -v 1.6 Makefilemakefile 的三要素： 目标 依赖 规则命令 写法： 目标：依赖 tab键 规则命令 12app: main.c add.c sub.c div.c mul.c gcc -o app -I./include/ main.c add.c sub.c div.c mul.c 如果更改其中一个文件，所有的源码都重新编译 可以考虑编译过程分解，先生成 .o 文件，然后使用 .o 文件编程结果 规则是递归的，依赖文件如果比目标文件新，则重新生成目标文件 1234567891011121314ObjFiles=main.o add.o sub.o div.o mul.oapp: $(ObjFiles) gcc -o app -I./include/ $(ObjFiles)main.o: main.c gcc -c main.c -I./include/add.o: add.c gcc -c add.c -I./include/ sub.o: sub.c gcc -c sub.c -I./include/ div.o: div.c gcc -c div.c -I./include/mul.o: mul.c gcc -c mul.c -I./include/ makefile 的隐含规则：默认处理第一个目标 123456789# get all .c filesSrcFiles=$(wildcard *.c)# all .c files --&gt; .o fileObjFiles=$(patsubst %.c,%.o,$(SrcFiles))test: echo $(SrcFiles) echo $(ObjFiles) makefile 变量： $@ 代表目标 $^ 代表全部依赖 $&lt; 第一个依赖 $? 第一个变化的依赖 1234567891011121314151617181920212223# get all .c filesSrcFiles=$(wildcard *.c)# all .c files --&gt; .o fileObjFiles=$(patsubst %.c,%.o,$(SrcFiles))all:app# 目标文件用法 $(Var)app: $(ObjFiles) gcc -o $@ -I./include/ $(ObjFiles) # 模式匹配规则， $@ $&lt; 这样的变量，只能在规则中出现%.o:%.c gcc -c $&lt; -I./include/ -o $@# @ 在规则前代表不输出该条规则的命令# - 规则前的“-”，代表该条规则报错，仍然继续执行# .PHONY 定义伪目标，防止有歧义.PHONY:clean allclean: -@rm -f *.o -@rm -f app make -f makefile1 指定makefile文件进行编译 12345678910SrcFiles=$(wildcard *.c)TargetFiles=$(patsubst %.c,%,$(SrcFiles))all:$(TargetFiles)%:%.c gcc -o $@ %^ clean: rm -f $(TargetFiles) 1.7 gdb 调试 gdb 调试入门，大牛写的高质量指南 gdb 调试利器 启动gdb：gdb app 在gdb启动程序： r(un) – 启动 可以带参数启动 start – 启动 - 停留在main函数，分步调试 n(ent) – 下一条指令 s(tep) – 下一条指令，可以进入函数内部，库函数不能进 q(uit) – 退出 gdb b(reak) num – 指定行号，函数, 文件:行号 设置断点 b 行号 – 主函数所在文件的行 b 函数名 b 文件名:行号 l(ist) 文件：行号 – 查看代码 l – 显示主函数对应的文件 l 文件名:行号 info b – 查看断点信息 d(el) num – 删除断点 c – continue 跳到下一个断点 p(rint) – 打印参数，或者变量值 ptype 变量 – 查看变量类型 set – 设置变量的值 set argc=4 set argv[1]=“12” set argv[2] = “7” display argc – 跟踪显示参数或者变量的变化 info display undisplay num b num if xx == xx – 条件断点 gdb跟踪core 设置生成 core ：ulimit -c unlimited 取消生成 core： ulimit -c 0 设置 core 文件格式：/proc/sys/kernel/core_pattern 文件不能 vi，可以用后面的套路：echo “/corefile/core-%e-%p-%t” &gt; core_pattern core 文件如何使用： gdb app core 如果看不到在哪儿core 可以用 where 查看在哪儿产生的 core 2. 系统api与库函数的关系 3. Linux 系统编程ulimit -a 查看所有资源的上限 env 查看环境变量 echo $PATH 打印指定的环境变量 char *getenv() 获取环境变量 创建一个进程： pid_t fork(void) 返回值： 失败 -1 成功，返回两次 父进程返回子进程的 id 子进程返回 0 获得pid，进程 id，获得当前进程 pid_t getpid(void) 获得当前进程父进程的 id pid_t getppid(void) ps ajx 查看父进程和子进程相关信息 进程共享： 父子进程之间在fork后，有哪些相同和不同： 父子相同处： 全局变量 data、text、栈、堆、环境变量 用户 ID 宿主目录、进程工作目录、信号处理方式… 父子不同处： 进程 ID 父进程 ID 进程运行时间 闹钟（定时器） 未决信号集 似乎，子进程复制了父进程 0-3G 用户空间内容，以及父进程的 PCB， 但 pid 不同。真的每 fork 一个子进程都要将父进程的 0-3G 地址空间完全拷贝一份，然后在映射至屋里内存吗？当然不是，父子进程间遵循读时共享写时复制。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 孤儿进程与僵尸进程： 孤儿进程 父进程死了，子进程被 init 进程领养 僵尸进程 子进程死了，父进程没有回收子进程的资源（PCB） 回收子进程，知道子进程的死亡原因，作用： 阻塞等待 回收子进程资源 查看死亡原因 pid_t wait(int *status) status 传出参数 返回值 成功返回终止的子进程 ID 失败 返回 -1 子进程的死亡原因： 正常死亡 WIFEXITED 如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出的状态 非正常死亡 WIFSIGNALED 如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号 pid_t waitpid(pid_t pid, int *status, int options) pid &lt; -1 组ID -1 回收任意 0 回收和调用进程组 ID 相同组内的子进程 &gt;0 回收指定的 pid option 0 与 wait 相同，也会阻塞 WNOHANG 如果当前没有子进程退出，会立刻返回 返回值 如果设置了 WNOHANG ，那么如果没有子进程退出，返回 0 如果有子进程退出返回退出的 pid 失败返回 -1 （没有子进程） 3.1 IPC 概念IPC ： 进程间通信，通过内核提供的缓存区进行数据交换的机制 IPC 通信的方式有几种： pipe 管道 – 最简单 fifo 有名管道 mmap 文件映射共享IO – 速度最快 本地 socket 最稳定 信号 携带信息量最小 共享内存 消息队列 读管道： 写端全部关闭 – read 读到 0， 想当于读到文件末尾 写端没有全部关闭 有数据 – read 读到数据 没有数据 – read 阻塞 fcntl 函数可以更改非阻塞 写管道： 读端全部关闭 – ？ 产生一个信号 SIGPIPE，程序异常终止 读端未全部关闭 管道已满 – write 阻塞 – 如果要显示现象，读端一直不读，写端狂写。 管道未满 – write 正常写入 管道缓冲区大小 可以使用 ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为： 1pipe size (512 bytes, -p) 8 也可以使用 fpathconf 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt; long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno 管道的优劣 优点： 简单，相比信号，套接字实现进程间通信，简单很多。 缺点： 只能单向通信，双向通信需建立两个管道。 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 FIFO通信 FIFO 有名管道，实现无血缘关系进程通信 创建一个管道的伪文件 mkfifo myfifo 命令创建 也可以使用函数 int mkfifo(const char *pathname, mode_t mode); 内核会针对 fifo 文件开辟一个缓存区，操作 fifo 文件，可以操作缓存区，实现进程间通信 – 实际上就是文件读写 mmap映射共享区 1void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 返回： 成功：返回创建的映射区首地址； 失败：MAP_FAILED宏 参数： addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL length： 欲创建映射区的大小 prot： 映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区) MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。（共享的） MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。（私有的） fd： 用来建立映射区的文件描述符 offset： 映射文件的偏移(4k的整数倍) 释放映射区 1int munmap(void *addr, size_t length); 匿名映射 通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。 使用 MAP_ANONYMOUS(或 MAP_ANON )， 如: 12int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); // "4"随意举例，该位置表大小，可依实际需要填写。 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 123456/*/dev/zero 聚宝盆，可以随意映射/dev/null 无底洞，一般错误信息重定向到这个文件中*/fd = open("/dev/zero", O_RDWR);p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0); 信号的概念 信号的特点 简单，不能带大量信息，满足特定条件发生 信号的机制 进程 B 发送给进程 A ，内核产生信号，内核处理 信号的产生 按键产生 函数调用 kill、raise、abort 定时器 alarm、setitimer 命令产生 kill 硬件异常、段错误、浮点型错误、总线错误、SIGPIPE 信号的状态 产生 递达 信号到达并且处理完 未决 信号被阻塞 信号的默认处理方式 忽略 执行默认动作 捕捉 信号的 4 要素 编号 事件 名称 默认处理动作 忽略 终止 终止 + core 暂停 继续 3.2 进程和线程 进程组 会话 守护进程 创建一个会话需要注意以下 5 点注意事项： 调用进程不能是进程组组长，该进程编程新会话首进程（session header） 该进程成为一个新进程组的组长进程 新会话丢弃原有的控制终端，该会话没有控制终端 该调用进程是组长进程，则出错返回 建立会话时，先调用fork，父进程终止，子进程调用 setsid 守护进程： Daemon 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 session 。并成为 session leader。 创建守护进程模型： 创建子进程，父进程退出 所有工作在子进程中进行形式上脱离了控制终端 在子进程中创建新会话 setsid() 函数 使子进程完全能独立出来，脱离控制 改变当前目录为根目录 chdir() 函数 防止占用可卸载的文件系统 也可以换成其他路径 重设文件权限掩码 umask() 函数 防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性 关闭文件描述符 继承的打开文件不会用到，浪费系统资源，无法卸载 开始执行守护进程核心工作 守护进程退出处理程序模型 会话：进程组的更高一级，多个进程组对应一个会话 进程组：多个进程在同一个组，第一个进程默认是进程组的组长 创建会话的时候，组长不可以创建，必须是组员创建。 创建会话的步骤：创建子进程，父进程终止，子进程当会长 守护进程的步骤： 创建子进程 fork 父进程退出 子进程当会长 setsid 切换工作目录 $HOME 设置掩码 umask 关闭文件描述符，为了避免浪费资源 执行核心逻辑 退出 12int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;signal.h&gt;int main(int argc, char *argv[])&#123; char strFileName[256] = &#123;0&#125;; while (1) &#123; memset(strFileName, 0x00, sizeof(strFileName)); sprintf(strFileName, "%s/log/Mr.Miaow.%ld", getenv("HOME"), time(NULL)); int fd = open(strFileName, O_RDWR | O_CREAT, 0666); if (fd &lt; 0) &#123; perror("open err"); exit(1); &#125; close(fd); sleep(5); &#125; return 0;&#125; 扩展了解： 通过 nohup 指令也可以达到守护进程创建的效果 nohup cmd [&gt; 1.log] &amp; nohup 指令会让 cmd 收不到 SIGHUP 信号 &amp; 代表后台运行 线程是最小的执行单位，进程是最小的系统资源分配单位 查看 LWP 号：ps -Lf pid 查看指定线程的 lwp 号 线程非共享资源 线程 ID 处理器现场和栈指针（内核栈） 独立的栈空间（用户空间栈） errno 变量 信号屏蔽字 调度优先级 线程优缺点： 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数 不稳定 调试、编写困难 对信号支持不好 1234567891011alias echomake=`cat ~/bin/makefile.template &gt;&gt; makefile`$ cat ~/bin/makefile.template# create by Mr.Miaow `date +%Y%m%d`SrcFiles=$(wildcard *.c)TargetFiles=$(patsubst %.c,%,$(SrcFiles))all:$(TargetFiles)%:%.c gcc -o $@ %&lt; -lpthread -gclean: -rm -f $(TargetFiles) 线程退出注意事项： 在线程中使用pthread_exit 在线程中使用 return （主控线程return 代表退出进程） exit 代表退出整个进程 线程回收函数： 1int pthread_join(pthread_t thread, void **retval); 杀死线程： 1int pthread_cancel(pthread_t thread); 被pthread_cancel 杀死的线程，退出状态为 PTHREAD_CANCELED 线程分离： 1int pthread_detach(pthread_t thread); 此时不需要 pthread_join回收资源 线程 ID 在进程内部是唯一的 进程属性控制： 初始化线程属性 1int pthread_attr_init(pthread_attr_t *attr); 销毁线程属性 1int pthread_attr_destroy(pthread_attr_t *attr); 设置属性分离态 1234567int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);# attr init 初始化的属性# detachstate# - PTHREAD_CREATE_DETACHED 线程分离# - PTHREAD_CREATE_JOINABLE 允许回收int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); 查看线程库版本： 1$ getconf GNU_LIBPTHREAD_VERSION 创建多少个线程？ cpu核数 * 2 + 2 线程同步： 协调步骤，顺序执行 解决同步的问题：加锁 mutex 互斥量： 123456789pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER; // 常量初始化，此时可以使用initpthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_destroy(pthread_mutex_t *mutex); 读写锁的特点：读共享，写独占，写优先级高 读写说任然是一把锁，有不同状态： 未加锁 读锁 写锁 123456789int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 条件变量（生产者消费者模型）： 1234567891011pthread_cond_t cond = PTHREAD_COND_INITIALIZER;int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);// 唤醒至少一个阻塞在条件变量 cond 上的线程int pthread_cond_signal(pthread_cond_t *cond);// 唤醒阻塞在条件变量 cond 上的全部线程int pthread_cond_broadcast(pthread_cond_t *cond);// 条件变量阻塞等待int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);// 超时等待int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);int pthread_cond_destroy(pthread_cond_t *cond); 信号量 加强版的互斥锁： 信号量是进化版的互斥量，允许多个线程访问共享资源 1234567891011121314151617#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);# pshared# - 0 代表线程信号量# - 非0 代表进程信号量# value 定义信号量的个数// 申请信号量，申请成功 value--int sem_wait(sem_t *sem);// 释放信号量 value++int sem_post(sem_t *sem);int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_destroy(sem_t *sem);// Link with -pthread. 文件锁： 1234#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
</search>
